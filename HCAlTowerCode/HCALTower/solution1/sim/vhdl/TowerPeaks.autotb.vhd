-- ==============================================================
-- File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
-- Version: 2016.4
-- Copyright (C) 1986-2016 Xilinx, Inc. All Rights Reserved.
-- 
-- ==============================================================

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.std_logic_unsigned.all;
use IEEE.std_logic_arith.all;
use IEEE.numeric_std.all;
use ieee.std_logic_textio.all;
use std.textio.all;


entity apatb_TowerPeaks_top is
  generic (
       AUTOTB_CLOCK_PERIOD_DIV2 :   TIME := 5.00 ns;
       AUTOTB_TVIN_towerET_0_0 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_0_0.dat";
       AUTOTB_TVIN_towerET_0_1 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_0_1.dat";
       AUTOTB_TVIN_towerET_0_2 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_0_2.dat";
       AUTOTB_TVIN_towerET_0_3 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_0_3.dat";
       AUTOTB_TVIN_towerET_1_0 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_1_0.dat";
       AUTOTB_TVIN_towerET_1_1 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_1_1.dat";
       AUTOTB_TVIN_towerET_1_2 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_1_2.dat";
       AUTOTB_TVIN_towerET_1_3 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_1_3.dat";
       AUTOTB_TVIN_towerET_2_0 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_2_0.dat";
       AUTOTB_TVIN_towerET_2_1 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_2_1.dat";
       AUTOTB_TVIN_towerET_2_2 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_2_2.dat";
       AUTOTB_TVIN_towerET_2_3 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_2_3.dat";
       AUTOTB_TVIN_towerET_3_0 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_3_0.dat";
       AUTOTB_TVIN_towerET_3_1 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_3_1.dat";
       AUTOTB_TVIN_towerET_3_2 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_3_2.dat";
       AUTOTB_TVIN_towerET_3_3 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_3_3.dat";
       AUTOTB_TVIN_towerET_4_0 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_4_0.dat";
       AUTOTB_TVIN_towerET_4_1 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_4_1.dat";
       AUTOTB_TVIN_towerET_4_2 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_4_2.dat";
       AUTOTB_TVIN_towerET_4_3 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_4_3.dat";
       AUTOTB_TVIN_towerET_5_0 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_5_0.dat";
       AUTOTB_TVIN_towerET_5_1 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_5_1.dat";
       AUTOTB_TVIN_towerET_5_2 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_5_2.dat";
       AUTOTB_TVIN_towerET_5_3 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_5_3.dat";
       AUTOTB_TVIN_towerET_6_0 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_6_0.dat";
       AUTOTB_TVIN_towerET_6_1 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_6_1.dat";
       AUTOTB_TVIN_towerET_6_2 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_6_2.dat";
       AUTOTB_TVIN_towerET_6_3 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_6_3.dat";
       AUTOTB_TVIN_towerET_7_0 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_7_0.dat";
       AUTOTB_TVIN_towerET_7_1 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_7_1.dat";
       AUTOTB_TVIN_towerET_7_2 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_7_2.dat";
       AUTOTB_TVIN_towerET_7_3 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_7_3.dat";
       AUTOTB_TVIN_towerET_8_0 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_8_0.dat";
       AUTOTB_TVIN_towerET_8_1 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_8_1.dat";
       AUTOTB_TVIN_towerET_8_2 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_8_2.dat";
       AUTOTB_TVIN_towerET_8_3 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_8_3.dat";
       AUTOTB_TVIN_towerET_9_0 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_9_0.dat";
       AUTOTB_TVIN_towerET_9_1 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_9_1.dat";
       AUTOTB_TVIN_towerET_9_2 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_9_2.dat";
       AUTOTB_TVIN_towerET_9_3 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_9_3.dat";
       AUTOTB_TVIN_towerET_10_0 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_10_0.dat";
       AUTOTB_TVIN_towerET_10_1 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_10_1.dat";
       AUTOTB_TVIN_towerET_10_2 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_10_2.dat";
       AUTOTB_TVIN_towerET_10_3 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_10_3.dat";
       AUTOTB_TVIN_towerET_11_0 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_11_0.dat";
       AUTOTB_TVIN_towerET_11_1 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_11_1.dat";
       AUTOTB_TVIN_towerET_11_2 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_11_2.dat";
       AUTOTB_TVIN_towerET_11_3 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_11_3.dat";
       AUTOTB_TVIN_towerET_12_0 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_12_0.dat";
       AUTOTB_TVIN_towerET_12_1 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_12_1.dat";
       AUTOTB_TVIN_towerET_12_2 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_12_2.dat";
       AUTOTB_TVIN_towerET_12_3 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_12_3.dat";
       AUTOTB_TVIN_towerET_13_0 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_13_0.dat";
       AUTOTB_TVIN_towerET_13_1 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_13_1.dat";
       AUTOTB_TVIN_towerET_13_2 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_13_2.dat";
       AUTOTB_TVIN_towerET_13_3 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_13_3.dat";
       AUTOTB_TVIN_towerET_14_0 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_14_0.dat";
       AUTOTB_TVIN_towerET_14_1 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_14_1.dat";
       AUTOTB_TVIN_towerET_14_2 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_14_2.dat";
       AUTOTB_TVIN_towerET_14_3 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_14_3.dat";
       AUTOTB_TVIN_towerET_15_0 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_15_0.dat";
       AUTOTB_TVIN_towerET_15_1 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_15_1.dat";
       AUTOTB_TVIN_towerET_15_2 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_15_2.dat";
       AUTOTB_TVIN_towerET_15_3 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_15_3.dat";
       AUTOTB_TVIN_towerET_16_0 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_16_0.dat";
       AUTOTB_TVIN_towerET_16_1 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_16_1.dat";
       AUTOTB_TVIN_towerET_16_2 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_16_2.dat";
       AUTOTB_TVIN_towerET_16_3 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_16_3.dat";
       AUTOTB_TVIN_towerET_0_0_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_0_0.dat";
       AUTOTB_TVIN_towerET_0_1_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_0_1.dat";
       AUTOTB_TVIN_towerET_0_2_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_0_2.dat";
       AUTOTB_TVIN_towerET_0_3_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_0_3.dat";
       AUTOTB_TVIN_towerET_1_0_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_1_0.dat";
       AUTOTB_TVIN_towerET_1_1_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_1_1.dat";
       AUTOTB_TVIN_towerET_1_2_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_1_2.dat";
       AUTOTB_TVIN_towerET_1_3_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_1_3.dat";
       AUTOTB_TVIN_towerET_2_0_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_2_0.dat";
       AUTOTB_TVIN_towerET_2_1_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_2_1.dat";
       AUTOTB_TVIN_towerET_2_2_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_2_2.dat";
       AUTOTB_TVIN_towerET_2_3_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_2_3.dat";
       AUTOTB_TVIN_towerET_3_0_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_3_0.dat";
       AUTOTB_TVIN_towerET_3_1_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_3_1.dat";
       AUTOTB_TVIN_towerET_3_2_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_3_2.dat";
       AUTOTB_TVIN_towerET_3_3_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_3_3.dat";
       AUTOTB_TVIN_towerET_4_0_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_4_0.dat";
       AUTOTB_TVIN_towerET_4_1_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_4_1.dat";
       AUTOTB_TVIN_towerET_4_2_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_4_2.dat";
       AUTOTB_TVIN_towerET_4_3_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_4_3.dat";
       AUTOTB_TVIN_towerET_5_0_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_5_0.dat";
       AUTOTB_TVIN_towerET_5_1_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_5_1.dat";
       AUTOTB_TVIN_towerET_5_2_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_5_2.dat";
       AUTOTB_TVIN_towerET_5_3_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_5_3.dat";
       AUTOTB_TVIN_towerET_6_0_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_6_0.dat";
       AUTOTB_TVIN_towerET_6_1_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_6_1.dat";
       AUTOTB_TVIN_towerET_6_2_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_6_2.dat";
       AUTOTB_TVIN_towerET_6_3_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_6_3.dat";
       AUTOTB_TVIN_towerET_7_0_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_7_0.dat";
       AUTOTB_TVIN_towerET_7_1_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_7_1.dat";
       AUTOTB_TVIN_towerET_7_2_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_7_2.dat";
       AUTOTB_TVIN_towerET_7_3_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_7_3.dat";
       AUTOTB_TVIN_towerET_8_0_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_8_0.dat";
       AUTOTB_TVIN_towerET_8_1_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_8_1.dat";
       AUTOTB_TVIN_towerET_8_2_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_8_2.dat";
       AUTOTB_TVIN_towerET_8_3_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_8_3.dat";
       AUTOTB_TVIN_towerET_9_0_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_9_0.dat";
       AUTOTB_TVIN_towerET_9_1_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_9_1.dat";
       AUTOTB_TVIN_towerET_9_2_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_9_2.dat";
       AUTOTB_TVIN_towerET_9_3_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_9_3.dat";
       AUTOTB_TVIN_towerET_10_0_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_10_0.dat";
       AUTOTB_TVIN_towerET_10_1_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_10_1.dat";
       AUTOTB_TVIN_towerET_10_2_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_10_2.dat";
       AUTOTB_TVIN_towerET_10_3_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_10_3.dat";
       AUTOTB_TVIN_towerET_11_0_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_11_0.dat";
       AUTOTB_TVIN_towerET_11_1_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_11_1.dat";
       AUTOTB_TVIN_towerET_11_2_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_11_2.dat";
       AUTOTB_TVIN_towerET_11_3_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_11_3.dat";
       AUTOTB_TVIN_towerET_12_0_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_12_0.dat";
       AUTOTB_TVIN_towerET_12_1_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_12_1.dat";
       AUTOTB_TVIN_towerET_12_2_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_12_2.dat";
       AUTOTB_TVIN_towerET_12_3_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_12_3.dat";
       AUTOTB_TVIN_towerET_13_0_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_13_0.dat";
       AUTOTB_TVIN_towerET_13_1_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_13_1.dat";
       AUTOTB_TVIN_towerET_13_2_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_13_2.dat";
       AUTOTB_TVIN_towerET_13_3_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_13_3.dat";
       AUTOTB_TVIN_towerET_14_0_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_14_0.dat";
       AUTOTB_TVIN_towerET_14_1_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_14_1.dat";
       AUTOTB_TVIN_towerET_14_2_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_14_2.dat";
       AUTOTB_TVIN_towerET_14_3_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_14_3.dat";
       AUTOTB_TVIN_towerET_15_0_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_15_0.dat";
       AUTOTB_TVIN_towerET_15_1_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_15_1.dat";
       AUTOTB_TVIN_towerET_15_2_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_15_2.dat";
       AUTOTB_TVIN_towerET_15_3_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_15_3.dat";
       AUTOTB_TVIN_towerET_16_0_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_16_0.dat";
       AUTOTB_TVIN_towerET_16_1_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_16_1.dat";
       AUTOTB_TVIN_towerET_16_2_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_16_2.dat";
       AUTOTB_TVIN_towerET_16_3_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvin_towerET_16_3.dat";
       AUTOTB_TVOUT_TowerPhi_0 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_0.dat";
       AUTOTB_TVOUT_TowerPhi_1 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_1.dat";
       AUTOTB_TVOUT_TowerPhi_2 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_2.dat";
       AUTOTB_TVOUT_TowerPhi_3 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_3.dat";
       AUTOTB_TVOUT_TowerPhi_4 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_4.dat";
       AUTOTB_TVOUT_TowerPhi_5 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_5.dat";
       AUTOTB_TVOUT_TowerPhi_6 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_6.dat";
       AUTOTB_TVOUT_TowerPhi_7 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_7.dat";
       AUTOTB_TVOUT_TowerPhi_8 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_8.dat";
       AUTOTB_TVOUT_TowerPhi_9 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_9.dat";
       AUTOTB_TVOUT_TowerPhi_10 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_10.dat";
       AUTOTB_TVOUT_TowerPhi_11 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_11.dat";
       AUTOTB_TVOUT_TowerPhi_12 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_12.dat";
       AUTOTB_TVOUT_TowerPhi_13 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_13.dat";
       AUTOTB_TVOUT_TowerPhi_14 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_14.dat";
       AUTOTB_TVOUT_TowerPhi_15 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_15.dat";
       AUTOTB_TVOUT_TowerPhi_16 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_16.dat";
       AUTOTB_TVOUT_TowerPhi_17 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_17.dat";
       AUTOTB_TVOUT_TowerPhi_18 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_18.dat";
       AUTOTB_TVOUT_TowerPhi_19 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_19.dat";
       AUTOTB_TVOUT_TowerPhi_20 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_20.dat";
       AUTOTB_TVOUT_TowerPhi_21 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_21.dat";
       AUTOTB_TVOUT_TowerPhi_22 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_22.dat";
       AUTOTB_TVOUT_TowerPhi_23 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_23.dat";
       AUTOTB_TVOUT_TowerPhi_24 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_24.dat";
       AUTOTB_TVOUT_TowerPhi_25 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_25.dat";
       AUTOTB_TVOUT_TowerPhi_26 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_26.dat";
       AUTOTB_TVOUT_TowerPhi_27 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_27.dat";
       AUTOTB_TVOUT_TowerPhi_28 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_28.dat";
       AUTOTB_TVOUT_TowerPhi_29 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_29.dat";
       AUTOTB_TVOUT_TowerEta_0 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_0.dat";
       AUTOTB_TVOUT_TowerEta_1 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_1.dat";
       AUTOTB_TVOUT_TowerEta_2 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_2.dat";
       AUTOTB_TVOUT_TowerEta_3 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_3.dat";
       AUTOTB_TVOUT_TowerEta_4 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_4.dat";
       AUTOTB_TVOUT_TowerEta_5 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_5.dat";
       AUTOTB_TVOUT_TowerEta_6 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_6.dat";
       AUTOTB_TVOUT_TowerEta_7 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_7.dat";
       AUTOTB_TVOUT_TowerEta_8 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_8.dat";
       AUTOTB_TVOUT_TowerEta_9 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_9.dat";
       AUTOTB_TVOUT_TowerEta_10 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_10.dat";
       AUTOTB_TVOUT_TowerEta_11 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_11.dat";
       AUTOTB_TVOUT_TowerEta_12 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_12.dat";
       AUTOTB_TVOUT_TowerEta_13 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_13.dat";
       AUTOTB_TVOUT_TowerEta_14 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_14.dat";
       AUTOTB_TVOUT_TowerEta_15 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_15.dat";
       AUTOTB_TVOUT_TowerEta_16 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_16.dat";
       AUTOTB_TVOUT_TowerEta_17 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_17.dat";
       AUTOTB_TVOUT_TowerEta_18 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_18.dat";
       AUTOTB_TVOUT_TowerEta_19 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_19.dat";
       AUTOTB_TVOUT_TowerEta_20 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_20.dat";
       AUTOTB_TVOUT_TowerEta_21 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_21.dat";
       AUTOTB_TVOUT_TowerEta_22 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_22.dat";
       AUTOTB_TVOUT_TowerEta_23 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_23.dat";
       AUTOTB_TVOUT_TowerEta_24 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_24.dat";
       AUTOTB_TVOUT_TowerEta_25 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_25.dat";
       AUTOTB_TVOUT_TowerEta_26 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_26.dat";
       AUTOTB_TVOUT_TowerEta_27 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_27.dat";
       AUTOTB_TVOUT_TowerEta_28 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_28.dat";
       AUTOTB_TVOUT_TowerEta_29 : STRING := "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_29.dat";
       AUTOTB_TVOUT_TowerPhi_0_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_0.dat";
       AUTOTB_TVOUT_TowerPhi_1_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_1.dat";
       AUTOTB_TVOUT_TowerPhi_2_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_2.dat";
       AUTOTB_TVOUT_TowerPhi_3_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_3.dat";
       AUTOTB_TVOUT_TowerPhi_4_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_4.dat";
       AUTOTB_TVOUT_TowerPhi_5_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_5.dat";
       AUTOTB_TVOUT_TowerPhi_6_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_6.dat";
       AUTOTB_TVOUT_TowerPhi_7_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_7.dat";
       AUTOTB_TVOUT_TowerPhi_8_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_8.dat";
       AUTOTB_TVOUT_TowerPhi_9_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_9.dat";
       AUTOTB_TVOUT_TowerPhi_10_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_10.dat";
       AUTOTB_TVOUT_TowerPhi_11_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_11.dat";
       AUTOTB_TVOUT_TowerPhi_12_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_12.dat";
       AUTOTB_TVOUT_TowerPhi_13_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_13.dat";
       AUTOTB_TVOUT_TowerPhi_14_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_14.dat";
       AUTOTB_TVOUT_TowerPhi_15_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_15.dat";
       AUTOTB_TVOUT_TowerPhi_16_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_16.dat";
       AUTOTB_TVOUT_TowerPhi_17_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_17.dat";
       AUTOTB_TVOUT_TowerPhi_18_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_18.dat";
       AUTOTB_TVOUT_TowerPhi_19_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_19.dat";
       AUTOTB_TVOUT_TowerPhi_20_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_20.dat";
       AUTOTB_TVOUT_TowerPhi_21_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_21.dat";
       AUTOTB_TVOUT_TowerPhi_22_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_22.dat";
       AUTOTB_TVOUT_TowerPhi_23_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_23.dat";
       AUTOTB_TVOUT_TowerPhi_24_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_24.dat";
       AUTOTB_TVOUT_TowerPhi_25_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_25.dat";
       AUTOTB_TVOUT_TowerPhi_26_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_26.dat";
       AUTOTB_TVOUT_TowerPhi_27_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_27.dat";
       AUTOTB_TVOUT_TowerPhi_28_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_28.dat";
       AUTOTB_TVOUT_TowerPhi_29_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_29.dat";
       AUTOTB_TVOUT_TowerEta_0_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_0.dat";
       AUTOTB_TVOUT_TowerEta_1_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_1.dat";
       AUTOTB_TVOUT_TowerEta_2_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_2.dat";
       AUTOTB_TVOUT_TowerEta_3_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_3.dat";
       AUTOTB_TVOUT_TowerEta_4_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_4.dat";
       AUTOTB_TVOUT_TowerEta_5_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_5.dat";
       AUTOTB_TVOUT_TowerEta_6_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_6.dat";
       AUTOTB_TVOUT_TowerEta_7_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_7.dat";
       AUTOTB_TVOUT_TowerEta_8_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_8.dat";
       AUTOTB_TVOUT_TowerEta_9_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_9.dat";
       AUTOTB_TVOUT_TowerEta_10_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_10.dat";
       AUTOTB_TVOUT_TowerEta_11_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_11.dat";
       AUTOTB_TVOUT_TowerEta_12_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_12.dat";
       AUTOTB_TVOUT_TowerEta_13_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_13.dat";
       AUTOTB_TVOUT_TowerEta_14_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_14.dat";
       AUTOTB_TVOUT_TowerEta_15_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_15.dat";
       AUTOTB_TVOUT_TowerEta_16_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_16.dat";
       AUTOTB_TVOUT_TowerEta_17_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_17.dat";
       AUTOTB_TVOUT_TowerEta_18_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_18.dat";
       AUTOTB_TVOUT_TowerEta_19_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_19.dat";
       AUTOTB_TVOUT_TowerEta_20_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_20.dat";
       AUTOTB_TVOUT_TowerEta_21_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_21.dat";
       AUTOTB_TVOUT_TowerEta_22_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_22.dat";
       AUTOTB_TVOUT_TowerEta_23_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_23.dat";
       AUTOTB_TVOUT_TowerEta_24_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_24.dat";
       AUTOTB_TVOUT_TowerEta_25_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_25.dat";
       AUTOTB_TVOUT_TowerEta_26_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_26.dat";
       AUTOTB_TVOUT_TowerEta_27_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_27.dat";
       AUTOTB_TVOUT_TowerEta_28_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_28.dat";
       AUTOTB_TVOUT_TowerEta_29_out_wrapc : STRING := "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_29.dat";
      AUTOTB_LAT_RESULT_FILE    : STRING  := "TowerPeaks.result.lat.rb";
      AUTOTB_PER_RESULT_TRANS_FILE    : STRING  := "TowerPeaks.performance.result.transaction.xml";
      LENGTH_towerET_0_0     : INTEGER := 1;
      LENGTH_towerET_0_1     : INTEGER := 1;
      LENGTH_towerET_0_2     : INTEGER := 1;
      LENGTH_towerET_0_3     : INTEGER := 1;
      LENGTH_towerET_1_0     : INTEGER := 1;
      LENGTH_towerET_1_1     : INTEGER := 1;
      LENGTH_towerET_1_2     : INTEGER := 1;
      LENGTH_towerET_1_3     : INTEGER := 1;
      LENGTH_towerET_2_0     : INTEGER := 1;
      LENGTH_towerET_2_1     : INTEGER := 1;
      LENGTH_towerET_2_2     : INTEGER := 1;
      LENGTH_towerET_2_3     : INTEGER := 1;
      LENGTH_towerET_3_0     : INTEGER := 1;
      LENGTH_towerET_3_1     : INTEGER := 1;
      LENGTH_towerET_3_2     : INTEGER := 1;
      LENGTH_towerET_3_3     : INTEGER := 1;
      LENGTH_towerET_4_0     : INTEGER := 1;
      LENGTH_towerET_4_1     : INTEGER := 1;
      LENGTH_towerET_4_2     : INTEGER := 1;
      LENGTH_towerET_4_3     : INTEGER := 1;
      LENGTH_towerET_5_0     : INTEGER := 1;
      LENGTH_towerET_5_1     : INTEGER := 1;
      LENGTH_towerET_5_2     : INTEGER := 1;
      LENGTH_towerET_5_3     : INTEGER := 1;
      LENGTH_towerET_6_0     : INTEGER := 1;
      LENGTH_towerET_6_1     : INTEGER := 1;
      LENGTH_towerET_6_2     : INTEGER := 1;
      LENGTH_towerET_6_3     : INTEGER := 1;
      LENGTH_towerET_7_0     : INTEGER := 1;
      LENGTH_towerET_7_1     : INTEGER := 1;
      LENGTH_towerET_7_2     : INTEGER := 1;
      LENGTH_towerET_7_3     : INTEGER := 1;
      LENGTH_towerET_8_0     : INTEGER := 1;
      LENGTH_towerET_8_1     : INTEGER := 1;
      LENGTH_towerET_8_2     : INTEGER := 1;
      LENGTH_towerET_8_3     : INTEGER := 1;
      LENGTH_towerET_9_0     : INTEGER := 1;
      LENGTH_towerET_9_1     : INTEGER := 1;
      LENGTH_towerET_9_2     : INTEGER := 1;
      LENGTH_towerET_9_3     : INTEGER := 1;
      LENGTH_towerET_10_0     : INTEGER := 1;
      LENGTH_towerET_10_1     : INTEGER := 1;
      LENGTH_towerET_10_2     : INTEGER := 1;
      LENGTH_towerET_10_3     : INTEGER := 1;
      LENGTH_towerET_11_0     : INTEGER := 1;
      LENGTH_towerET_11_1     : INTEGER := 1;
      LENGTH_towerET_11_2     : INTEGER := 1;
      LENGTH_towerET_11_3     : INTEGER := 1;
      LENGTH_towerET_12_0     : INTEGER := 1;
      LENGTH_towerET_12_1     : INTEGER := 1;
      LENGTH_towerET_12_2     : INTEGER := 1;
      LENGTH_towerET_12_3     : INTEGER := 1;
      LENGTH_towerET_13_0     : INTEGER := 1;
      LENGTH_towerET_13_1     : INTEGER := 1;
      LENGTH_towerET_13_2     : INTEGER := 1;
      LENGTH_towerET_13_3     : INTEGER := 1;
      LENGTH_towerET_14_0     : INTEGER := 1;
      LENGTH_towerET_14_1     : INTEGER := 1;
      LENGTH_towerET_14_2     : INTEGER := 1;
      LENGTH_towerET_14_3     : INTEGER := 1;
      LENGTH_towerET_15_0     : INTEGER := 1;
      LENGTH_towerET_15_1     : INTEGER := 1;
      LENGTH_towerET_15_2     : INTEGER := 1;
      LENGTH_towerET_15_3     : INTEGER := 1;
      LENGTH_towerET_16_0     : INTEGER := 1;
      LENGTH_towerET_16_1     : INTEGER := 1;
      LENGTH_towerET_16_2     : INTEGER := 1;
      LENGTH_towerET_16_3     : INTEGER := 1;
      LENGTH_TowerPhi_0     : INTEGER := 1;
      LENGTH_TowerPhi_1     : INTEGER := 1;
      LENGTH_TowerPhi_2     : INTEGER := 1;
      LENGTH_TowerPhi_3     : INTEGER := 1;
      LENGTH_TowerPhi_4     : INTEGER := 1;
      LENGTH_TowerPhi_5     : INTEGER := 1;
      LENGTH_TowerPhi_6     : INTEGER := 1;
      LENGTH_TowerPhi_7     : INTEGER := 1;
      LENGTH_TowerPhi_8     : INTEGER := 1;
      LENGTH_TowerPhi_9     : INTEGER := 1;
      LENGTH_TowerPhi_10     : INTEGER := 1;
      LENGTH_TowerPhi_11     : INTEGER := 1;
      LENGTH_TowerPhi_12     : INTEGER := 1;
      LENGTH_TowerPhi_13     : INTEGER := 1;
      LENGTH_TowerPhi_14     : INTEGER := 1;
      LENGTH_TowerPhi_15     : INTEGER := 1;
      LENGTH_TowerPhi_16     : INTEGER := 1;
      LENGTH_TowerPhi_17     : INTEGER := 1;
      LENGTH_TowerPhi_18     : INTEGER := 1;
      LENGTH_TowerPhi_19     : INTEGER := 1;
      LENGTH_TowerPhi_20     : INTEGER := 1;
      LENGTH_TowerPhi_21     : INTEGER := 1;
      LENGTH_TowerPhi_22     : INTEGER := 1;
      LENGTH_TowerPhi_23     : INTEGER := 1;
      LENGTH_TowerPhi_24     : INTEGER := 1;
      LENGTH_TowerPhi_25     : INTEGER := 1;
      LENGTH_TowerPhi_26     : INTEGER := 1;
      LENGTH_TowerPhi_27     : INTEGER := 1;
      LENGTH_TowerPhi_28     : INTEGER := 1;
      LENGTH_TowerPhi_29     : INTEGER := 1;
      LENGTH_TowerEta_0     : INTEGER := 1;
      LENGTH_TowerEta_1     : INTEGER := 1;
      LENGTH_TowerEta_2     : INTEGER := 1;
      LENGTH_TowerEta_3     : INTEGER := 1;
      LENGTH_TowerEta_4     : INTEGER := 1;
      LENGTH_TowerEta_5     : INTEGER := 1;
      LENGTH_TowerEta_6     : INTEGER := 1;
      LENGTH_TowerEta_7     : INTEGER := 1;
      LENGTH_TowerEta_8     : INTEGER := 1;
      LENGTH_TowerEta_9     : INTEGER := 1;
      LENGTH_TowerEta_10     : INTEGER := 1;
      LENGTH_TowerEta_11     : INTEGER := 1;
      LENGTH_TowerEta_12     : INTEGER := 1;
      LENGTH_TowerEta_13     : INTEGER := 1;
      LENGTH_TowerEta_14     : INTEGER := 1;
      LENGTH_TowerEta_15     : INTEGER := 1;
      LENGTH_TowerEta_16     : INTEGER := 1;
      LENGTH_TowerEta_17     : INTEGER := 1;
      LENGTH_TowerEta_18     : INTEGER := 1;
      LENGTH_TowerEta_19     : INTEGER := 1;
      LENGTH_TowerEta_20     : INTEGER := 1;
      LENGTH_TowerEta_21     : INTEGER := 1;
      LENGTH_TowerEta_22     : INTEGER := 1;
      LENGTH_TowerEta_23     : INTEGER := 1;
      LENGTH_TowerEta_24     : INTEGER := 1;
      LENGTH_TowerEta_25     : INTEGER := 1;
      LENGTH_TowerEta_26     : INTEGER := 1;
      LENGTH_TowerEta_27     : INTEGER := 1;
      LENGTH_TowerEta_28     : INTEGER := 1;
      LENGTH_TowerEta_29     : INTEGER := 1;
	    AUTOTB_TRANSACTION_NUM    : INTEGER := 1
);

end apatb_TowerPeaks_top;

architecture behav of apatb_TowerPeaks_top is 
  signal AESL_clock	:   STD_LOGIC := '0';
  signal rst  :   STD_LOGIC;
  signal start    :   STD_LOGIC := '0';
  signal ce       :   STD_LOGIC;
  signal continue :   STD_LOGIC := '0';
  signal AESL_reset :   STD_LOGIC := '0';
  signal AESL_start :   STD_LOGIC := '0';
  signal AESL_ce :   STD_LOGIC := '0';
  signal AESL_continue :   STD_LOGIC := '0';
  signal AESL_ready :   STD_LOGIC := '0';
  signal AESL_idle :   STD_LOGIC := '0';
  signal AESL_done :   STD_LOGIC := '0';
  signal AESL_done_delay :   STD_LOGIC := '0';
  signal AESL_done_delay2 :   STD_LOGIC := '0';
  signal AESL_ready_delay :   STD_LOGIC := '0';
  signal ready :   STD_LOGIC := '0';
  signal ready_wire :   STD_LOGIC := '0';

  signal ap_clk :  STD_LOGIC;
  signal ap_rst :  STD_LOGIC;
  signal ap_start :  STD_LOGIC;
  signal ap_done :  STD_LOGIC;
  signal ap_idle :  STD_LOGIC;
  signal ap_ready :  STD_LOGIC;
  signal towerET_0_0 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_0_1 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_0_2 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_0_3 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_1_0 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_1_1 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_1_2 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_1_3 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_2_0 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_2_1 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_2_2 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_2_3 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_3_0 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_3_1 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_3_2 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_3_3 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_4_0 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_4_1 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_4_2 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_4_3 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_5_0 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_5_1 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_5_2 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_5_3 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_6_0 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_6_1 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_6_2 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_6_3 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_7_0 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_7_1 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_7_2 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_7_3 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_8_0 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_8_1 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_8_2 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_8_3 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_9_0 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_9_1 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_9_2 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_9_3 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_10_0 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_10_1 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_10_2 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_10_3 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_11_0 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_11_1 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_11_2 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_11_3 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_12_0 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_12_1 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_12_2 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_12_3 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_13_0 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_13_1 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_13_2 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_13_3 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_14_0 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_14_1 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_14_2 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_14_3 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_15_0 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_15_1 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_15_2 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_15_3 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_16_0 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_16_1 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_16_2 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal towerET_16_3 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerPhi_0 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerPhi_0_ap_vld :  STD_LOGIC;
  signal TowerPhi_1 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerPhi_1_ap_vld :  STD_LOGIC;
  signal TowerPhi_2 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerPhi_2_ap_vld :  STD_LOGIC;
  signal TowerPhi_3 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerPhi_3_ap_vld :  STD_LOGIC;
  signal TowerPhi_4 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerPhi_4_ap_vld :  STD_LOGIC;
  signal TowerPhi_5 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerPhi_5_ap_vld :  STD_LOGIC;
  signal TowerPhi_6 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerPhi_6_ap_vld :  STD_LOGIC;
  signal TowerPhi_7 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerPhi_7_ap_vld :  STD_LOGIC;
  signal TowerPhi_8 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerPhi_8_ap_vld :  STD_LOGIC;
  signal TowerPhi_9 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerPhi_9_ap_vld :  STD_LOGIC;
  signal TowerPhi_10 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerPhi_10_ap_vld :  STD_LOGIC;
  signal TowerPhi_11 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerPhi_11_ap_vld :  STD_LOGIC;
  signal TowerPhi_12 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerPhi_12_ap_vld :  STD_LOGIC;
  signal TowerPhi_13 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerPhi_13_ap_vld :  STD_LOGIC;
  signal TowerPhi_14 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerPhi_14_ap_vld :  STD_LOGIC;
  signal TowerPhi_15 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerPhi_15_ap_vld :  STD_LOGIC;
  signal TowerPhi_16 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerPhi_16_ap_vld :  STD_LOGIC;
  signal TowerPhi_17 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerPhi_17_ap_vld :  STD_LOGIC;
  signal TowerPhi_18 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerPhi_18_ap_vld :  STD_LOGIC;
  signal TowerPhi_19 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerPhi_19_ap_vld :  STD_LOGIC;
  signal TowerPhi_20 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerPhi_20_ap_vld :  STD_LOGIC;
  signal TowerPhi_21 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerPhi_21_ap_vld :  STD_LOGIC;
  signal TowerPhi_22 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerPhi_22_ap_vld :  STD_LOGIC;
  signal TowerPhi_23 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerPhi_23_ap_vld :  STD_LOGIC;
  signal TowerPhi_24 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerPhi_24_ap_vld :  STD_LOGIC;
  signal TowerPhi_25 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerPhi_25_ap_vld :  STD_LOGIC;
  signal TowerPhi_26 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerPhi_26_ap_vld :  STD_LOGIC;
  signal TowerPhi_27 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerPhi_27_ap_vld :  STD_LOGIC;
  signal TowerPhi_28 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerPhi_28_ap_vld :  STD_LOGIC;
  signal TowerPhi_29 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerPhi_29_ap_vld :  STD_LOGIC;
  signal TowerEta_0 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerEta_0_ap_vld :  STD_LOGIC;
  signal TowerEta_1 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerEta_1_ap_vld :  STD_LOGIC;
  signal TowerEta_2 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerEta_2_ap_vld :  STD_LOGIC;
  signal TowerEta_3 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerEta_3_ap_vld :  STD_LOGIC;
  signal TowerEta_4 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerEta_4_ap_vld :  STD_LOGIC;
  signal TowerEta_5 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerEta_5_ap_vld :  STD_LOGIC;
  signal TowerEta_6 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerEta_6_ap_vld :  STD_LOGIC;
  signal TowerEta_7 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerEta_7_ap_vld :  STD_LOGIC;
  signal TowerEta_8 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerEta_8_ap_vld :  STD_LOGIC;
  signal TowerEta_9 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerEta_9_ap_vld :  STD_LOGIC;
  signal TowerEta_10 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerEta_10_ap_vld :  STD_LOGIC;
  signal TowerEta_11 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerEta_11_ap_vld :  STD_LOGIC;
  signal TowerEta_12 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerEta_12_ap_vld :  STD_LOGIC;
  signal TowerEta_13 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerEta_13_ap_vld :  STD_LOGIC;
  signal TowerEta_14 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerEta_14_ap_vld :  STD_LOGIC;
  signal TowerEta_15 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerEta_15_ap_vld :  STD_LOGIC;
  signal TowerEta_16 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerEta_16_ap_vld :  STD_LOGIC;
  signal TowerEta_17 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerEta_17_ap_vld :  STD_LOGIC;
  signal TowerEta_18 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerEta_18_ap_vld :  STD_LOGIC;
  signal TowerEta_19 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerEta_19_ap_vld :  STD_LOGIC;
  signal TowerEta_20 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerEta_20_ap_vld :  STD_LOGIC;
  signal TowerEta_21 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerEta_21_ap_vld :  STD_LOGIC;
  signal TowerEta_22 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerEta_22_ap_vld :  STD_LOGIC;
  signal TowerEta_23 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerEta_23_ap_vld :  STD_LOGIC;
  signal TowerEta_24 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerEta_24_ap_vld :  STD_LOGIC;
  signal TowerEta_25 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerEta_25_ap_vld :  STD_LOGIC;
  signal TowerEta_26 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerEta_26_ap_vld :  STD_LOGIC;
  signal TowerEta_27 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerEta_27_ap_vld :  STD_LOGIC;
  signal TowerEta_28 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerEta_28_ap_vld :  STD_LOGIC;
  signal TowerEta_29 :  STD_LOGIC_VECTOR (15 DOWNTO 0);
  signal TowerEta_29_ap_vld :  STD_LOGIC;

  signal ready_cnt : STD_LOGIC_VECTOR(31 DOWNTO 0);
  signal done_cnt	: STD_LOGIC_VECTOR(31 DOWNTO 0);
  signal ready_initial  :	STD_LOGIC;
  signal ready_initial_n	:   STD_LOGIC;
  signal ready_last_n   :	STD_LOGIC;
  signal ready_delay_last_n	:   STD_LOGIC;
  signal done_delay_last_n	:   STD_LOGIC;
  signal interface_done :	STD_LOGIC := '0';
  -- Subtype for random state number, to prevent confusing it with true integers
  -- Top of range should be (2**31)-1 but this literal calculation causes overflow on 32-bit machines
  subtype T_RANDINT is integer range 1 to integer'high;

  type latency_record is array(0 to AUTOTB_TRANSACTION_NUM + 1) of INTEGER;
  shared variable AESL_mLatCnterIn : latency_record;
  shared variable AESL_mLatCnterOut : latency_record;
  shared variable AESL_mLatCnterIn_addr : INTEGER;
  shared variable AESL_mLatCnterOut_addr : INTEGER;
  shared variable AESL_clk_counter : INTEGER;
  signal reported_stuck : STD_LOGIC   := '0';
  shared variable reported_stuck_cnt : INTEGER := 0;
component TowerPeaks is
port (
    ap_clk :  IN STD_LOGIC;
    ap_rst :  IN STD_LOGIC;
    ap_start :  IN STD_LOGIC;
    ap_done :  OUT STD_LOGIC;
    ap_idle :  OUT STD_LOGIC;
    ap_ready :  OUT STD_LOGIC;
    towerET_0_0 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_0_1 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_0_2 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_0_3 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_1_0 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_1_1 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_1_2 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_1_3 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_2_0 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_2_1 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_2_2 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_2_3 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_3_0 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_3_1 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_3_2 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_3_3 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_4_0 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_4_1 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_4_2 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_4_3 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_5_0 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_5_1 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_5_2 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_5_3 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_6_0 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_6_1 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_6_2 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_6_3 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_7_0 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_7_1 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_7_2 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_7_3 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_8_0 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_8_1 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_8_2 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_8_3 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_9_0 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_9_1 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_9_2 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_9_3 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_10_0 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_10_1 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_10_2 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_10_3 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_11_0 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_11_1 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_11_2 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_11_3 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_12_0 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_12_1 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_12_2 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_12_3 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_13_0 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_13_1 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_13_2 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_13_3 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_14_0 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_14_1 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_14_2 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_14_3 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_15_0 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_15_1 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_15_2 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_15_3 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_16_0 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_16_1 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_16_2 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    towerET_16_3 :  IN STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerPhi_0 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerPhi_0_ap_vld :  OUT STD_LOGIC;
    TowerPhi_1 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerPhi_1_ap_vld :  OUT STD_LOGIC;
    TowerPhi_2 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerPhi_2_ap_vld :  OUT STD_LOGIC;
    TowerPhi_3 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerPhi_3_ap_vld :  OUT STD_LOGIC;
    TowerPhi_4 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerPhi_4_ap_vld :  OUT STD_LOGIC;
    TowerPhi_5 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerPhi_5_ap_vld :  OUT STD_LOGIC;
    TowerPhi_6 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerPhi_6_ap_vld :  OUT STD_LOGIC;
    TowerPhi_7 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerPhi_7_ap_vld :  OUT STD_LOGIC;
    TowerPhi_8 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerPhi_8_ap_vld :  OUT STD_LOGIC;
    TowerPhi_9 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerPhi_9_ap_vld :  OUT STD_LOGIC;
    TowerPhi_10 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerPhi_10_ap_vld :  OUT STD_LOGIC;
    TowerPhi_11 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerPhi_11_ap_vld :  OUT STD_LOGIC;
    TowerPhi_12 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerPhi_12_ap_vld :  OUT STD_LOGIC;
    TowerPhi_13 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerPhi_13_ap_vld :  OUT STD_LOGIC;
    TowerPhi_14 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerPhi_14_ap_vld :  OUT STD_LOGIC;
    TowerPhi_15 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerPhi_15_ap_vld :  OUT STD_LOGIC;
    TowerPhi_16 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerPhi_16_ap_vld :  OUT STD_LOGIC;
    TowerPhi_17 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerPhi_17_ap_vld :  OUT STD_LOGIC;
    TowerPhi_18 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerPhi_18_ap_vld :  OUT STD_LOGIC;
    TowerPhi_19 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerPhi_19_ap_vld :  OUT STD_LOGIC;
    TowerPhi_20 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerPhi_20_ap_vld :  OUT STD_LOGIC;
    TowerPhi_21 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerPhi_21_ap_vld :  OUT STD_LOGIC;
    TowerPhi_22 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerPhi_22_ap_vld :  OUT STD_LOGIC;
    TowerPhi_23 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerPhi_23_ap_vld :  OUT STD_LOGIC;
    TowerPhi_24 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerPhi_24_ap_vld :  OUT STD_LOGIC;
    TowerPhi_25 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerPhi_25_ap_vld :  OUT STD_LOGIC;
    TowerPhi_26 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerPhi_26_ap_vld :  OUT STD_LOGIC;
    TowerPhi_27 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerPhi_27_ap_vld :  OUT STD_LOGIC;
    TowerPhi_28 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerPhi_28_ap_vld :  OUT STD_LOGIC;
    TowerPhi_29 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerPhi_29_ap_vld :  OUT STD_LOGIC;
    TowerEta_0 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerEta_0_ap_vld :  OUT STD_LOGIC;
    TowerEta_1 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerEta_1_ap_vld :  OUT STD_LOGIC;
    TowerEta_2 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerEta_2_ap_vld :  OUT STD_LOGIC;
    TowerEta_3 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerEta_3_ap_vld :  OUT STD_LOGIC;
    TowerEta_4 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerEta_4_ap_vld :  OUT STD_LOGIC;
    TowerEta_5 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerEta_5_ap_vld :  OUT STD_LOGIC;
    TowerEta_6 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerEta_6_ap_vld :  OUT STD_LOGIC;
    TowerEta_7 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerEta_7_ap_vld :  OUT STD_LOGIC;
    TowerEta_8 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerEta_8_ap_vld :  OUT STD_LOGIC;
    TowerEta_9 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerEta_9_ap_vld :  OUT STD_LOGIC;
    TowerEta_10 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerEta_10_ap_vld :  OUT STD_LOGIC;
    TowerEta_11 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerEta_11_ap_vld :  OUT STD_LOGIC;
    TowerEta_12 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerEta_12_ap_vld :  OUT STD_LOGIC;
    TowerEta_13 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerEta_13_ap_vld :  OUT STD_LOGIC;
    TowerEta_14 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerEta_14_ap_vld :  OUT STD_LOGIC;
    TowerEta_15 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerEta_15_ap_vld :  OUT STD_LOGIC;
    TowerEta_16 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerEta_16_ap_vld :  OUT STD_LOGIC;
    TowerEta_17 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerEta_17_ap_vld :  OUT STD_LOGIC;
    TowerEta_18 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerEta_18_ap_vld :  OUT STD_LOGIC;
    TowerEta_19 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerEta_19_ap_vld :  OUT STD_LOGIC;
    TowerEta_20 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerEta_20_ap_vld :  OUT STD_LOGIC;
    TowerEta_21 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerEta_21_ap_vld :  OUT STD_LOGIC;
    TowerEta_22 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerEta_22_ap_vld :  OUT STD_LOGIC;
    TowerEta_23 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerEta_23_ap_vld :  OUT STD_LOGIC;
    TowerEta_24 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerEta_24_ap_vld :  OUT STD_LOGIC;
    TowerEta_25 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerEta_25_ap_vld :  OUT STD_LOGIC;
    TowerEta_26 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerEta_26_ap_vld :  OUT STD_LOGIC;
    TowerEta_27 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerEta_27_ap_vld :  OUT STD_LOGIC;
    TowerEta_28 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerEta_28_ap_vld :  OUT STD_LOGIC;
    TowerEta_29 :  OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
    TowerEta_29_ap_vld :  OUT STD_LOGIC);
end component;

-- The signal of port towerET_0_0
shared variable AESL_REG_towerET_0_0 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_0_1
shared variable AESL_REG_towerET_0_1 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_0_2
shared variable AESL_REG_towerET_0_2 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_0_3
shared variable AESL_REG_towerET_0_3 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_1_0
shared variable AESL_REG_towerET_1_0 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_1_1
shared variable AESL_REG_towerET_1_1 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_1_2
shared variable AESL_REG_towerET_1_2 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_1_3
shared variable AESL_REG_towerET_1_3 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_2_0
shared variable AESL_REG_towerET_2_0 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_2_1
shared variable AESL_REG_towerET_2_1 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_2_2
shared variable AESL_REG_towerET_2_2 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_2_3
shared variable AESL_REG_towerET_2_3 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_3_0
shared variable AESL_REG_towerET_3_0 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_3_1
shared variable AESL_REG_towerET_3_1 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_3_2
shared variable AESL_REG_towerET_3_2 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_3_3
shared variable AESL_REG_towerET_3_3 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_4_0
shared variable AESL_REG_towerET_4_0 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_4_1
shared variable AESL_REG_towerET_4_1 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_4_2
shared variable AESL_REG_towerET_4_2 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_4_3
shared variable AESL_REG_towerET_4_3 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_5_0
shared variable AESL_REG_towerET_5_0 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_5_1
shared variable AESL_REG_towerET_5_1 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_5_2
shared variable AESL_REG_towerET_5_2 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_5_3
shared variable AESL_REG_towerET_5_3 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_6_0
shared variable AESL_REG_towerET_6_0 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_6_1
shared variable AESL_REG_towerET_6_1 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_6_2
shared variable AESL_REG_towerET_6_2 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_6_3
shared variable AESL_REG_towerET_6_3 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_7_0
shared variable AESL_REG_towerET_7_0 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_7_1
shared variable AESL_REG_towerET_7_1 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_7_2
shared variable AESL_REG_towerET_7_2 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_7_3
shared variable AESL_REG_towerET_7_3 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_8_0
shared variable AESL_REG_towerET_8_0 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_8_1
shared variable AESL_REG_towerET_8_1 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_8_2
shared variable AESL_REG_towerET_8_2 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_8_3
shared variable AESL_REG_towerET_8_3 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_9_0
shared variable AESL_REG_towerET_9_0 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_9_1
shared variable AESL_REG_towerET_9_1 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_9_2
shared variable AESL_REG_towerET_9_2 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_9_3
shared variable AESL_REG_towerET_9_3 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_10_0
shared variable AESL_REG_towerET_10_0 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_10_1
shared variable AESL_REG_towerET_10_1 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_10_2
shared variable AESL_REG_towerET_10_2 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_10_3
shared variable AESL_REG_towerET_10_3 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_11_0
shared variable AESL_REG_towerET_11_0 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_11_1
shared variable AESL_REG_towerET_11_1 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_11_2
shared variable AESL_REG_towerET_11_2 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_11_3
shared variable AESL_REG_towerET_11_3 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_12_0
shared variable AESL_REG_towerET_12_0 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_12_1
shared variable AESL_REG_towerET_12_1 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_12_2
shared variable AESL_REG_towerET_12_2 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_12_3
shared variable AESL_REG_towerET_12_3 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_13_0
shared variable AESL_REG_towerET_13_0 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_13_1
shared variable AESL_REG_towerET_13_1 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_13_2
shared variable AESL_REG_towerET_13_2 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_13_3
shared variable AESL_REG_towerET_13_3 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_14_0
shared variable AESL_REG_towerET_14_0 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_14_1
shared variable AESL_REG_towerET_14_1 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_14_2
shared variable AESL_REG_towerET_14_2 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_14_3
shared variable AESL_REG_towerET_14_3 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_15_0
shared variable AESL_REG_towerET_15_0 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_15_1
shared variable AESL_REG_towerET_15_1 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_15_2
shared variable AESL_REG_towerET_15_2 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_15_3
shared variable AESL_REG_towerET_15_3 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_16_0
shared variable AESL_REG_towerET_16_0 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_16_1
shared variable AESL_REG_towerET_16_1 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_16_2
shared variable AESL_REG_towerET_16_2 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
-- The signal of port towerET_16_3
shared variable AESL_REG_towerET_16_3 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerPhi_0_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerPhi_0
shared variable AESL_REG_TowerPhi_0 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerPhi_1_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerPhi_1
shared variable AESL_REG_TowerPhi_1 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerPhi_2_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerPhi_2
shared variable AESL_REG_TowerPhi_2 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerPhi_3_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerPhi_3
shared variable AESL_REG_TowerPhi_3 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerPhi_4_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerPhi_4
shared variable AESL_REG_TowerPhi_4 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerPhi_5_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerPhi_5
shared variable AESL_REG_TowerPhi_5 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerPhi_6_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerPhi_6
shared variable AESL_REG_TowerPhi_6 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerPhi_7_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerPhi_7
shared variable AESL_REG_TowerPhi_7 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerPhi_8_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerPhi_8
shared variable AESL_REG_TowerPhi_8 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerPhi_9_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerPhi_9
shared variable AESL_REG_TowerPhi_9 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerPhi_10_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerPhi_10
shared variable AESL_REG_TowerPhi_10 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerPhi_11_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerPhi_11
shared variable AESL_REG_TowerPhi_11 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerPhi_12_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerPhi_12
shared variable AESL_REG_TowerPhi_12 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerPhi_13_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerPhi_13
shared variable AESL_REG_TowerPhi_13 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerPhi_14_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerPhi_14
shared variable AESL_REG_TowerPhi_14 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerPhi_15_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerPhi_15
shared variable AESL_REG_TowerPhi_15 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerPhi_16_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerPhi_16
shared variable AESL_REG_TowerPhi_16 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerPhi_17_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerPhi_17
shared variable AESL_REG_TowerPhi_17 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerPhi_18_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerPhi_18
shared variable AESL_REG_TowerPhi_18 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerPhi_19_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerPhi_19
shared variable AESL_REG_TowerPhi_19 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerPhi_20_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerPhi_20
shared variable AESL_REG_TowerPhi_20 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerPhi_21_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerPhi_21
shared variable AESL_REG_TowerPhi_21 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerPhi_22_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerPhi_22
shared variable AESL_REG_TowerPhi_22 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerPhi_23_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerPhi_23
shared variable AESL_REG_TowerPhi_23 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerPhi_24_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerPhi_24
shared variable AESL_REG_TowerPhi_24 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerPhi_25_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerPhi_25
shared variable AESL_REG_TowerPhi_25 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerPhi_26_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerPhi_26
shared variable AESL_REG_TowerPhi_26 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerPhi_27_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerPhi_27
shared variable AESL_REG_TowerPhi_27 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerPhi_28_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerPhi_28
shared variable AESL_REG_TowerPhi_28 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerPhi_29_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerPhi_29
shared variable AESL_REG_TowerPhi_29 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerEta_0_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerEta_0
shared variable AESL_REG_TowerEta_0 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerEta_1_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerEta_1
shared variable AESL_REG_TowerEta_1 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerEta_2_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerEta_2
shared variable AESL_REG_TowerEta_2 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerEta_3_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerEta_3
shared variable AESL_REG_TowerEta_3 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerEta_4_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerEta_4
shared variable AESL_REG_TowerEta_4 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerEta_5_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerEta_5
shared variable AESL_REG_TowerEta_5 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerEta_6_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerEta_6
shared variable AESL_REG_TowerEta_6 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerEta_7_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerEta_7
shared variable AESL_REG_TowerEta_7 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerEta_8_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerEta_8
shared variable AESL_REG_TowerEta_8 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerEta_9_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerEta_9
shared variable AESL_REG_TowerEta_9 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerEta_10_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerEta_10
shared variable AESL_REG_TowerEta_10 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerEta_11_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerEta_11
shared variable AESL_REG_TowerEta_11 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerEta_12_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerEta_12
shared variable AESL_REG_TowerEta_12 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerEta_13_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerEta_13
shared variable AESL_REG_TowerEta_13 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerEta_14_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerEta_14
shared variable AESL_REG_TowerEta_14 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerEta_15_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerEta_15
shared variable AESL_REG_TowerEta_15 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerEta_16_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerEta_16
shared variable AESL_REG_TowerEta_16 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerEta_17_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerEta_17
shared variable AESL_REG_TowerEta_17 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerEta_18_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerEta_18
shared variable AESL_REG_TowerEta_18 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerEta_19_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerEta_19
shared variable AESL_REG_TowerEta_19 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerEta_20_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerEta_20
shared variable AESL_REG_TowerEta_20 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerEta_21_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerEta_21
shared variable AESL_REG_TowerEta_21 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerEta_22_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerEta_22
shared variable AESL_REG_TowerEta_22 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerEta_23_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerEta_23
shared variable AESL_REG_TowerEta_23 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerEta_24_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerEta_24
shared variable AESL_REG_TowerEta_24 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerEta_25_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerEta_25
shared variable AESL_REG_TowerEta_25 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerEta_26_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerEta_26
shared variable AESL_REG_TowerEta_26 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerEta_27_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerEta_27
shared variable AESL_REG_TowerEta_27 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerEta_28_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerEta_28
shared variable AESL_REG_TowerEta_28 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
shared variable AESL_REG_TowerEta_29_ap_vld : STD_LOGIC := '0';
-- The signal of port TowerEta_29
shared variable AESL_REG_TowerEta_29 : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
      procedure esl_read_token (file textfile: TEXT; textline: inout LINE; token: out STRING; token_len: out INTEGER) is
          variable whitespace : CHARACTER;
          variable i : INTEGER;
          variable ok: BOOLEAN;
          variable buff: STRING(1 to token'length);
      begin
          ok := false;
          i := 1;
          loop_main: while not endfile(textfile) loop
              if textline = null or textline'length = 0 then
                  readline(textfile, textline);
              end if;
              loop_remove_whitespace: while textline'length > 0 loop
                  if textline(textline'left) = ' ' or
                      textline(textline'left) = HT or
                      textline(textline'left) = CR or
                      textline(textline'left) = LF then
                      read(textline, whitespace);
                  else
                      exit loop_remove_whitespace;
                  end if;
              end loop;
              loop_aesl_read_token: while textline'length > 0 and i <= buff'length loop
                  if textline(textline'left) = ' ' or
                     textline(textline'left) = HT or
                     textline(textline'left) = CR or
                     textline(textline'left) = LF then
                      exit loop_aesl_read_token;
                  else
                      read(textline, buff(i));
                      i := i + 1;
                  end if;
                  ok := true;
              end loop;
              if ok = true then
                  exit loop_main;
              end if;
          end loop;
          buff(i) := ' ';
          token := buff;
          token_len:= i-1;
      end procedure esl_read_token;

      procedure esl_read_token (file textfile: TEXT;
                                textline: inout LINE;
                                token: out STRING) is
          variable i : INTEGER;
      begin
          esl_read_token (textfile, textline, token, i);
      end procedure esl_read_token;

      function esl_str2lv_hex (RHS : STRING; data_width : INTEGER) return STD_LOGIC_VECTOR is
          variable	ret	:   STD_LOGIC_VECTOR(data_width - 1 downto 0);
          variable	idx	:   integer := 3;
      begin
          ret := (others => '0');
          if(RHS(1) /= '0' and (RHS(2) /= 'x' or RHS(2) /= 'X')) then
     	        report "Error! The format of hex number is not initialed by 0x";
          end if;
          while true loop
              if (data_width > 4) then
                  case RHS(idx)  is
                      when '0'    =>  ret := ret(data_width - 5 downto 0) & "0000";
     	                when '1'    =>  ret := ret(data_width - 5 downto 0) & "0001";
                      when '2'    =>  ret := ret(data_width - 5 downto 0) & "0010";
                      when '3'    =>  ret := ret(data_width - 5 downto 0) & "0011";
                      when '4'    =>  ret := ret(data_width - 5 downto 0) & "0100";
                      when '5'    =>  ret := ret(data_width - 5 downto 0) & "0101";
                      when '6'    =>  ret := ret(data_width - 5 downto 0) & "0110";
                      when '7'    =>  ret := ret(data_width - 5 downto 0) & "0111";
                      when '8'    =>  ret := ret(data_width - 5 downto 0) & "1000";
                      when '9'    =>  ret := ret(data_width - 5 downto 0) & "1001";
                      when 'a' | 'A'  =>  ret := ret(data_width - 5 downto 0) & "1010";
                      when 'b' | 'B'  =>  ret := ret(data_width - 5 downto 0) & "1011";
                      when 'c' | 'C'  =>  ret := ret(data_width - 5 downto 0) & "1100";
                      when 'd' | 'D'  =>  ret := ret(data_width - 5 downto 0) & "1101";
                      when 'e' | 'E'  =>  ret := ret(data_width - 5 downto 0) & "1110";
                      when 'f' | 'F'  =>  ret := ret(data_width - 5 downto 0) & "1111";
                      when 'x' | 'X'  =>  ret := ret(data_width - 5 downto 0) & "XXXX";
                      when ' '    =>  return ret;
                      when others    =>  report "Wrong hex char " & RHS(idx);	return ret;
                  end case;
              elsif (data_width = 4) then
                  case RHS(idx)  is
                      when '0'    =>  ret := "0000";
     	                when '1'    =>  ret := "0001";
                      when '2'    =>  ret := "0010";
                      when '3'    =>  ret := "0011";
                      when '4'    =>  ret := "0100";
                      when '5'    =>  ret := "0101";
                      when '6'    =>  ret := "0110";
                      when '7'    =>  ret := "0111";
                      when '8'    =>  ret := "1000";
                      when '9'    =>  ret := "1001";
                      when 'a' | 'A'  =>  ret := "1010";
                      when 'b' | 'B'  =>  ret := "1011";
                      when 'c' | 'C'  =>  ret := "1100";
                      when 'd' | 'D'  =>  ret := "1101";
                      when 'e' | 'E'  =>  ret := "1110";
                      when 'f' | 'F'  =>  ret := "1111";
                      when 'x' | 'X'  =>  ret := "XXXX";
                      when ' '    =>  return ret;
                      when others    =>  report "Wrong hex char " & RHS(idx);	return ret;
                  end case;
              elsif (data_width = 3) then
                  case RHS(idx)  is
                      when '0'    =>  ret := "000";
     	                when '1'    =>  ret := "001";
                      when '2'    =>  ret := "010";
                      when '3'    =>  ret := "011";
                      when '4'    =>  ret := "100";
                      when '5'    =>  ret := "101";
                      when '6'    =>  ret := "110";
                      when '7'    =>  ret := "111";
                      when 'x' | 'X'  =>  ret := "XXX";
                      when ' '    =>  return ret;
                      when others    =>  report "Wrong hex char " & RHS(idx);	return ret;
                  end case;
              elsif (data_width = 2) then
                  case RHS(idx)  is
                      when '0'    =>  ret := "00";
     	                when '1'    =>  ret := "01";
                      when '2'    =>  ret := "10";
                      when '3'    =>  ret := "11";
                      when 'x' | 'X'  =>  ret := "XX";
                      when ' '    =>  return ret;
                      when others    =>  report "Wrong hex char " & RHS(idx);	return ret;
                  end case;
              elsif (data_width = 1) then
                  case RHS(idx)  is
                      when '0'    =>  ret := "0";
     	                when '1'    =>  ret := "1";
                      when 'x' | 'X'  =>  ret := "X";
                      when ' '    =>  return ret;
                      when others    =>  report "Wrong hex char " & RHS(idx);	return ret;
                  end case;
              else
                  report string'("Wrong data_width.");
                  return ret;
              end if;
              idx := idx + 1;
          end loop;
          return ret;
      end function;

    function esl_str_dec2int (RHS : STRING) return INTEGER is
        variable	ret	:   integer;
        variable	idx	:   integer := 1;
    begin
        ret := 0;
        while true loop
            case RHS(idx)  is
                when '0'    =>  ret := ret * 10 + 0;
                when '1'    =>  ret := ret * 10 + 1;
                when '2'    =>  ret := ret * 10 + 2;
                when '3'    =>  ret := ret * 10 + 3;
                when '4'    =>  ret := ret * 10 + 4;
                when '5'    =>  ret := ret * 10 + 5;
                when '6'    =>  ret := ret * 10 + 6;
                when '7'    =>  ret := ret * 10 + 7;
                when '8'    =>  ret := ret * 10 + 8;
                when '9'    =>  ret := ret * 10 + 9;
                when ' '    =>  return ret;
                when others    =>  report "Wrong dec char " & RHS(idx);	return ret;
            end case;
            idx := idx + 1;
        end loop;
        return ret;
    end esl_str_dec2int;
      function esl_conv_string_hex (lv : STD_LOGIC_VECTOR) return STRING is
          constant str_len : integer := (lv'length + 3)/4;
          variable ret : STRING (1 to str_len);
          variable i, tmp: INTEGER;
          variable normal_lv : STD_LOGIC_VECTOR(lv'length - 1 downto 0);
          variable tmp_lv : STD_LOGIC_VECTOR(3 downto 0);
      begin
          normal_lv := lv;
          for i in 1 to str_len loop
              if(i = 1) then
                  if((lv'length mod 4) = 3) then
                      tmp_lv(2 downto 0) := normal_lv(lv'length - 1 downto lv'length - 3);
                      case tmp_lv(2 downto 0) is
                          when "000" => ret(i) := '0';
                          when "001" => ret(i) := '1';
                          when "010" => ret(i) := '2';
                          when "011" => ret(i) := '3';
                          when "100" => ret(i) := '4';
                          when "101" => ret(i) := '5';
                          when "110" => ret(i) := '6';
                          when "111" => ret(i) := '7';
                          when others  => ret(i) := 'X';
                      end case;
                  elsif((lv'length mod 4) = 2) then
                      tmp_lv(1 downto 0) := normal_lv(lv'length - 1 downto lv'length - 2);
                      case tmp_lv(1 downto 0) is
                          when "00" => ret(i) := '0';
                          when "01" => ret(i) := '1';
                          when "10" => ret(i) := '2';
                          when "11" => ret(i) := '3';
                          when others => ret(i) := 'X';
                      end case;
                  elsif((lv'length mod 4) = 1) then
                      tmp_lv(0 downto 0) := normal_lv(lv'length - 1 downto lv'length - 1);
                      case tmp_lv(0 downto 0) is
                          when "0" => ret(i) := '0';
                          when "1" => ret(i) := '1';
                          when others=> ret(i) := 'X';
                      end case;
                  elsif((lv'length mod 4) = 0) then
                      tmp_lv(3 downto 0) := normal_lv(lv'length - 1 downto lv'length - 4);
                      case tmp_lv(3 downto 0) is
                          when "0000" => ret(i) := '0';
                          when "0001" => ret(i) := '1';
                          when "0010" => ret(i) := '2';
                          when "0011" => ret(i) := '3';
                          when "0100" => ret(i) := '4';
                          when "0101" => ret(i) := '5';
                          when "0110" => ret(i) := '6';
                          when "0111" => ret(i) := '7';
                          when "1000" => ret(i) := '8';
                          when "1001" => ret(i) := '9';
                          when "1010" => ret(i) := 'a';
                          when "1011" => ret(i) := 'b';
                          when "1100" => ret(i) := 'c';
                          when "1101" => ret(i) := 'd';
                          when "1110" => ret(i) := 'e';
                          when "1111" => ret(i) := 'f';
                          when others   => ret(i) := 'X';
                      end case;
                  end if;
              else
                  tmp_lv(3 downto 0) := normal_lv((str_len - i) * 4 + 3 downto (str_len - i) * 4);
                  case tmp_lv(3 downto 0) is
                      when "0000" => ret(i) := '0';
                      when "0001" => ret(i) := '1';
                      when "0010" => ret(i) := '2';
                      when "0011" => ret(i) := '3';
                      when "0100" => ret(i) := '4';
                      when "0101" => ret(i) := '5';
                      when "0110" => ret(i) := '6';
                      when "0111" => ret(i) := '7';
                      when "1000" => ret(i) := '8';
                      when "1001" => ret(i) := '9';
                      when "1010" => ret(i) := 'a';
                      when "1011" => ret(i) := 'b';
                      when "1100" => ret(i) := 'c';
                      when "1101" => ret(i) := 'd';
                      when "1110" => ret(i) := 'e';
                      when "1111" => ret(i) := 'f';
                      when others   => ret(i) := 'X';
                  end case;
              end if;
          end loop;
          return ret;
      end function;

  -- purpose: initialise the random state variable based on an integer seed
  function init_rand(seed : integer) return T_RANDINT is
    variable result : T_RANDINT;
  begin
    -- If the seed is smaller than the minimum value of the random state variable, use the minimum value
    if seed < T_RANDINT'low then
      result := T_RANDINT'low;
      -- If the seed is larger than the maximum value of the random state variable, use the maximum value
    elsif seed > T_RANDINT'high then
      result := T_RANDINT'high;
      -- If the seed is within the range of the random state variable, just use the seed
    else
      result := seed;
    end if;
    -- Return the result
    return result;
  end init_rand;


  -- purpose: generate a random integer between min and max limits
  procedure rand_int(variable rand   : inout T_RANDINT;
                     constant minval : in    integer;
                     constant maxval : in    integer;
                     variable result : out   integer
                     ) is

    variable k, q      : integer;
    variable real_rand : real;
    variable res       : integer;

  begin
    -- Create a new random integer in the range 1 to 2**31-1 and put it back into rand VARIABLE
    -- Based on an example from Numerical Recipes in C, 2nd Edition, page 279
    k   := rand/127773;
    q   := 16807*(rand-k*127773)-2836*k;
    if q < 0 then
      q := q + 2147483647;
    end if;
    rand := init_rand(q);

    -- Convert this integer to a real number in the range 0 to 1
    real_rand := (real(rand - T_RANDINT'low)) / real(T_RANDINT'high - T_RANDINT'low);
    -- Convert this real number to an integer in the range minval to maxval
    -- The +1 and -0.5 are to get equal probability of minval and maxval as other values
    res    := integer((real_rand * real(maxval+1-minval)) - 0.5) + minval;
    -- VHDL real to integer conversion doesn't define what happens for x.5 so deal with this
    if res < minval then
      res  := minval;
    elsif res > maxval then
      res  := maxval;
    end if;
    -- assign output
    result := res;

  end rand_int;

begin
AESL_inst_TowerPeaks    :   TowerPeaks port map (
   ap_clk  =>  ap_clk,
   ap_rst  =>  ap_rst,
   ap_start  =>  ap_start,
   ap_done  =>  ap_done,
   ap_idle  =>  ap_idle,
   ap_ready  =>  ap_ready,
   towerET_0_0  =>  towerET_0_0,
   towerET_0_1  =>  towerET_0_1,
   towerET_0_2  =>  towerET_0_2,
   towerET_0_3  =>  towerET_0_3,
   towerET_1_0  =>  towerET_1_0,
   towerET_1_1  =>  towerET_1_1,
   towerET_1_2  =>  towerET_1_2,
   towerET_1_3  =>  towerET_1_3,
   towerET_2_0  =>  towerET_2_0,
   towerET_2_1  =>  towerET_2_1,
   towerET_2_2  =>  towerET_2_2,
   towerET_2_3  =>  towerET_2_3,
   towerET_3_0  =>  towerET_3_0,
   towerET_3_1  =>  towerET_3_1,
   towerET_3_2  =>  towerET_3_2,
   towerET_3_3  =>  towerET_3_3,
   towerET_4_0  =>  towerET_4_0,
   towerET_4_1  =>  towerET_4_1,
   towerET_4_2  =>  towerET_4_2,
   towerET_4_3  =>  towerET_4_3,
   towerET_5_0  =>  towerET_5_0,
   towerET_5_1  =>  towerET_5_1,
   towerET_5_2  =>  towerET_5_2,
   towerET_5_3  =>  towerET_5_3,
   towerET_6_0  =>  towerET_6_0,
   towerET_6_1  =>  towerET_6_1,
   towerET_6_2  =>  towerET_6_2,
   towerET_6_3  =>  towerET_6_3,
   towerET_7_0  =>  towerET_7_0,
   towerET_7_1  =>  towerET_7_1,
   towerET_7_2  =>  towerET_7_2,
   towerET_7_3  =>  towerET_7_3,
   towerET_8_0  =>  towerET_8_0,
   towerET_8_1  =>  towerET_8_1,
   towerET_8_2  =>  towerET_8_2,
   towerET_8_3  =>  towerET_8_3,
   towerET_9_0  =>  towerET_9_0,
   towerET_9_1  =>  towerET_9_1,
   towerET_9_2  =>  towerET_9_2,
   towerET_9_3  =>  towerET_9_3,
   towerET_10_0  =>  towerET_10_0,
   towerET_10_1  =>  towerET_10_1,
   towerET_10_2  =>  towerET_10_2,
   towerET_10_3  =>  towerET_10_3,
   towerET_11_0  =>  towerET_11_0,
   towerET_11_1  =>  towerET_11_1,
   towerET_11_2  =>  towerET_11_2,
   towerET_11_3  =>  towerET_11_3,
   towerET_12_0  =>  towerET_12_0,
   towerET_12_1  =>  towerET_12_1,
   towerET_12_2  =>  towerET_12_2,
   towerET_12_3  =>  towerET_12_3,
   towerET_13_0  =>  towerET_13_0,
   towerET_13_1  =>  towerET_13_1,
   towerET_13_2  =>  towerET_13_2,
   towerET_13_3  =>  towerET_13_3,
   towerET_14_0  =>  towerET_14_0,
   towerET_14_1  =>  towerET_14_1,
   towerET_14_2  =>  towerET_14_2,
   towerET_14_3  =>  towerET_14_3,
   towerET_15_0  =>  towerET_15_0,
   towerET_15_1  =>  towerET_15_1,
   towerET_15_2  =>  towerET_15_2,
   towerET_15_3  =>  towerET_15_3,
   towerET_16_0  =>  towerET_16_0,
   towerET_16_1  =>  towerET_16_1,
   towerET_16_2  =>  towerET_16_2,
   towerET_16_3  =>  towerET_16_3,
   TowerPhi_0  =>  TowerPhi_0,
   TowerPhi_0_ap_vld  =>  TowerPhi_0_ap_vld,
   TowerPhi_1  =>  TowerPhi_1,
   TowerPhi_1_ap_vld  =>  TowerPhi_1_ap_vld,
   TowerPhi_2  =>  TowerPhi_2,
   TowerPhi_2_ap_vld  =>  TowerPhi_2_ap_vld,
   TowerPhi_3  =>  TowerPhi_3,
   TowerPhi_3_ap_vld  =>  TowerPhi_3_ap_vld,
   TowerPhi_4  =>  TowerPhi_4,
   TowerPhi_4_ap_vld  =>  TowerPhi_4_ap_vld,
   TowerPhi_5  =>  TowerPhi_5,
   TowerPhi_5_ap_vld  =>  TowerPhi_5_ap_vld,
   TowerPhi_6  =>  TowerPhi_6,
   TowerPhi_6_ap_vld  =>  TowerPhi_6_ap_vld,
   TowerPhi_7  =>  TowerPhi_7,
   TowerPhi_7_ap_vld  =>  TowerPhi_7_ap_vld,
   TowerPhi_8  =>  TowerPhi_8,
   TowerPhi_8_ap_vld  =>  TowerPhi_8_ap_vld,
   TowerPhi_9  =>  TowerPhi_9,
   TowerPhi_9_ap_vld  =>  TowerPhi_9_ap_vld,
   TowerPhi_10  =>  TowerPhi_10,
   TowerPhi_10_ap_vld  =>  TowerPhi_10_ap_vld,
   TowerPhi_11  =>  TowerPhi_11,
   TowerPhi_11_ap_vld  =>  TowerPhi_11_ap_vld,
   TowerPhi_12  =>  TowerPhi_12,
   TowerPhi_12_ap_vld  =>  TowerPhi_12_ap_vld,
   TowerPhi_13  =>  TowerPhi_13,
   TowerPhi_13_ap_vld  =>  TowerPhi_13_ap_vld,
   TowerPhi_14  =>  TowerPhi_14,
   TowerPhi_14_ap_vld  =>  TowerPhi_14_ap_vld,
   TowerPhi_15  =>  TowerPhi_15,
   TowerPhi_15_ap_vld  =>  TowerPhi_15_ap_vld,
   TowerPhi_16  =>  TowerPhi_16,
   TowerPhi_16_ap_vld  =>  TowerPhi_16_ap_vld,
   TowerPhi_17  =>  TowerPhi_17,
   TowerPhi_17_ap_vld  =>  TowerPhi_17_ap_vld,
   TowerPhi_18  =>  TowerPhi_18,
   TowerPhi_18_ap_vld  =>  TowerPhi_18_ap_vld,
   TowerPhi_19  =>  TowerPhi_19,
   TowerPhi_19_ap_vld  =>  TowerPhi_19_ap_vld,
   TowerPhi_20  =>  TowerPhi_20,
   TowerPhi_20_ap_vld  =>  TowerPhi_20_ap_vld,
   TowerPhi_21  =>  TowerPhi_21,
   TowerPhi_21_ap_vld  =>  TowerPhi_21_ap_vld,
   TowerPhi_22  =>  TowerPhi_22,
   TowerPhi_22_ap_vld  =>  TowerPhi_22_ap_vld,
   TowerPhi_23  =>  TowerPhi_23,
   TowerPhi_23_ap_vld  =>  TowerPhi_23_ap_vld,
   TowerPhi_24  =>  TowerPhi_24,
   TowerPhi_24_ap_vld  =>  TowerPhi_24_ap_vld,
   TowerPhi_25  =>  TowerPhi_25,
   TowerPhi_25_ap_vld  =>  TowerPhi_25_ap_vld,
   TowerPhi_26  =>  TowerPhi_26,
   TowerPhi_26_ap_vld  =>  TowerPhi_26_ap_vld,
   TowerPhi_27  =>  TowerPhi_27,
   TowerPhi_27_ap_vld  =>  TowerPhi_27_ap_vld,
   TowerPhi_28  =>  TowerPhi_28,
   TowerPhi_28_ap_vld  =>  TowerPhi_28_ap_vld,
   TowerPhi_29  =>  TowerPhi_29,
   TowerPhi_29_ap_vld  =>  TowerPhi_29_ap_vld,
   TowerEta_0  =>  TowerEta_0,
   TowerEta_0_ap_vld  =>  TowerEta_0_ap_vld,
   TowerEta_1  =>  TowerEta_1,
   TowerEta_1_ap_vld  =>  TowerEta_1_ap_vld,
   TowerEta_2  =>  TowerEta_2,
   TowerEta_2_ap_vld  =>  TowerEta_2_ap_vld,
   TowerEta_3  =>  TowerEta_3,
   TowerEta_3_ap_vld  =>  TowerEta_3_ap_vld,
   TowerEta_4  =>  TowerEta_4,
   TowerEta_4_ap_vld  =>  TowerEta_4_ap_vld,
   TowerEta_5  =>  TowerEta_5,
   TowerEta_5_ap_vld  =>  TowerEta_5_ap_vld,
   TowerEta_6  =>  TowerEta_6,
   TowerEta_6_ap_vld  =>  TowerEta_6_ap_vld,
   TowerEta_7  =>  TowerEta_7,
   TowerEta_7_ap_vld  =>  TowerEta_7_ap_vld,
   TowerEta_8  =>  TowerEta_8,
   TowerEta_8_ap_vld  =>  TowerEta_8_ap_vld,
   TowerEta_9  =>  TowerEta_9,
   TowerEta_9_ap_vld  =>  TowerEta_9_ap_vld,
   TowerEta_10  =>  TowerEta_10,
   TowerEta_10_ap_vld  =>  TowerEta_10_ap_vld,
   TowerEta_11  =>  TowerEta_11,
   TowerEta_11_ap_vld  =>  TowerEta_11_ap_vld,
   TowerEta_12  =>  TowerEta_12,
   TowerEta_12_ap_vld  =>  TowerEta_12_ap_vld,
   TowerEta_13  =>  TowerEta_13,
   TowerEta_13_ap_vld  =>  TowerEta_13_ap_vld,
   TowerEta_14  =>  TowerEta_14,
   TowerEta_14_ap_vld  =>  TowerEta_14_ap_vld,
   TowerEta_15  =>  TowerEta_15,
   TowerEta_15_ap_vld  =>  TowerEta_15_ap_vld,
   TowerEta_16  =>  TowerEta_16,
   TowerEta_16_ap_vld  =>  TowerEta_16_ap_vld,
   TowerEta_17  =>  TowerEta_17,
   TowerEta_17_ap_vld  =>  TowerEta_17_ap_vld,
   TowerEta_18  =>  TowerEta_18,
   TowerEta_18_ap_vld  =>  TowerEta_18_ap_vld,
   TowerEta_19  =>  TowerEta_19,
   TowerEta_19_ap_vld  =>  TowerEta_19_ap_vld,
   TowerEta_20  =>  TowerEta_20,
   TowerEta_20_ap_vld  =>  TowerEta_20_ap_vld,
   TowerEta_21  =>  TowerEta_21,
   TowerEta_21_ap_vld  =>  TowerEta_21_ap_vld,
   TowerEta_22  =>  TowerEta_22,
   TowerEta_22_ap_vld  =>  TowerEta_22_ap_vld,
   TowerEta_23  =>  TowerEta_23,
   TowerEta_23_ap_vld  =>  TowerEta_23_ap_vld,
   TowerEta_24  =>  TowerEta_24,
   TowerEta_24_ap_vld  =>  TowerEta_24_ap_vld,
   TowerEta_25  =>  TowerEta_25,
   TowerEta_25_ap_vld  =>  TowerEta_25_ap_vld,
   TowerEta_26  =>  TowerEta_26,
   TowerEta_26_ap_vld  =>  TowerEta_26_ap_vld,
   TowerEta_27  =>  TowerEta_27,
   TowerEta_27_ap_vld  =>  TowerEta_27_ap_vld,
   TowerEta_28  =>  TowerEta_28,
   TowerEta_28_ap_vld  =>  TowerEta_28_ap_vld,
   TowerEta_29  =>  TowerEta_29,
   TowerEta_29_ap_vld  =>  TowerEta_29_ap_vld
);

-- Assignment for control signal
  ap_clk <= AESL_clock;
  ap_rst <= AESL_reset;
  AESL_reset <= rst;
  ap_start <= AESL_start;
  AESL_start <= start;
  AESL_done <= ap_done;
  AESL_idle <= ap_idle;
  AESL_ready <= ap_ready;
  AESL_ce <= ce;
  AESL_continue <= continue;
gen_check_strlSignal_AESL_done_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
      NULL;
    else
        if ( AESL_done /= '1' and AESL_done /= '0' ) then
            assert false report "Control signal AESL_done is invalid!" severity failure;
        end if;
    end if;
  end if;
end process;
gen_check_strlSignal_AESL_ready_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
      NULL;
    else
        if ( AESL_ready /= '1' and AESL_ready /= '0' ) then
            assert false report "Control signal AESL_ready is invalid!" severity failure;
        end if;
    end if;
  end if;
end process;
gen_assign_towerET_0_0_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_0_0 <= AESL_REG_towerET_0_0;
end process;
read_file_process_towerET_0_0 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_0_0, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_0_0 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_0_0 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_0_1_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_0_1 <= AESL_REG_towerET_0_1;
end process;
read_file_process_towerET_0_1 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_0_1, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_0_1 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_0_1 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_0_2_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_0_2 <= AESL_REG_towerET_0_2;
end process;
read_file_process_towerET_0_2 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_0_2, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_0_2 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_0_2 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_0_3_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_0_3 <= AESL_REG_towerET_0_3;
end process;
read_file_process_towerET_0_3 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_0_3, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_0_3 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_0_3 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_1_0_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_1_0 <= AESL_REG_towerET_1_0;
end process;
read_file_process_towerET_1_0 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_1_0, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_1_0 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_1_0 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_1_1_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_1_1 <= AESL_REG_towerET_1_1;
end process;
read_file_process_towerET_1_1 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_1_1, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_1_1 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_1_1 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_1_2_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_1_2 <= AESL_REG_towerET_1_2;
end process;
read_file_process_towerET_1_2 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_1_2, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_1_2 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_1_2 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_1_3_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_1_3 <= AESL_REG_towerET_1_3;
end process;
read_file_process_towerET_1_3 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_1_3, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_1_3 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_1_3 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_2_0_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_2_0 <= AESL_REG_towerET_2_0;
end process;
read_file_process_towerET_2_0 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_2_0, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_2_0 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_2_0 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_2_1_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_2_1 <= AESL_REG_towerET_2_1;
end process;
read_file_process_towerET_2_1 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_2_1, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_2_1 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_2_1 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_2_2_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_2_2 <= AESL_REG_towerET_2_2;
end process;
read_file_process_towerET_2_2 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_2_2, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_2_2 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_2_2 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_2_3_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_2_3 <= AESL_REG_towerET_2_3;
end process;
read_file_process_towerET_2_3 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_2_3, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_2_3 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_2_3 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_3_0_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_3_0 <= AESL_REG_towerET_3_0;
end process;
read_file_process_towerET_3_0 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_3_0, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_3_0 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_3_0 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_3_1_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_3_1 <= AESL_REG_towerET_3_1;
end process;
read_file_process_towerET_3_1 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_3_1, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_3_1 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_3_1 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_3_2_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_3_2 <= AESL_REG_towerET_3_2;
end process;
read_file_process_towerET_3_2 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_3_2, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_3_2 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_3_2 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_3_3_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_3_3 <= AESL_REG_towerET_3_3;
end process;
read_file_process_towerET_3_3 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_3_3, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_3_3 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_3_3 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_4_0_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_4_0 <= AESL_REG_towerET_4_0;
end process;
read_file_process_towerET_4_0 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_4_0, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_4_0 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_4_0 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_4_1_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_4_1 <= AESL_REG_towerET_4_1;
end process;
read_file_process_towerET_4_1 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_4_1, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_4_1 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_4_1 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_4_2_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_4_2 <= AESL_REG_towerET_4_2;
end process;
read_file_process_towerET_4_2 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_4_2, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_4_2 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_4_2 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_4_3_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_4_3 <= AESL_REG_towerET_4_3;
end process;
read_file_process_towerET_4_3 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_4_3, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_4_3 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_4_3 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_5_0_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_5_0 <= AESL_REG_towerET_5_0;
end process;
read_file_process_towerET_5_0 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_5_0, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_5_0 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_5_0 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_5_1_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_5_1 <= AESL_REG_towerET_5_1;
end process;
read_file_process_towerET_5_1 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_5_1, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_5_1 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_5_1 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_5_2_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_5_2 <= AESL_REG_towerET_5_2;
end process;
read_file_process_towerET_5_2 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_5_2, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_5_2 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_5_2 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_5_3_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_5_3 <= AESL_REG_towerET_5_3;
end process;
read_file_process_towerET_5_3 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_5_3, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_5_3 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_5_3 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_6_0_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_6_0 <= AESL_REG_towerET_6_0;
end process;
read_file_process_towerET_6_0 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_6_0, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_6_0 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_6_0 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_6_1_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_6_1 <= AESL_REG_towerET_6_1;
end process;
read_file_process_towerET_6_1 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_6_1, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_6_1 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_6_1 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_6_2_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_6_2 <= AESL_REG_towerET_6_2;
end process;
read_file_process_towerET_6_2 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_6_2, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_6_2 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_6_2 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_6_3_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_6_3 <= AESL_REG_towerET_6_3;
end process;
read_file_process_towerET_6_3 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_6_3, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_6_3 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_6_3 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_7_0_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_7_0 <= AESL_REG_towerET_7_0;
end process;
read_file_process_towerET_7_0 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_7_0, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_7_0 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_7_0 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_7_1_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_7_1 <= AESL_REG_towerET_7_1;
end process;
read_file_process_towerET_7_1 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_7_1, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_7_1 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_7_1 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_7_2_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_7_2 <= AESL_REG_towerET_7_2;
end process;
read_file_process_towerET_7_2 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_7_2, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_7_2 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_7_2 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_7_3_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_7_3 <= AESL_REG_towerET_7_3;
end process;
read_file_process_towerET_7_3 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_7_3, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_7_3 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_7_3 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_8_0_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_8_0 <= AESL_REG_towerET_8_0;
end process;
read_file_process_towerET_8_0 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_8_0, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_8_0 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_8_0 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_8_1_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_8_1 <= AESL_REG_towerET_8_1;
end process;
read_file_process_towerET_8_1 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_8_1, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_8_1 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_8_1 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_8_2_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_8_2 <= AESL_REG_towerET_8_2;
end process;
read_file_process_towerET_8_2 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_8_2, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_8_2 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_8_2 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_8_3_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_8_3 <= AESL_REG_towerET_8_3;
end process;
read_file_process_towerET_8_3 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_8_3, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_8_3 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_8_3 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_9_0_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_9_0 <= AESL_REG_towerET_9_0;
end process;
read_file_process_towerET_9_0 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_9_0, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_9_0 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_9_0 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_9_1_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_9_1 <= AESL_REG_towerET_9_1;
end process;
read_file_process_towerET_9_1 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_9_1, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_9_1 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_9_1 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_9_2_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_9_2 <= AESL_REG_towerET_9_2;
end process;
read_file_process_towerET_9_2 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_9_2, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_9_2 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_9_2 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_9_3_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_9_3 <= AESL_REG_towerET_9_3;
end process;
read_file_process_towerET_9_3 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_9_3, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_9_3 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_9_3 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_10_0_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_10_0 <= AESL_REG_towerET_10_0;
end process;
read_file_process_towerET_10_0 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_10_0, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_10_0 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_10_0 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_10_1_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_10_1 <= AESL_REG_towerET_10_1;
end process;
read_file_process_towerET_10_1 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_10_1, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_10_1 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_10_1 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_10_2_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_10_2 <= AESL_REG_towerET_10_2;
end process;
read_file_process_towerET_10_2 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_10_2, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_10_2 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_10_2 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_10_3_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_10_3 <= AESL_REG_towerET_10_3;
end process;
read_file_process_towerET_10_3 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_10_3, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_10_3 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_10_3 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_11_0_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_11_0 <= AESL_REG_towerET_11_0;
end process;
read_file_process_towerET_11_0 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_11_0, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_11_0 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_11_0 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_11_1_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_11_1 <= AESL_REG_towerET_11_1;
end process;
read_file_process_towerET_11_1 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_11_1, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_11_1 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_11_1 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_11_2_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_11_2 <= AESL_REG_towerET_11_2;
end process;
read_file_process_towerET_11_2 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_11_2, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_11_2 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_11_2 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_11_3_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_11_3 <= AESL_REG_towerET_11_3;
end process;
read_file_process_towerET_11_3 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_11_3, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_11_3 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_11_3 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_12_0_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_12_0 <= AESL_REG_towerET_12_0;
end process;
read_file_process_towerET_12_0 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_12_0, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_12_0 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_12_0 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_12_1_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_12_1 <= AESL_REG_towerET_12_1;
end process;
read_file_process_towerET_12_1 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_12_1, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_12_1 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_12_1 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_12_2_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_12_2 <= AESL_REG_towerET_12_2;
end process;
read_file_process_towerET_12_2 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_12_2, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_12_2 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_12_2 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_12_3_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_12_3 <= AESL_REG_towerET_12_3;
end process;
read_file_process_towerET_12_3 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_12_3, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_12_3 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_12_3 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_13_0_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_13_0 <= AESL_REG_towerET_13_0;
end process;
read_file_process_towerET_13_0 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_13_0, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_13_0 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_13_0 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_13_1_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_13_1 <= AESL_REG_towerET_13_1;
end process;
read_file_process_towerET_13_1 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_13_1, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_13_1 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_13_1 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_13_2_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_13_2 <= AESL_REG_towerET_13_2;
end process;
read_file_process_towerET_13_2 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_13_2, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_13_2 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_13_2 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_13_3_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_13_3 <= AESL_REG_towerET_13_3;
end process;
read_file_process_towerET_13_3 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_13_3, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_13_3 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_13_3 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_14_0_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_14_0 <= AESL_REG_towerET_14_0;
end process;
read_file_process_towerET_14_0 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_14_0, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_14_0 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_14_0 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_14_1_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_14_1 <= AESL_REG_towerET_14_1;
end process;
read_file_process_towerET_14_1 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_14_1, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_14_1 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_14_1 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_14_2_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_14_2 <= AESL_REG_towerET_14_2;
end process;
read_file_process_towerET_14_2 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_14_2, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_14_2 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_14_2 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_14_3_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_14_3 <= AESL_REG_towerET_14_3;
end process;
read_file_process_towerET_14_3 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_14_3, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_14_3 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_14_3 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_15_0_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_15_0 <= AESL_REG_towerET_15_0;
end process;
read_file_process_towerET_15_0 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_15_0, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_15_0 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_15_0 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_15_1_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_15_1 <= AESL_REG_towerET_15_1;
end process;
read_file_process_towerET_15_1 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_15_1, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_15_1 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_15_1 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_15_2_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_15_2 <= AESL_REG_towerET_15_2;
end process;
read_file_process_towerET_15_2 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_15_2, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_15_2 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_15_2 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_15_3_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_15_3 <= AESL_REG_towerET_15_3;
end process;
read_file_process_towerET_15_3 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_15_3, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_15_3 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_15_3 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_16_0_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_16_0 <= AESL_REG_towerET_16_0;
end process;
read_file_process_towerET_16_0 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_16_0, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_16_0 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_16_0 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_16_1_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_16_1 <= AESL_REG_towerET_16_1;
end process;
read_file_process_towerET_16_1 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_16_1, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_16_1 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_16_1 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_16_2_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_16_2 <= AESL_REG_towerET_16_2;
end process;
read_file_process_towerET_16_2 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_16_2, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_16_2 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_16_2 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_assign_towerET_16_3_proc : process
begin
  wait until (AESL_clock'event and AESL_clock = '1');
  wait for 0.45 ns;
  towerET_16_3 <= AESL_REG_towerET_16_3;
end process;
read_file_process_towerET_16_3 : process
  file        fp          :   TEXT;
  variable    fstatus     :   FILE_OPEN_STATUS;
  variable    token_line  :   LINE;
  variable    token       :   STRING(1 to 168);
  variable    i           :   INTEGER;
  variable    transaction_finish  :   INTEGER;
  variable    transaction_idx     :   INTEGER:= 0;
  variable    rand        :   T_RANDINT     := init_rand(0);
  variable    rint        :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVIN_towerET_16_3, READ_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVIN_towerET_16_3 & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    if(token(1 to 13) /= "[[[runtime]]]") then
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    esl_read_token(fp, token_line, token);
    while(token(1 to 14) /= "[[[/runtime]]]") loop
        if(token(1 to 15) /= "[[transaction]]") then
            assert false report "ERROR: Simulation using HLS TB failed." severity failure;
        end if;
        esl_read_token(fp, token_line, token);  -- Skip transaction number
        esl_read_token(fp, token_line, token);
        wait for 0.2 ns;
        while(ready_wire /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
            wait for 0.2 ns;
        end loop;
        if(token(1 to 16) /= "[[/transaction]]") then
            AESL_REG_towerET_16_3 := esl_str2lv_hex(token, 16 );
            esl_read_token(fp, token_line, token);
        end if;
        wait until AESL_clock'event and AESL_clock = '1';
        esl_read_token(fp, token_line, token);
    end loop;
    file_close(fp);
    wait;
end process;

gen_out_TowerPhi_0_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerPhi_0 := (others => '0'); 
    elsif(TowerPhi_0_ap_vld = '1') then
        AESL_REG_TowerPhi_0 := TowerPhi_0;
        AESL_REG_TowerPhi_0_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerPhi_0 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerPhi_0_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerPhi_0_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerPhi_0_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerPhi_0_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerPhi_0));
            writeline(fp, token_line);
            AESL_REG_TowerPhi_0_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerPhi_1_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerPhi_1 := (others => '0'); 
    elsif(TowerPhi_1_ap_vld = '1') then
        AESL_REG_TowerPhi_1 := TowerPhi_1;
        AESL_REG_TowerPhi_1_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerPhi_1 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerPhi_1_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerPhi_1_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerPhi_1_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerPhi_1_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerPhi_1));
            writeline(fp, token_line);
            AESL_REG_TowerPhi_1_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerPhi_2_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerPhi_2 := (others => '0'); 
    elsif(TowerPhi_2_ap_vld = '1') then
        AESL_REG_TowerPhi_2 := TowerPhi_2;
        AESL_REG_TowerPhi_2_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerPhi_2 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerPhi_2_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerPhi_2_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerPhi_2_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerPhi_2_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerPhi_2));
            writeline(fp, token_line);
            AESL_REG_TowerPhi_2_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerPhi_3_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerPhi_3 := (others => '0'); 
    elsif(TowerPhi_3_ap_vld = '1') then
        AESL_REG_TowerPhi_3 := TowerPhi_3;
        AESL_REG_TowerPhi_3_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerPhi_3 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerPhi_3_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerPhi_3_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerPhi_3_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerPhi_3_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerPhi_3));
            writeline(fp, token_line);
            AESL_REG_TowerPhi_3_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerPhi_4_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerPhi_4 := (others => '0'); 
    elsif(TowerPhi_4_ap_vld = '1') then
        AESL_REG_TowerPhi_4 := TowerPhi_4;
        AESL_REG_TowerPhi_4_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerPhi_4 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerPhi_4_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerPhi_4_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerPhi_4_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerPhi_4_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerPhi_4));
            writeline(fp, token_line);
            AESL_REG_TowerPhi_4_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerPhi_5_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerPhi_5 := (others => '0'); 
    elsif(TowerPhi_5_ap_vld = '1') then
        AESL_REG_TowerPhi_5 := TowerPhi_5;
        AESL_REG_TowerPhi_5_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerPhi_5 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerPhi_5_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerPhi_5_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerPhi_5_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerPhi_5_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerPhi_5));
            writeline(fp, token_line);
            AESL_REG_TowerPhi_5_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerPhi_6_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerPhi_6 := (others => '0'); 
    elsif(TowerPhi_6_ap_vld = '1') then
        AESL_REG_TowerPhi_6 := TowerPhi_6;
        AESL_REG_TowerPhi_6_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerPhi_6 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerPhi_6_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerPhi_6_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerPhi_6_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerPhi_6_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerPhi_6));
            writeline(fp, token_line);
            AESL_REG_TowerPhi_6_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerPhi_7_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerPhi_7 := (others => '0'); 
    elsif(TowerPhi_7_ap_vld = '1') then
        AESL_REG_TowerPhi_7 := TowerPhi_7;
        AESL_REG_TowerPhi_7_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerPhi_7 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerPhi_7_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerPhi_7_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerPhi_7_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerPhi_7_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerPhi_7));
            writeline(fp, token_line);
            AESL_REG_TowerPhi_7_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerPhi_8_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerPhi_8 := (others => '0'); 
    elsif(TowerPhi_8_ap_vld = '1') then
        AESL_REG_TowerPhi_8 := TowerPhi_8;
        AESL_REG_TowerPhi_8_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerPhi_8 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerPhi_8_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerPhi_8_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerPhi_8_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerPhi_8_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerPhi_8));
            writeline(fp, token_line);
            AESL_REG_TowerPhi_8_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerPhi_9_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerPhi_9 := (others => '0'); 
    elsif(TowerPhi_9_ap_vld = '1') then
        AESL_REG_TowerPhi_9 := TowerPhi_9;
        AESL_REG_TowerPhi_9_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerPhi_9 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerPhi_9_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerPhi_9_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerPhi_9_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerPhi_9_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerPhi_9));
            writeline(fp, token_line);
            AESL_REG_TowerPhi_9_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerPhi_10_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerPhi_10 := (others => '0'); 
    elsif(TowerPhi_10_ap_vld = '1') then
        AESL_REG_TowerPhi_10 := TowerPhi_10;
        AESL_REG_TowerPhi_10_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerPhi_10 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerPhi_10_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerPhi_10_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerPhi_10_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerPhi_10_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerPhi_10));
            writeline(fp, token_line);
            AESL_REG_TowerPhi_10_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerPhi_11_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerPhi_11 := (others => '0'); 
    elsif(TowerPhi_11_ap_vld = '1') then
        AESL_REG_TowerPhi_11 := TowerPhi_11;
        AESL_REG_TowerPhi_11_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerPhi_11 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerPhi_11_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerPhi_11_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerPhi_11_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerPhi_11_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerPhi_11));
            writeline(fp, token_line);
            AESL_REG_TowerPhi_11_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerPhi_12_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerPhi_12 := (others => '0'); 
    elsif(TowerPhi_12_ap_vld = '1') then
        AESL_REG_TowerPhi_12 := TowerPhi_12;
        AESL_REG_TowerPhi_12_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerPhi_12 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerPhi_12_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerPhi_12_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerPhi_12_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerPhi_12_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerPhi_12));
            writeline(fp, token_line);
            AESL_REG_TowerPhi_12_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerPhi_13_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerPhi_13 := (others => '0'); 
    elsif(TowerPhi_13_ap_vld = '1') then
        AESL_REG_TowerPhi_13 := TowerPhi_13;
        AESL_REG_TowerPhi_13_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerPhi_13 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerPhi_13_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerPhi_13_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerPhi_13_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerPhi_13_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerPhi_13));
            writeline(fp, token_line);
            AESL_REG_TowerPhi_13_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerPhi_14_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerPhi_14 := (others => '0'); 
    elsif(TowerPhi_14_ap_vld = '1') then
        AESL_REG_TowerPhi_14 := TowerPhi_14;
        AESL_REG_TowerPhi_14_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerPhi_14 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerPhi_14_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerPhi_14_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerPhi_14_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerPhi_14_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerPhi_14));
            writeline(fp, token_line);
            AESL_REG_TowerPhi_14_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerPhi_15_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerPhi_15 := (others => '0'); 
    elsif(TowerPhi_15_ap_vld = '1') then
        AESL_REG_TowerPhi_15 := TowerPhi_15;
        AESL_REG_TowerPhi_15_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerPhi_15 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerPhi_15_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerPhi_15_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerPhi_15_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerPhi_15_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerPhi_15));
            writeline(fp, token_line);
            AESL_REG_TowerPhi_15_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerPhi_16_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerPhi_16 := (others => '0'); 
    elsif(TowerPhi_16_ap_vld = '1') then
        AESL_REG_TowerPhi_16 := TowerPhi_16;
        AESL_REG_TowerPhi_16_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerPhi_16 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerPhi_16_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerPhi_16_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerPhi_16_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerPhi_16_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerPhi_16));
            writeline(fp, token_line);
            AESL_REG_TowerPhi_16_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerPhi_17_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerPhi_17 := (others => '0'); 
    elsif(TowerPhi_17_ap_vld = '1') then
        AESL_REG_TowerPhi_17 := TowerPhi_17;
        AESL_REG_TowerPhi_17_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerPhi_17 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerPhi_17_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerPhi_17_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerPhi_17_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerPhi_17_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerPhi_17));
            writeline(fp, token_line);
            AESL_REG_TowerPhi_17_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerPhi_18_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerPhi_18 := (others => '0'); 
    elsif(TowerPhi_18_ap_vld = '1') then
        AESL_REG_TowerPhi_18 := TowerPhi_18;
        AESL_REG_TowerPhi_18_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerPhi_18 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerPhi_18_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerPhi_18_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerPhi_18_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerPhi_18_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerPhi_18));
            writeline(fp, token_line);
            AESL_REG_TowerPhi_18_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerPhi_19_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerPhi_19 := (others => '0'); 
    elsif(TowerPhi_19_ap_vld = '1') then
        AESL_REG_TowerPhi_19 := TowerPhi_19;
        AESL_REG_TowerPhi_19_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerPhi_19 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerPhi_19_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerPhi_19_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerPhi_19_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerPhi_19_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerPhi_19));
            writeline(fp, token_line);
            AESL_REG_TowerPhi_19_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerPhi_20_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerPhi_20 := (others => '0'); 
    elsif(TowerPhi_20_ap_vld = '1') then
        AESL_REG_TowerPhi_20 := TowerPhi_20;
        AESL_REG_TowerPhi_20_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerPhi_20 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerPhi_20_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerPhi_20_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerPhi_20_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerPhi_20_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerPhi_20));
            writeline(fp, token_line);
            AESL_REG_TowerPhi_20_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerPhi_21_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerPhi_21 := (others => '0'); 
    elsif(TowerPhi_21_ap_vld = '1') then
        AESL_REG_TowerPhi_21 := TowerPhi_21;
        AESL_REG_TowerPhi_21_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerPhi_21 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerPhi_21_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerPhi_21_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerPhi_21_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerPhi_21_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerPhi_21));
            writeline(fp, token_line);
            AESL_REG_TowerPhi_21_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerPhi_22_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerPhi_22 := (others => '0'); 
    elsif(TowerPhi_22_ap_vld = '1') then
        AESL_REG_TowerPhi_22 := TowerPhi_22;
        AESL_REG_TowerPhi_22_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerPhi_22 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerPhi_22_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerPhi_22_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerPhi_22_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerPhi_22_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerPhi_22));
            writeline(fp, token_line);
            AESL_REG_TowerPhi_22_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerPhi_23_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerPhi_23 := (others => '0'); 
    elsif(TowerPhi_23_ap_vld = '1') then
        AESL_REG_TowerPhi_23 := TowerPhi_23;
        AESL_REG_TowerPhi_23_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerPhi_23 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerPhi_23_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerPhi_23_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerPhi_23_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerPhi_23_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerPhi_23));
            writeline(fp, token_line);
            AESL_REG_TowerPhi_23_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerPhi_24_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerPhi_24 := (others => '0'); 
    elsif(TowerPhi_24_ap_vld = '1') then
        AESL_REG_TowerPhi_24 := TowerPhi_24;
        AESL_REG_TowerPhi_24_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerPhi_24 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerPhi_24_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerPhi_24_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerPhi_24_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerPhi_24_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerPhi_24));
            writeline(fp, token_line);
            AESL_REG_TowerPhi_24_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerPhi_25_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerPhi_25 := (others => '0'); 
    elsif(TowerPhi_25_ap_vld = '1') then
        AESL_REG_TowerPhi_25 := TowerPhi_25;
        AESL_REG_TowerPhi_25_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerPhi_25 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerPhi_25_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerPhi_25_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerPhi_25_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerPhi_25_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerPhi_25));
            writeline(fp, token_line);
            AESL_REG_TowerPhi_25_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerPhi_26_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerPhi_26 := (others => '0'); 
    elsif(TowerPhi_26_ap_vld = '1') then
        AESL_REG_TowerPhi_26 := TowerPhi_26;
        AESL_REG_TowerPhi_26_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerPhi_26 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerPhi_26_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerPhi_26_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerPhi_26_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerPhi_26_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerPhi_26));
            writeline(fp, token_line);
            AESL_REG_TowerPhi_26_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerPhi_27_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerPhi_27 := (others => '0'); 
    elsif(TowerPhi_27_ap_vld = '1') then
        AESL_REG_TowerPhi_27 := TowerPhi_27;
        AESL_REG_TowerPhi_27_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerPhi_27 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerPhi_27_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerPhi_27_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerPhi_27_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerPhi_27_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerPhi_27));
            writeline(fp, token_line);
            AESL_REG_TowerPhi_27_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerPhi_28_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerPhi_28 := (others => '0'); 
    elsif(TowerPhi_28_ap_vld = '1') then
        AESL_REG_TowerPhi_28 := TowerPhi_28;
        AESL_REG_TowerPhi_28_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerPhi_28 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerPhi_28_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerPhi_28_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerPhi_28_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerPhi_28_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerPhi_28));
            writeline(fp, token_line);
            AESL_REG_TowerPhi_28_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerPhi_29_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerPhi_29 := (others => '0'); 
    elsif(TowerPhi_29_ap_vld = '1') then
        AESL_REG_TowerPhi_29 := TowerPhi_29;
        AESL_REG_TowerPhi_29_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerPhi_29 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerPhi_29_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerPhi_29_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerPhi_29_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerPhi_29_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerPhi_29));
            writeline(fp, token_line);
            AESL_REG_TowerPhi_29_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerEta_0_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerEta_0 := (others => '0'); 
    elsif(TowerEta_0_ap_vld = '1') then
        AESL_REG_TowerEta_0 := TowerEta_0;
        AESL_REG_TowerEta_0_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerEta_0 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerEta_0_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerEta_0_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerEta_0_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerEta_0_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerEta_0));
            writeline(fp, token_line);
            AESL_REG_TowerEta_0_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerEta_1_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerEta_1 := (others => '0'); 
    elsif(TowerEta_1_ap_vld = '1') then
        AESL_REG_TowerEta_1 := TowerEta_1;
        AESL_REG_TowerEta_1_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerEta_1 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerEta_1_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerEta_1_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerEta_1_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerEta_1_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerEta_1));
            writeline(fp, token_line);
            AESL_REG_TowerEta_1_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerEta_2_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerEta_2 := (others => '0'); 
    elsif(TowerEta_2_ap_vld = '1') then
        AESL_REG_TowerEta_2 := TowerEta_2;
        AESL_REG_TowerEta_2_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerEta_2 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerEta_2_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerEta_2_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerEta_2_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerEta_2_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerEta_2));
            writeline(fp, token_line);
            AESL_REG_TowerEta_2_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerEta_3_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerEta_3 := (others => '0'); 
    elsif(TowerEta_3_ap_vld = '1') then
        AESL_REG_TowerEta_3 := TowerEta_3;
        AESL_REG_TowerEta_3_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerEta_3 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerEta_3_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerEta_3_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerEta_3_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerEta_3_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerEta_3));
            writeline(fp, token_line);
            AESL_REG_TowerEta_3_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerEta_4_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerEta_4 := (others => '0'); 
    elsif(TowerEta_4_ap_vld = '1') then
        AESL_REG_TowerEta_4 := TowerEta_4;
        AESL_REG_TowerEta_4_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerEta_4 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerEta_4_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerEta_4_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerEta_4_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerEta_4_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerEta_4));
            writeline(fp, token_line);
            AESL_REG_TowerEta_4_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerEta_5_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerEta_5 := (others => '0'); 
    elsif(TowerEta_5_ap_vld = '1') then
        AESL_REG_TowerEta_5 := TowerEta_5;
        AESL_REG_TowerEta_5_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerEta_5 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerEta_5_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerEta_5_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerEta_5_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerEta_5_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerEta_5));
            writeline(fp, token_line);
            AESL_REG_TowerEta_5_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerEta_6_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerEta_6 := (others => '0'); 
    elsif(TowerEta_6_ap_vld = '1') then
        AESL_REG_TowerEta_6 := TowerEta_6;
        AESL_REG_TowerEta_6_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerEta_6 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerEta_6_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerEta_6_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerEta_6_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerEta_6_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerEta_6));
            writeline(fp, token_line);
            AESL_REG_TowerEta_6_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerEta_7_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerEta_7 := (others => '0'); 
    elsif(TowerEta_7_ap_vld = '1') then
        AESL_REG_TowerEta_7 := TowerEta_7;
        AESL_REG_TowerEta_7_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerEta_7 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerEta_7_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerEta_7_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerEta_7_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerEta_7_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerEta_7));
            writeline(fp, token_line);
            AESL_REG_TowerEta_7_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerEta_8_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerEta_8 := (others => '0'); 
    elsif(TowerEta_8_ap_vld = '1') then
        AESL_REG_TowerEta_8 := TowerEta_8;
        AESL_REG_TowerEta_8_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerEta_8 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerEta_8_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerEta_8_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerEta_8_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerEta_8_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerEta_8));
            writeline(fp, token_line);
            AESL_REG_TowerEta_8_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerEta_9_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerEta_9 := (others => '0'); 
    elsif(TowerEta_9_ap_vld = '1') then
        AESL_REG_TowerEta_9 := TowerEta_9;
        AESL_REG_TowerEta_9_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerEta_9 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerEta_9_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerEta_9_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerEta_9_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerEta_9_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerEta_9));
            writeline(fp, token_line);
            AESL_REG_TowerEta_9_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerEta_10_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerEta_10 := (others => '0'); 
    elsif(TowerEta_10_ap_vld = '1') then
        AESL_REG_TowerEta_10 := TowerEta_10;
        AESL_REG_TowerEta_10_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerEta_10 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerEta_10_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerEta_10_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerEta_10_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerEta_10_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerEta_10));
            writeline(fp, token_line);
            AESL_REG_TowerEta_10_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerEta_11_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerEta_11 := (others => '0'); 
    elsif(TowerEta_11_ap_vld = '1') then
        AESL_REG_TowerEta_11 := TowerEta_11;
        AESL_REG_TowerEta_11_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerEta_11 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerEta_11_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerEta_11_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerEta_11_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerEta_11_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerEta_11));
            writeline(fp, token_line);
            AESL_REG_TowerEta_11_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerEta_12_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerEta_12 := (others => '0'); 
    elsif(TowerEta_12_ap_vld = '1') then
        AESL_REG_TowerEta_12 := TowerEta_12;
        AESL_REG_TowerEta_12_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerEta_12 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerEta_12_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerEta_12_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerEta_12_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerEta_12_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerEta_12));
            writeline(fp, token_line);
            AESL_REG_TowerEta_12_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerEta_13_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerEta_13 := (others => '0'); 
    elsif(TowerEta_13_ap_vld = '1') then
        AESL_REG_TowerEta_13 := TowerEta_13;
        AESL_REG_TowerEta_13_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerEta_13 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerEta_13_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerEta_13_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerEta_13_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerEta_13_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerEta_13));
            writeline(fp, token_line);
            AESL_REG_TowerEta_13_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerEta_14_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerEta_14 := (others => '0'); 
    elsif(TowerEta_14_ap_vld = '1') then
        AESL_REG_TowerEta_14 := TowerEta_14;
        AESL_REG_TowerEta_14_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerEta_14 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerEta_14_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerEta_14_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerEta_14_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerEta_14_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerEta_14));
            writeline(fp, token_line);
            AESL_REG_TowerEta_14_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerEta_15_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerEta_15 := (others => '0'); 
    elsif(TowerEta_15_ap_vld = '1') then
        AESL_REG_TowerEta_15 := TowerEta_15;
        AESL_REG_TowerEta_15_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerEta_15 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerEta_15_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerEta_15_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerEta_15_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerEta_15_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerEta_15));
            writeline(fp, token_line);
            AESL_REG_TowerEta_15_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerEta_16_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerEta_16 := (others => '0'); 
    elsif(TowerEta_16_ap_vld = '1') then
        AESL_REG_TowerEta_16 := TowerEta_16;
        AESL_REG_TowerEta_16_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerEta_16 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerEta_16_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerEta_16_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerEta_16_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerEta_16_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerEta_16));
            writeline(fp, token_line);
            AESL_REG_TowerEta_16_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerEta_17_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerEta_17 := (others => '0'); 
    elsif(TowerEta_17_ap_vld = '1') then
        AESL_REG_TowerEta_17 := TowerEta_17;
        AESL_REG_TowerEta_17_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerEta_17 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerEta_17_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerEta_17_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerEta_17_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerEta_17_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerEta_17));
            writeline(fp, token_line);
            AESL_REG_TowerEta_17_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerEta_18_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerEta_18 := (others => '0'); 
    elsif(TowerEta_18_ap_vld = '1') then
        AESL_REG_TowerEta_18 := TowerEta_18;
        AESL_REG_TowerEta_18_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerEta_18 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerEta_18_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerEta_18_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerEta_18_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerEta_18_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerEta_18));
            writeline(fp, token_line);
            AESL_REG_TowerEta_18_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerEta_19_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerEta_19 := (others => '0'); 
    elsif(TowerEta_19_ap_vld = '1') then
        AESL_REG_TowerEta_19 := TowerEta_19;
        AESL_REG_TowerEta_19_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerEta_19 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerEta_19_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerEta_19_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerEta_19_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerEta_19_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerEta_19));
            writeline(fp, token_line);
            AESL_REG_TowerEta_19_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerEta_20_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerEta_20 := (others => '0'); 
    elsif(TowerEta_20_ap_vld = '1') then
        AESL_REG_TowerEta_20 := TowerEta_20;
        AESL_REG_TowerEta_20_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerEta_20 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerEta_20_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerEta_20_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerEta_20_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerEta_20_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerEta_20));
            writeline(fp, token_line);
            AESL_REG_TowerEta_20_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerEta_21_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerEta_21 := (others => '0'); 
    elsif(TowerEta_21_ap_vld = '1') then
        AESL_REG_TowerEta_21 := TowerEta_21;
        AESL_REG_TowerEta_21_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerEta_21 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerEta_21_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerEta_21_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerEta_21_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerEta_21_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerEta_21));
            writeline(fp, token_line);
            AESL_REG_TowerEta_21_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerEta_22_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerEta_22 := (others => '0'); 
    elsif(TowerEta_22_ap_vld = '1') then
        AESL_REG_TowerEta_22 := TowerEta_22;
        AESL_REG_TowerEta_22_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerEta_22 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerEta_22_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerEta_22_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerEta_22_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerEta_22_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerEta_22));
            writeline(fp, token_line);
            AESL_REG_TowerEta_22_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerEta_23_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerEta_23 := (others => '0'); 
    elsif(TowerEta_23_ap_vld = '1') then
        AESL_REG_TowerEta_23 := TowerEta_23;
        AESL_REG_TowerEta_23_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerEta_23 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerEta_23_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerEta_23_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerEta_23_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerEta_23_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerEta_23));
            writeline(fp, token_line);
            AESL_REG_TowerEta_23_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerEta_24_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerEta_24 := (others => '0'); 
    elsif(TowerEta_24_ap_vld = '1') then
        AESL_REG_TowerEta_24 := TowerEta_24;
        AESL_REG_TowerEta_24_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerEta_24 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerEta_24_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerEta_24_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerEta_24_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerEta_24_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerEta_24));
            writeline(fp, token_line);
            AESL_REG_TowerEta_24_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerEta_25_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerEta_25 := (others => '0'); 
    elsif(TowerEta_25_ap_vld = '1') then
        AESL_REG_TowerEta_25 := TowerEta_25;
        AESL_REG_TowerEta_25_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerEta_25 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerEta_25_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerEta_25_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerEta_25_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerEta_25_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerEta_25));
            writeline(fp, token_line);
            AESL_REG_TowerEta_25_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerEta_26_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerEta_26 := (others => '0'); 
    elsif(TowerEta_26_ap_vld = '1') then
        AESL_REG_TowerEta_26 := TowerEta_26;
        AESL_REG_TowerEta_26_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerEta_26 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerEta_26_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerEta_26_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerEta_26_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerEta_26_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerEta_26));
            writeline(fp, token_line);
            AESL_REG_TowerEta_26_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerEta_27_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerEta_27 := (others => '0'); 
    elsif(TowerEta_27_ap_vld = '1') then
        AESL_REG_TowerEta_27 := TowerEta_27;
        AESL_REG_TowerEta_27_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerEta_27 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerEta_27_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerEta_27_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerEta_27_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerEta_27_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerEta_27));
            writeline(fp, token_line);
            AESL_REG_TowerEta_27_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerEta_28_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerEta_28 := (others => '0'); 
    elsif(TowerEta_28_ap_vld = '1') then
        AESL_REG_TowerEta_28 := TowerEta_28;
        AESL_REG_TowerEta_28_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerEta_28 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerEta_28_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerEta_28_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerEta_28_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerEta_28_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerEta_28));
            writeline(fp, token_line);
            AESL_REG_TowerEta_28_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

gen_out_TowerEta_29_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
        AESL_REG_TowerEta_29 := (others => '0'); 
    elsif(TowerEta_29_ap_vld = '1') then
        AESL_REG_TowerEta_29 := TowerEta_29;
        AESL_REG_TowerEta_29_ap_vld := '1';
    end if;
  end if;
end process;

write_file_process_TowerEta_29 : process
    file      fp              :   TEXT;
    file      fp_size         :   TEXT;
    variable  fstatus         :   FILE_OPEN_STATUS;
    variable  token_line      :   LINE;
    variable  token           :   STRING(1 to 168);
    variable  str             :   STRING(1 to 40);
    variable  transaction_idx :   INTEGER;
    variable  TowerEta_29_count   :   INTEGER;
    variable  hls_stream_size :   INTEGER;
    variable  i               :   INTEGER;
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    wait until AESL_reset = '0';
    file_open(fstatus, fp, AUTOTB_TVOUT_TowerEta_29_out_wrapc, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_TVOUT_TowerEta_29_out_wrapc & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;
    write(token_line, string'("[[[runtime]]]"));
    writeline(fp, token_line);
    transaction_idx := 0;
    while (transaction_idx /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
	      while(AESL_done /= '1') loop
            wait until AESL_clock'event and AESL_clock = '1';
	      end loop;
        wait for 0.4 ns;
        write(token_line, string'("[[transaction]]    ") & integer'image(transaction_idx));
        writeline(fp, token_line);
        if(AESL_REG_TowerEta_29_ap_vld = '1')  then
            write(token_line, "0x" & esl_conv_string_hex(AESL_REG_TowerEta_29));
            writeline(fp, token_line);
            AESL_REG_TowerEta_29_ap_vld := '0';
        end if;
        transaction_idx := transaction_idx + 1;
        write(token_line, string'("[[/transaction]]"));
        writeline(fp, token_line);
    end loop;
    write(token_line, string'("[[[/runtime]]]"));
    writeline(fp, token_line);
    file_close(fp);
    wait;
end process;

generate_ready_cnt_proc : process(ready_initial, AESL_clock)
begin
    if(AESL_clock'event and AESL_clock = '0') then
        if(ready_initial = '1') then
            ready_cnt <= conv_std_logic_vector(1, 32);
        end if;
    elsif(AESL_clock'event and AESL_clock = '1') then
        if(ready_cnt /= AUTOTB_TRANSACTION_NUM) then
            if(AESL_ready = '1') then
                ready_cnt <= ready_cnt + 1;
            end if;
        end if;
    end if;
end process;

generate_done_cnt_proc : process(AESL_reset, AESL_clock)
begin
    if(AESL_reset = '1') then
        done_cnt <= (others => '0');
    elsif(AESL_clock'event and AESL_clock = '1') then
        if(done_cnt /= AUTOTB_TRANSACTION_NUM) then
            if(AESL_done = '1') then
                done_cnt <= done_cnt + 1;
            end if;
        end if;
    end if;
end process;

generate_sim_done_proc    :   process
begin
    while(done_cnt /= AUTOTB_TRANSACTION_NUM) loop
        wait until AESL_clock'event and AESL_clock = '1';
    end loop;
        wait until AESL_clock'event and AESL_clock = '1';
        wait until AESL_clock'event and AESL_clock = '1';
        wait until AESL_clock'event and AESL_clock = '1';
    assert false report "simulation done!" severity note;
    assert false report "NORMAL EXIT (note: failure is to force the simulator to stop)" severity failure;
    wait;
end process;

gen_clock_proc :   process
begin
    AESL_clock <= '0';
    while(true) loop
        wait for AUTOTB_CLOCK_PERIOD_DIV2;
        AESL_clock <= not AESL_clock;
    end loop;
    wait;
end process;

gen_reset_proc : process
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
    rst <= '1';
    wait for 100 ns;
    for i in 1 to 3 loop
        wait until AESL_clock'event and AESL_clock = '1';
    end loop;
    rst <= '0';
    wait;
end process;

gen_start_proc : process
    variable  rand            :   T_RANDINT     := init_rand(0);
    variable  rint            :   INTEGER;
begin
  start <= '0';
  ce <= '1';
    wait until AESL_reset = '0';
  wait until (AESL_clock'event and AESL_clock = '1');
  start <= '1';
  while(ready_cnt /= AUTOTB_TRANSACTION_NUM + 1) loop
      wait until (AESL_clock'event and AESL_clock = '1');
      if(AESL_ready = '1') then
          start <= '0';
          start <= '1';
      end if;
  end loop;
  start <= '0';
  wait;
end process;


gen_continue_proc : process(AESL_done)
begin
    continue <= AESL_done;
end process;

gen_AESL_ready_delay_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
          AESL_ready_delay <= '0';
      else
          AESL_ready_delay <= AESL_ready;
      end if;
  end if;
end process;

gen_ready_initial_proc : process
begin
    ready_initial <= '0';
    wait until AESL_start = '1';
    ready_initial <= '1';
    wait until AESL_clock'event and AESL_clock = '1';
    ready_initial <= '0';
    wait;
end process;

ready_last_n_proc : process
begin
  ready_last_n <= '1';
  while(ready_cnt /= AUTOTB_TRANSACTION_NUM) loop
    wait until AESL_clock'event and AESL_clock = '1';
  end loop;
  ready_last_n <= '0';
  wait;
end process;

gen_ready_delay_n_last_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
          ready_delay_last_n <= '0';
      else
          ready_delay_last_n <= ready_last_n;
      end if;
  end if;
end process;

ready <= (ready_initial or AESL_ready_delay);
ready_wire <= ready_initial or AESL_ready_delay;
done_delay_last_n <= '0' when done_cnt = AUTOTB_TRANSACTION_NUM else '1';

gen_done_delay_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
          AESL_done_delay <= '0';
          AESL_done_delay2 <= '0';
      else
          AESL_done_delay <= AESL_done and done_delay_last_n;
          AESL_done_delay2 <= AESL_done_delay;
      end if;
  end if;
end process;

gen_interface_done : process(ready, AESL_ready_delay, AESL_done_delay)
begin
    if(ready_cnt > 0 and ready_cnt < AUTOTB_TRANSACTION_NUM) then
        interface_done <= AESL_ready_delay;
    elsif(ready_cnt = AUTOTB_TRANSACTION_NUM) then
        interface_done <= AESL_done_delay;
    else
        interface_done <= '0';
    end if;
end process;

gen_clock_counter_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '0') then
    if(AESL_reset = '1') then
        AESL_clk_counter := 0;
    else
        AESL_clk_counter := AESL_clk_counter + 1;
    end if;
  end if;
end process;

gen_mLatcnterout_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
          AESL_mLatCnterOut_addr := 0;
          AESL_mLatCnterOut(AESL_mLatCnterOut_addr) := AESL_clk_counter + 1 ;
          reported_stuck_cnt := 0;
      else
          if (AESL_done = '1' and AESL_mLatCnterOut_addr < AUTOTB_TRANSACTION_NUM + 1) then
              AESL_mLatCnterOut(AESL_mLatCnterOut_addr) := AESL_clk_counter;
              AESL_mLatCnterOut_addr := AESL_mLatCnterOut_addr + 1;
              reported_stuck <= '0';
          elsif (reported_stuck = '0' and reported_stuck_cnt < 4) then
              if ( AESL_mLatCnterIn_addr > AESL_mLatCnterOut_addr ) then
                  if ( AESL_clk_counter - AESL_mLatCnterIn(AESL_mLatCnterOut_addr) > 10000 and AESL_clk_counter - AESL_mLatCnterIn(AESL_mLatCnterOut_addr) > 10 * 10 ) then
                      report "WARNING: The latency is much larger than expected. Simulation may stuck.";
                      reported_stuck <= '1';
                      reported_stuck_cnt := reported_stuck_cnt + 1;
                  end if;
              end if;
          end if;
      end if;
  end if;
end process;

gen_mLatcnterin_proc : process(AESL_clock)
begin
  if (AESL_clock'event and AESL_clock = '1') then
    if(AESL_reset = '1') then
          AESL_mLatCnterIn_addr := 0;
      else
    if (AESL_start = '1' and AESL_mLatCnterIn_addr = 0) then
        AESL_mLatCnterIn(AESL_mLatCnterIn_addr) := AESL_clk_counter;
        AESL_mLatCnterIn_addr := AESL_mLatCnterIn_addr + 1;
    elsif (AESL_ready = '1' and AESL_mLatCnterIn_addr < AUTOTB_TRANSACTION_NUM + 1 ) then
        AESL_mLatCnterIn(AESL_mLatCnterIn_addr) := AESL_clk_counter;
        AESL_mLatCnterIn_addr := AESL_mLatCnterIn_addr + 1;
    end if;
      end if;
  end if;
end process;

gen_performance_check_proc : process
    variable transaction_counter : INTEGER;
    variable i : INTEGER;
    file     fp :   TEXT;
    variable    fstatus         :   FILE_OPEN_STATUS;
    variable    token_line      :   LINE;
    variable    token           :   STRING(1 to 1024);

    variable latthistime : INTEGER;
    variable lattotal : INTEGER;
    variable latmax : INTEGER;
    variable latmin : INTEGER;


    variable thrthistime : INTEGER;
    variable thrtotal : INTEGER;
    variable thrmax : INTEGER;
    variable thrmin : INTEGER;

    variable lataver : INTEGER;
    variable thraver : INTEGER;
    type latency_record is array(0 to AUTOTB_TRANSACTION_NUM + 1) of INTEGER;
    variable lat_array : latency_record;
    variable thr_array : latency_record;

begin
    i := 0;
    lattotal  := 0;
    latmax    := 0;
    latmin    := 16#7fffffff#;
    lataver   := 0;

    thrtotal  := 0;
    thrmax    := 0;
    thrmin    := 16#7fffffff#;
    thraver   := 0;

    wait until (AESL_clock'event and AESL_clock = '1');
    wait until (AESL_reset = '0'); 
    while (done_cnt /= AUTOTB_TRANSACTION_NUM) loop
        wait until (AESL_clock'event and AESL_clock = '1');
    end loop;
  wait for 0.001 ns;

    for i in 0 to AUTOTB_TRANSACTION_NUM - 1 loop
        latthistime := AESL_mLatCnterOut(i) - AESL_mLatCnterIn(i);
        lat_array(i) := latthistime;
        if (latthistime > latmax) then
            latmax := latthistime; 
        end if;
        if (latthistime < latmin) then
            latmin := latthistime;
        end if;
		lattotal := lattotal + latthistime;
		if (AUTOTB_TRANSACTION_NUM = 1) then
			thrthistime := latthistime;
		else
			thrthistime := AESL_mLatCnterIn(i + 1) - AESL_mLatCnterIn(i);
		end if;
     thr_array(i) := thrthistime;
		if (thrthistime > thrmax) then
		    thrmax := thrthistime;
      end if;
		if (thrthistime < thrmin) then
	        thrmin := thrthistime;
      end if;
		thrtotal := thrtotal + thrthistime;
	end loop;
	lataver := lattotal / AUTOTB_TRANSACTION_NUM;
	thraver := thrtotal / AUTOTB_TRANSACTION_NUM;

    file_open(fstatus, fp, AUTOTB_LAT_RESULT_FILE, WRITE_MODE);
    if (fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_LAT_RESULT_FILE & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;

    if (AUTOTB_TRANSACTION_NUM = 1) then
        thrmax  := 0;
        thrmin  := 0;
        thraver := 0;
        write(token_line, "$MAX_LATENCY = " & '"' & integer'image(latmax) & '"');
        writeline(fp, token_line);
        write(token_line, "$MIN_LATENCY = " & '"' & integer'image(latmin) & '"');
        writeline(fp, token_line);
        write(token_line, "$AVER_LATENCY = " & '"' & integer'image(lataver) & '"');
        writeline(fp, token_line);
        write(token_line, "$MAX_THROUGHPUT = " & '"' & integer'image(thrmax) & '"');
        writeline(fp, token_line);
        write(token_line, "$MIN_THROUGHPUT = " & '"' & integer'image(thrmin) & '"');
        writeline(fp, token_line);
        write(token_line, "$AVER_THROUGHPUT = " & '"' & integer'image(thraver) & '"');
        writeline(fp, token_line);
    else
        write(token_line, "$MAX_LATENCY = " & '"' & integer'image(latmax) & '"');
        writeline(fp, token_line);
        write(token_line, "$MIN_LATENCY = " & '"' & integer'image(latmin) & '"');
        writeline(fp, token_line);
        write(token_line, "$AVER_LATENCY = " & '"' & integer'image(lataver) & '"');
        writeline(fp, token_line);
        write(token_line, "$MAX_THROUGHPUT = " & '"' & integer'image(thrmax) & '"');
        writeline(fp, token_line);
        write(token_line, "$MIN_THROUGHPUT = " & '"' & integer'image(thrmin) & '"');
        writeline(fp, token_line);
        write(token_line, "$AVER_THROUGHPUT = " & '"' & integer'image(thraver) & '"');
        writeline(fp, token_line);
    end if;

    file_close(fp);

    file_open(fstatus, fp, AUTOTB_PER_RESULT_TRANS_FILE, WRITE_MODE);
    if(fstatus /= OPEN_OK) then
        assert false report "Open file " & AUTOTB_PER_RESULT_TRANS_FILE & " failed!!!" severity note;
        assert false report "ERROR: Simulation using HLS TB failed." severity failure;
    end if;

    write(token_line,string'("                            latency            interval"));
    writeline(fp, token_line);
    if (AUTOTB_TRANSACTION_NUM = 1) then
        i := 0;
        thr_array(i) := 0;
        write(token_line,"transaction        " & integer'image(i) & "            " & integer'image(lat_array(i) ) & "            " & integer'image(thr_array(i) ) );
        writeline(fp, token_line);
    else
        for i in 0 to AESL_mLatCnterOut_addr - 1 loop
            write(token_line,"transaction        " & integer'image(i) & "            " & integer'image(lat_array(i) ) & "            " & integer'image(thr_array(i) ) );
            writeline(fp, token_line);
        end loop;
    end if;
    file_close(fp);
    wait;
end process;

end behav;
