// ==============================================================
// File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
// Version: 2016.4
// Copyright (C) 1986-2016 Xilinx, Inc. All Rights Reserved.
// ==============================================================

#include <systemc>
#include <iostream>
#include <cstdlib>
#include <cstddef>
#include <stdint.h>
#include "SysCFileHandler.h"
#include "ap_int.h"
#include "ap_fixed.h"
#include <complex>
#include <stdbool.h>
#include "autopilot_cbe.h"
#include "ap_stream.h"
#include "hls_stream.h"
#include "hls_half.h"
#include "hls_signal_handler.h"

using namespace std;
using namespace sc_core;
using namespace sc_dt;


// [dump_struct_tree [build_nameSpaceTree] dumpedStructList] ---------->


// [dump_enumeration [get_enumeration_list]] ---------->


// wrapc file define: "towerET_0_0"
#define AUTOTB_TVIN_towerET_0_0  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_0_0.dat"
// wrapc file define: "towerET_0_1"
#define AUTOTB_TVIN_towerET_0_1  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_0_1.dat"
// wrapc file define: "towerET_0_2"
#define AUTOTB_TVIN_towerET_0_2  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_0_2.dat"
// wrapc file define: "towerET_0_3"
#define AUTOTB_TVIN_towerET_0_3  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_0_3.dat"
// wrapc file define: "towerET_1_0"
#define AUTOTB_TVIN_towerET_1_0  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_1_0.dat"
// wrapc file define: "towerET_1_1"
#define AUTOTB_TVIN_towerET_1_1  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_1_1.dat"
// wrapc file define: "towerET_1_2"
#define AUTOTB_TVIN_towerET_1_2  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_1_2.dat"
// wrapc file define: "towerET_1_3"
#define AUTOTB_TVIN_towerET_1_3  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_1_3.dat"
// wrapc file define: "towerET_2_0"
#define AUTOTB_TVIN_towerET_2_0  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_2_0.dat"
// wrapc file define: "towerET_2_1"
#define AUTOTB_TVIN_towerET_2_1  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_2_1.dat"
// wrapc file define: "towerET_2_2"
#define AUTOTB_TVIN_towerET_2_2  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_2_2.dat"
// wrapc file define: "towerET_2_3"
#define AUTOTB_TVIN_towerET_2_3  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_2_3.dat"
// wrapc file define: "towerET_3_0"
#define AUTOTB_TVIN_towerET_3_0  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_3_0.dat"
// wrapc file define: "towerET_3_1"
#define AUTOTB_TVIN_towerET_3_1  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_3_1.dat"
// wrapc file define: "towerET_3_2"
#define AUTOTB_TVIN_towerET_3_2  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_3_2.dat"
// wrapc file define: "towerET_3_3"
#define AUTOTB_TVIN_towerET_3_3  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_3_3.dat"
// wrapc file define: "towerET_4_0"
#define AUTOTB_TVIN_towerET_4_0  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_4_0.dat"
// wrapc file define: "towerET_4_1"
#define AUTOTB_TVIN_towerET_4_1  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_4_1.dat"
// wrapc file define: "towerET_4_2"
#define AUTOTB_TVIN_towerET_4_2  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_4_2.dat"
// wrapc file define: "towerET_4_3"
#define AUTOTB_TVIN_towerET_4_3  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_4_3.dat"
// wrapc file define: "towerET_5_0"
#define AUTOTB_TVIN_towerET_5_0  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_5_0.dat"
// wrapc file define: "towerET_5_1"
#define AUTOTB_TVIN_towerET_5_1  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_5_1.dat"
// wrapc file define: "towerET_5_2"
#define AUTOTB_TVIN_towerET_5_2  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_5_2.dat"
// wrapc file define: "towerET_5_3"
#define AUTOTB_TVIN_towerET_5_3  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_5_3.dat"
// wrapc file define: "towerET_6_0"
#define AUTOTB_TVIN_towerET_6_0  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_6_0.dat"
// wrapc file define: "towerET_6_1"
#define AUTOTB_TVIN_towerET_6_1  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_6_1.dat"
// wrapc file define: "towerET_6_2"
#define AUTOTB_TVIN_towerET_6_2  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_6_2.dat"
// wrapc file define: "towerET_6_3"
#define AUTOTB_TVIN_towerET_6_3  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_6_3.dat"
// wrapc file define: "towerET_7_0"
#define AUTOTB_TVIN_towerET_7_0  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_7_0.dat"
// wrapc file define: "towerET_7_1"
#define AUTOTB_TVIN_towerET_7_1  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_7_1.dat"
// wrapc file define: "towerET_7_2"
#define AUTOTB_TVIN_towerET_7_2  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_7_2.dat"
// wrapc file define: "towerET_7_3"
#define AUTOTB_TVIN_towerET_7_3  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_7_3.dat"
// wrapc file define: "towerET_8_0"
#define AUTOTB_TVIN_towerET_8_0  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_8_0.dat"
// wrapc file define: "towerET_8_1"
#define AUTOTB_TVIN_towerET_8_1  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_8_1.dat"
// wrapc file define: "towerET_8_2"
#define AUTOTB_TVIN_towerET_8_2  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_8_2.dat"
// wrapc file define: "towerET_8_3"
#define AUTOTB_TVIN_towerET_8_3  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_8_3.dat"
// wrapc file define: "towerET_9_0"
#define AUTOTB_TVIN_towerET_9_0  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_9_0.dat"
// wrapc file define: "towerET_9_1"
#define AUTOTB_TVIN_towerET_9_1  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_9_1.dat"
// wrapc file define: "towerET_9_2"
#define AUTOTB_TVIN_towerET_9_2  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_9_2.dat"
// wrapc file define: "towerET_9_3"
#define AUTOTB_TVIN_towerET_9_3  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_9_3.dat"
// wrapc file define: "towerET_10_0"
#define AUTOTB_TVIN_towerET_10_0  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_10_0.dat"
// wrapc file define: "towerET_10_1"
#define AUTOTB_TVIN_towerET_10_1  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_10_1.dat"
// wrapc file define: "towerET_10_2"
#define AUTOTB_TVIN_towerET_10_2  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_10_2.dat"
// wrapc file define: "towerET_10_3"
#define AUTOTB_TVIN_towerET_10_3  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_10_3.dat"
// wrapc file define: "towerET_11_0"
#define AUTOTB_TVIN_towerET_11_0  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_11_0.dat"
// wrapc file define: "towerET_11_1"
#define AUTOTB_TVIN_towerET_11_1  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_11_1.dat"
// wrapc file define: "towerET_11_2"
#define AUTOTB_TVIN_towerET_11_2  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_11_2.dat"
// wrapc file define: "towerET_11_3"
#define AUTOTB_TVIN_towerET_11_3  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_11_3.dat"
// wrapc file define: "towerET_12_0"
#define AUTOTB_TVIN_towerET_12_0  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_12_0.dat"
// wrapc file define: "towerET_12_1"
#define AUTOTB_TVIN_towerET_12_1  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_12_1.dat"
// wrapc file define: "towerET_12_2"
#define AUTOTB_TVIN_towerET_12_2  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_12_2.dat"
// wrapc file define: "towerET_12_3"
#define AUTOTB_TVIN_towerET_12_3  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_12_3.dat"
// wrapc file define: "towerET_13_0"
#define AUTOTB_TVIN_towerET_13_0  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_13_0.dat"
// wrapc file define: "towerET_13_1"
#define AUTOTB_TVIN_towerET_13_1  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_13_1.dat"
// wrapc file define: "towerET_13_2"
#define AUTOTB_TVIN_towerET_13_2  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_13_2.dat"
// wrapc file define: "towerET_13_3"
#define AUTOTB_TVIN_towerET_13_3  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_13_3.dat"
// wrapc file define: "towerET_14_0"
#define AUTOTB_TVIN_towerET_14_0  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_14_0.dat"
// wrapc file define: "towerET_14_1"
#define AUTOTB_TVIN_towerET_14_1  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_14_1.dat"
// wrapc file define: "towerET_14_2"
#define AUTOTB_TVIN_towerET_14_2  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_14_2.dat"
// wrapc file define: "towerET_14_3"
#define AUTOTB_TVIN_towerET_14_3  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_14_3.dat"
// wrapc file define: "towerET_15_0"
#define AUTOTB_TVIN_towerET_15_0  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_15_0.dat"
// wrapc file define: "towerET_15_1"
#define AUTOTB_TVIN_towerET_15_1  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_15_1.dat"
// wrapc file define: "towerET_15_2"
#define AUTOTB_TVIN_towerET_15_2  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_15_2.dat"
// wrapc file define: "towerET_15_3"
#define AUTOTB_TVIN_towerET_15_3  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_15_3.dat"
// wrapc file define: "towerET_16_0"
#define AUTOTB_TVIN_towerET_16_0  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_16_0.dat"
// wrapc file define: "towerET_16_1"
#define AUTOTB_TVIN_towerET_16_1  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_16_1.dat"
// wrapc file define: "towerET_16_2"
#define AUTOTB_TVIN_towerET_16_2  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_16_2.dat"
// wrapc file define: "towerET_16_3"
#define AUTOTB_TVIN_towerET_16_3  "../tv/cdatafile/c.TowerPeaks.autotvin_towerET_16_3.dat"
// wrapc file define: "TowerPhi_0"
#define AUTOTB_TVOUT_TowerPhi_0  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_0.dat"
// wrapc file define: "TowerPhi_1"
#define AUTOTB_TVOUT_TowerPhi_1  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_1.dat"
// wrapc file define: "TowerPhi_2"
#define AUTOTB_TVOUT_TowerPhi_2  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_2.dat"
// wrapc file define: "TowerPhi_3"
#define AUTOTB_TVOUT_TowerPhi_3  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_3.dat"
// wrapc file define: "TowerPhi_4"
#define AUTOTB_TVOUT_TowerPhi_4  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_4.dat"
// wrapc file define: "TowerPhi_5"
#define AUTOTB_TVOUT_TowerPhi_5  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_5.dat"
// wrapc file define: "TowerPhi_6"
#define AUTOTB_TVOUT_TowerPhi_6  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_6.dat"
// wrapc file define: "TowerPhi_7"
#define AUTOTB_TVOUT_TowerPhi_7  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_7.dat"
// wrapc file define: "TowerPhi_8"
#define AUTOTB_TVOUT_TowerPhi_8  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_8.dat"
// wrapc file define: "TowerPhi_9"
#define AUTOTB_TVOUT_TowerPhi_9  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_9.dat"
// wrapc file define: "TowerPhi_10"
#define AUTOTB_TVOUT_TowerPhi_10  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_10.dat"
// wrapc file define: "TowerPhi_11"
#define AUTOTB_TVOUT_TowerPhi_11  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_11.dat"
// wrapc file define: "TowerPhi_12"
#define AUTOTB_TVOUT_TowerPhi_12  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_12.dat"
// wrapc file define: "TowerPhi_13"
#define AUTOTB_TVOUT_TowerPhi_13  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_13.dat"
// wrapc file define: "TowerPhi_14"
#define AUTOTB_TVOUT_TowerPhi_14  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_14.dat"
// wrapc file define: "TowerPhi_15"
#define AUTOTB_TVOUT_TowerPhi_15  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_15.dat"
// wrapc file define: "TowerPhi_16"
#define AUTOTB_TVOUT_TowerPhi_16  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_16.dat"
// wrapc file define: "TowerPhi_17"
#define AUTOTB_TVOUT_TowerPhi_17  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_17.dat"
// wrapc file define: "TowerPhi_18"
#define AUTOTB_TVOUT_TowerPhi_18  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_18.dat"
// wrapc file define: "TowerPhi_19"
#define AUTOTB_TVOUT_TowerPhi_19  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_19.dat"
// wrapc file define: "TowerPhi_20"
#define AUTOTB_TVOUT_TowerPhi_20  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_20.dat"
// wrapc file define: "TowerPhi_21"
#define AUTOTB_TVOUT_TowerPhi_21  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_21.dat"
// wrapc file define: "TowerPhi_22"
#define AUTOTB_TVOUT_TowerPhi_22  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_22.dat"
// wrapc file define: "TowerPhi_23"
#define AUTOTB_TVOUT_TowerPhi_23  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_23.dat"
// wrapc file define: "TowerPhi_24"
#define AUTOTB_TVOUT_TowerPhi_24  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_24.dat"
// wrapc file define: "TowerPhi_25"
#define AUTOTB_TVOUT_TowerPhi_25  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_25.dat"
// wrapc file define: "TowerPhi_26"
#define AUTOTB_TVOUT_TowerPhi_26  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_26.dat"
// wrapc file define: "TowerPhi_27"
#define AUTOTB_TVOUT_TowerPhi_27  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_27.dat"
// wrapc file define: "TowerPhi_28"
#define AUTOTB_TVOUT_TowerPhi_28  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_28.dat"
// wrapc file define: "TowerPhi_29"
#define AUTOTB_TVOUT_TowerPhi_29  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerPhi_29.dat"
// wrapc file define: "TowerEta_0"
#define AUTOTB_TVOUT_TowerEta_0  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_0.dat"
// wrapc file define: "TowerEta_1"
#define AUTOTB_TVOUT_TowerEta_1  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_1.dat"
// wrapc file define: "TowerEta_2"
#define AUTOTB_TVOUT_TowerEta_2  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_2.dat"
// wrapc file define: "TowerEta_3"
#define AUTOTB_TVOUT_TowerEta_3  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_3.dat"
// wrapc file define: "TowerEta_4"
#define AUTOTB_TVOUT_TowerEta_4  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_4.dat"
// wrapc file define: "TowerEta_5"
#define AUTOTB_TVOUT_TowerEta_5  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_5.dat"
// wrapc file define: "TowerEta_6"
#define AUTOTB_TVOUT_TowerEta_6  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_6.dat"
// wrapc file define: "TowerEta_7"
#define AUTOTB_TVOUT_TowerEta_7  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_7.dat"
// wrapc file define: "TowerEta_8"
#define AUTOTB_TVOUT_TowerEta_8  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_8.dat"
// wrapc file define: "TowerEta_9"
#define AUTOTB_TVOUT_TowerEta_9  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_9.dat"
// wrapc file define: "TowerEta_10"
#define AUTOTB_TVOUT_TowerEta_10  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_10.dat"
// wrapc file define: "TowerEta_11"
#define AUTOTB_TVOUT_TowerEta_11  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_11.dat"
// wrapc file define: "TowerEta_12"
#define AUTOTB_TVOUT_TowerEta_12  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_12.dat"
// wrapc file define: "TowerEta_13"
#define AUTOTB_TVOUT_TowerEta_13  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_13.dat"
// wrapc file define: "TowerEta_14"
#define AUTOTB_TVOUT_TowerEta_14  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_14.dat"
// wrapc file define: "TowerEta_15"
#define AUTOTB_TVOUT_TowerEta_15  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_15.dat"
// wrapc file define: "TowerEta_16"
#define AUTOTB_TVOUT_TowerEta_16  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_16.dat"
// wrapc file define: "TowerEta_17"
#define AUTOTB_TVOUT_TowerEta_17  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_17.dat"
// wrapc file define: "TowerEta_18"
#define AUTOTB_TVOUT_TowerEta_18  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_18.dat"
// wrapc file define: "TowerEta_19"
#define AUTOTB_TVOUT_TowerEta_19  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_19.dat"
// wrapc file define: "TowerEta_20"
#define AUTOTB_TVOUT_TowerEta_20  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_20.dat"
// wrapc file define: "TowerEta_21"
#define AUTOTB_TVOUT_TowerEta_21  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_21.dat"
// wrapc file define: "TowerEta_22"
#define AUTOTB_TVOUT_TowerEta_22  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_22.dat"
// wrapc file define: "TowerEta_23"
#define AUTOTB_TVOUT_TowerEta_23  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_23.dat"
// wrapc file define: "TowerEta_24"
#define AUTOTB_TVOUT_TowerEta_24  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_24.dat"
// wrapc file define: "TowerEta_25"
#define AUTOTB_TVOUT_TowerEta_25  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_25.dat"
// wrapc file define: "TowerEta_26"
#define AUTOTB_TVOUT_TowerEta_26  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_26.dat"
// wrapc file define: "TowerEta_27"
#define AUTOTB_TVOUT_TowerEta_27  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_27.dat"
// wrapc file define: "TowerEta_28"
#define AUTOTB_TVOUT_TowerEta_28  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_28.dat"
// wrapc file define: "TowerEta_29"
#define AUTOTB_TVOUT_TowerEta_29  "../tv/cdatafile/c.TowerPeaks.autotvout_TowerEta_29.dat"

#define INTER_TCL  "../tv/cdatafile/ref.tcl"

// tvout file define: "TowerPhi_0"
#define AUTOTB_TVOUT_PC_TowerPhi_0  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_0.dat"
// tvout file define: "TowerPhi_1"
#define AUTOTB_TVOUT_PC_TowerPhi_1  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_1.dat"
// tvout file define: "TowerPhi_2"
#define AUTOTB_TVOUT_PC_TowerPhi_2  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_2.dat"
// tvout file define: "TowerPhi_3"
#define AUTOTB_TVOUT_PC_TowerPhi_3  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_3.dat"
// tvout file define: "TowerPhi_4"
#define AUTOTB_TVOUT_PC_TowerPhi_4  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_4.dat"
// tvout file define: "TowerPhi_5"
#define AUTOTB_TVOUT_PC_TowerPhi_5  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_5.dat"
// tvout file define: "TowerPhi_6"
#define AUTOTB_TVOUT_PC_TowerPhi_6  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_6.dat"
// tvout file define: "TowerPhi_7"
#define AUTOTB_TVOUT_PC_TowerPhi_7  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_7.dat"
// tvout file define: "TowerPhi_8"
#define AUTOTB_TVOUT_PC_TowerPhi_8  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_8.dat"
// tvout file define: "TowerPhi_9"
#define AUTOTB_TVOUT_PC_TowerPhi_9  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_9.dat"
// tvout file define: "TowerPhi_10"
#define AUTOTB_TVOUT_PC_TowerPhi_10  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_10.dat"
// tvout file define: "TowerPhi_11"
#define AUTOTB_TVOUT_PC_TowerPhi_11  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_11.dat"
// tvout file define: "TowerPhi_12"
#define AUTOTB_TVOUT_PC_TowerPhi_12  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_12.dat"
// tvout file define: "TowerPhi_13"
#define AUTOTB_TVOUT_PC_TowerPhi_13  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_13.dat"
// tvout file define: "TowerPhi_14"
#define AUTOTB_TVOUT_PC_TowerPhi_14  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_14.dat"
// tvout file define: "TowerPhi_15"
#define AUTOTB_TVOUT_PC_TowerPhi_15  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_15.dat"
// tvout file define: "TowerPhi_16"
#define AUTOTB_TVOUT_PC_TowerPhi_16  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_16.dat"
// tvout file define: "TowerPhi_17"
#define AUTOTB_TVOUT_PC_TowerPhi_17  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_17.dat"
// tvout file define: "TowerPhi_18"
#define AUTOTB_TVOUT_PC_TowerPhi_18  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_18.dat"
// tvout file define: "TowerPhi_19"
#define AUTOTB_TVOUT_PC_TowerPhi_19  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_19.dat"
// tvout file define: "TowerPhi_20"
#define AUTOTB_TVOUT_PC_TowerPhi_20  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_20.dat"
// tvout file define: "TowerPhi_21"
#define AUTOTB_TVOUT_PC_TowerPhi_21  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_21.dat"
// tvout file define: "TowerPhi_22"
#define AUTOTB_TVOUT_PC_TowerPhi_22  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_22.dat"
// tvout file define: "TowerPhi_23"
#define AUTOTB_TVOUT_PC_TowerPhi_23  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_23.dat"
// tvout file define: "TowerPhi_24"
#define AUTOTB_TVOUT_PC_TowerPhi_24  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_24.dat"
// tvout file define: "TowerPhi_25"
#define AUTOTB_TVOUT_PC_TowerPhi_25  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_25.dat"
// tvout file define: "TowerPhi_26"
#define AUTOTB_TVOUT_PC_TowerPhi_26  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_26.dat"
// tvout file define: "TowerPhi_27"
#define AUTOTB_TVOUT_PC_TowerPhi_27  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_27.dat"
// tvout file define: "TowerPhi_28"
#define AUTOTB_TVOUT_PC_TowerPhi_28  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_28.dat"
// tvout file define: "TowerPhi_29"
#define AUTOTB_TVOUT_PC_TowerPhi_29  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerPhi_29.dat"
// tvout file define: "TowerEta_0"
#define AUTOTB_TVOUT_PC_TowerEta_0  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_0.dat"
// tvout file define: "TowerEta_1"
#define AUTOTB_TVOUT_PC_TowerEta_1  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_1.dat"
// tvout file define: "TowerEta_2"
#define AUTOTB_TVOUT_PC_TowerEta_2  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_2.dat"
// tvout file define: "TowerEta_3"
#define AUTOTB_TVOUT_PC_TowerEta_3  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_3.dat"
// tvout file define: "TowerEta_4"
#define AUTOTB_TVOUT_PC_TowerEta_4  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_4.dat"
// tvout file define: "TowerEta_5"
#define AUTOTB_TVOUT_PC_TowerEta_5  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_5.dat"
// tvout file define: "TowerEta_6"
#define AUTOTB_TVOUT_PC_TowerEta_6  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_6.dat"
// tvout file define: "TowerEta_7"
#define AUTOTB_TVOUT_PC_TowerEta_7  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_7.dat"
// tvout file define: "TowerEta_8"
#define AUTOTB_TVOUT_PC_TowerEta_8  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_8.dat"
// tvout file define: "TowerEta_9"
#define AUTOTB_TVOUT_PC_TowerEta_9  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_9.dat"
// tvout file define: "TowerEta_10"
#define AUTOTB_TVOUT_PC_TowerEta_10  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_10.dat"
// tvout file define: "TowerEta_11"
#define AUTOTB_TVOUT_PC_TowerEta_11  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_11.dat"
// tvout file define: "TowerEta_12"
#define AUTOTB_TVOUT_PC_TowerEta_12  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_12.dat"
// tvout file define: "TowerEta_13"
#define AUTOTB_TVOUT_PC_TowerEta_13  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_13.dat"
// tvout file define: "TowerEta_14"
#define AUTOTB_TVOUT_PC_TowerEta_14  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_14.dat"
// tvout file define: "TowerEta_15"
#define AUTOTB_TVOUT_PC_TowerEta_15  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_15.dat"
// tvout file define: "TowerEta_16"
#define AUTOTB_TVOUT_PC_TowerEta_16  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_16.dat"
// tvout file define: "TowerEta_17"
#define AUTOTB_TVOUT_PC_TowerEta_17  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_17.dat"
// tvout file define: "TowerEta_18"
#define AUTOTB_TVOUT_PC_TowerEta_18  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_18.dat"
// tvout file define: "TowerEta_19"
#define AUTOTB_TVOUT_PC_TowerEta_19  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_19.dat"
// tvout file define: "TowerEta_20"
#define AUTOTB_TVOUT_PC_TowerEta_20  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_20.dat"
// tvout file define: "TowerEta_21"
#define AUTOTB_TVOUT_PC_TowerEta_21  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_21.dat"
// tvout file define: "TowerEta_22"
#define AUTOTB_TVOUT_PC_TowerEta_22  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_22.dat"
// tvout file define: "TowerEta_23"
#define AUTOTB_TVOUT_PC_TowerEta_23  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_23.dat"
// tvout file define: "TowerEta_24"
#define AUTOTB_TVOUT_PC_TowerEta_24  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_24.dat"
// tvout file define: "TowerEta_25"
#define AUTOTB_TVOUT_PC_TowerEta_25  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_25.dat"
// tvout file define: "TowerEta_26"
#define AUTOTB_TVOUT_PC_TowerEta_26  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_26.dat"
// tvout file define: "TowerEta_27"
#define AUTOTB_TVOUT_PC_TowerEta_27  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_27.dat"
// tvout file define: "TowerEta_28"
#define AUTOTB_TVOUT_PC_TowerEta_28  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_28.dat"
// tvout file define: "TowerEta_29"
#define AUTOTB_TVOUT_PC_TowerEta_29  "../tv/rtldatafile/rtl.TowerPeaks.autotvout_TowerEta_29.dat"

class INTER_TCL_FILE {
	public:
		INTER_TCL_FILE(const char* name) {
			mName = name;
			towerET_0_0_depth = 0;
			towerET_0_1_depth = 0;
			towerET_0_2_depth = 0;
			towerET_0_3_depth = 0;
			towerET_1_0_depth = 0;
			towerET_1_1_depth = 0;
			towerET_1_2_depth = 0;
			towerET_1_3_depth = 0;
			towerET_2_0_depth = 0;
			towerET_2_1_depth = 0;
			towerET_2_2_depth = 0;
			towerET_2_3_depth = 0;
			towerET_3_0_depth = 0;
			towerET_3_1_depth = 0;
			towerET_3_2_depth = 0;
			towerET_3_3_depth = 0;
			towerET_4_0_depth = 0;
			towerET_4_1_depth = 0;
			towerET_4_2_depth = 0;
			towerET_4_3_depth = 0;
			towerET_5_0_depth = 0;
			towerET_5_1_depth = 0;
			towerET_5_2_depth = 0;
			towerET_5_3_depth = 0;
			towerET_6_0_depth = 0;
			towerET_6_1_depth = 0;
			towerET_6_2_depth = 0;
			towerET_6_3_depth = 0;
			towerET_7_0_depth = 0;
			towerET_7_1_depth = 0;
			towerET_7_2_depth = 0;
			towerET_7_3_depth = 0;
			towerET_8_0_depth = 0;
			towerET_8_1_depth = 0;
			towerET_8_2_depth = 0;
			towerET_8_3_depth = 0;
			towerET_9_0_depth = 0;
			towerET_9_1_depth = 0;
			towerET_9_2_depth = 0;
			towerET_9_3_depth = 0;
			towerET_10_0_depth = 0;
			towerET_10_1_depth = 0;
			towerET_10_2_depth = 0;
			towerET_10_3_depth = 0;
			towerET_11_0_depth = 0;
			towerET_11_1_depth = 0;
			towerET_11_2_depth = 0;
			towerET_11_3_depth = 0;
			towerET_12_0_depth = 0;
			towerET_12_1_depth = 0;
			towerET_12_2_depth = 0;
			towerET_12_3_depth = 0;
			towerET_13_0_depth = 0;
			towerET_13_1_depth = 0;
			towerET_13_2_depth = 0;
			towerET_13_3_depth = 0;
			towerET_14_0_depth = 0;
			towerET_14_1_depth = 0;
			towerET_14_2_depth = 0;
			towerET_14_3_depth = 0;
			towerET_15_0_depth = 0;
			towerET_15_1_depth = 0;
			towerET_15_2_depth = 0;
			towerET_15_3_depth = 0;
			towerET_16_0_depth = 0;
			towerET_16_1_depth = 0;
			towerET_16_2_depth = 0;
			towerET_16_3_depth = 0;
			TowerPhi_0_depth = 0;
			TowerPhi_1_depth = 0;
			TowerPhi_2_depth = 0;
			TowerPhi_3_depth = 0;
			TowerPhi_4_depth = 0;
			TowerPhi_5_depth = 0;
			TowerPhi_6_depth = 0;
			TowerPhi_7_depth = 0;
			TowerPhi_8_depth = 0;
			TowerPhi_9_depth = 0;
			TowerPhi_10_depth = 0;
			TowerPhi_11_depth = 0;
			TowerPhi_12_depth = 0;
			TowerPhi_13_depth = 0;
			TowerPhi_14_depth = 0;
			TowerPhi_15_depth = 0;
			TowerPhi_16_depth = 0;
			TowerPhi_17_depth = 0;
			TowerPhi_18_depth = 0;
			TowerPhi_19_depth = 0;
			TowerPhi_20_depth = 0;
			TowerPhi_21_depth = 0;
			TowerPhi_22_depth = 0;
			TowerPhi_23_depth = 0;
			TowerPhi_24_depth = 0;
			TowerPhi_25_depth = 0;
			TowerPhi_26_depth = 0;
			TowerPhi_27_depth = 0;
			TowerPhi_28_depth = 0;
			TowerPhi_29_depth = 0;
			TowerEta_0_depth = 0;
			TowerEta_1_depth = 0;
			TowerEta_2_depth = 0;
			TowerEta_3_depth = 0;
			TowerEta_4_depth = 0;
			TowerEta_5_depth = 0;
			TowerEta_6_depth = 0;
			TowerEta_7_depth = 0;
			TowerEta_8_depth = 0;
			TowerEta_9_depth = 0;
			TowerEta_10_depth = 0;
			TowerEta_11_depth = 0;
			TowerEta_12_depth = 0;
			TowerEta_13_depth = 0;
			TowerEta_14_depth = 0;
			TowerEta_15_depth = 0;
			TowerEta_16_depth = 0;
			TowerEta_17_depth = 0;
			TowerEta_18_depth = 0;
			TowerEta_19_depth = 0;
			TowerEta_20_depth = 0;
			TowerEta_21_depth = 0;
			TowerEta_22_depth = 0;
			TowerEta_23_depth = 0;
			TowerEta_24_depth = 0;
			TowerEta_25_depth = 0;
			TowerEta_26_depth = 0;
			TowerEta_27_depth = 0;
			TowerEta_28_depth = 0;
			TowerEta_29_depth = 0;
			trans_num =0;
		}

		~INTER_TCL_FILE() {
			mFile.open(mName);
			if (!mFile.good()) {
				cout << "Failed to open file ref.tcl" << endl;
				exit (1);
			}
			string total_list = get_depth_list();
			mFile << "set depth_list {\n";
			mFile << total_list;
			mFile << "}\n";
			mFile << "set trans_num "<<trans_num<<endl;
			mFile.close();
		}

		string get_depth_list () {
			stringstream total_list;
			total_list << "{towerET_0_0 " << towerET_0_0_depth << "}\n";
			total_list << "{towerET_0_1 " << towerET_0_1_depth << "}\n";
			total_list << "{towerET_0_2 " << towerET_0_2_depth << "}\n";
			total_list << "{towerET_0_3 " << towerET_0_3_depth << "}\n";
			total_list << "{towerET_1_0 " << towerET_1_0_depth << "}\n";
			total_list << "{towerET_1_1 " << towerET_1_1_depth << "}\n";
			total_list << "{towerET_1_2 " << towerET_1_2_depth << "}\n";
			total_list << "{towerET_1_3 " << towerET_1_3_depth << "}\n";
			total_list << "{towerET_2_0 " << towerET_2_0_depth << "}\n";
			total_list << "{towerET_2_1 " << towerET_2_1_depth << "}\n";
			total_list << "{towerET_2_2 " << towerET_2_2_depth << "}\n";
			total_list << "{towerET_2_3 " << towerET_2_3_depth << "}\n";
			total_list << "{towerET_3_0 " << towerET_3_0_depth << "}\n";
			total_list << "{towerET_3_1 " << towerET_3_1_depth << "}\n";
			total_list << "{towerET_3_2 " << towerET_3_2_depth << "}\n";
			total_list << "{towerET_3_3 " << towerET_3_3_depth << "}\n";
			total_list << "{towerET_4_0 " << towerET_4_0_depth << "}\n";
			total_list << "{towerET_4_1 " << towerET_4_1_depth << "}\n";
			total_list << "{towerET_4_2 " << towerET_4_2_depth << "}\n";
			total_list << "{towerET_4_3 " << towerET_4_3_depth << "}\n";
			total_list << "{towerET_5_0 " << towerET_5_0_depth << "}\n";
			total_list << "{towerET_5_1 " << towerET_5_1_depth << "}\n";
			total_list << "{towerET_5_2 " << towerET_5_2_depth << "}\n";
			total_list << "{towerET_5_3 " << towerET_5_3_depth << "}\n";
			total_list << "{towerET_6_0 " << towerET_6_0_depth << "}\n";
			total_list << "{towerET_6_1 " << towerET_6_1_depth << "}\n";
			total_list << "{towerET_6_2 " << towerET_6_2_depth << "}\n";
			total_list << "{towerET_6_3 " << towerET_6_3_depth << "}\n";
			total_list << "{towerET_7_0 " << towerET_7_0_depth << "}\n";
			total_list << "{towerET_7_1 " << towerET_7_1_depth << "}\n";
			total_list << "{towerET_7_2 " << towerET_7_2_depth << "}\n";
			total_list << "{towerET_7_3 " << towerET_7_3_depth << "}\n";
			total_list << "{towerET_8_0 " << towerET_8_0_depth << "}\n";
			total_list << "{towerET_8_1 " << towerET_8_1_depth << "}\n";
			total_list << "{towerET_8_2 " << towerET_8_2_depth << "}\n";
			total_list << "{towerET_8_3 " << towerET_8_3_depth << "}\n";
			total_list << "{towerET_9_0 " << towerET_9_0_depth << "}\n";
			total_list << "{towerET_9_1 " << towerET_9_1_depth << "}\n";
			total_list << "{towerET_9_2 " << towerET_9_2_depth << "}\n";
			total_list << "{towerET_9_3 " << towerET_9_3_depth << "}\n";
			total_list << "{towerET_10_0 " << towerET_10_0_depth << "}\n";
			total_list << "{towerET_10_1 " << towerET_10_1_depth << "}\n";
			total_list << "{towerET_10_2 " << towerET_10_2_depth << "}\n";
			total_list << "{towerET_10_3 " << towerET_10_3_depth << "}\n";
			total_list << "{towerET_11_0 " << towerET_11_0_depth << "}\n";
			total_list << "{towerET_11_1 " << towerET_11_1_depth << "}\n";
			total_list << "{towerET_11_2 " << towerET_11_2_depth << "}\n";
			total_list << "{towerET_11_3 " << towerET_11_3_depth << "}\n";
			total_list << "{towerET_12_0 " << towerET_12_0_depth << "}\n";
			total_list << "{towerET_12_1 " << towerET_12_1_depth << "}\n";
			total_list << "{towerET_12_2 " << towerET_12_2_depth << "}\n";
			total_list << "{towerET_12_3 " << towerET_12_3_depth << "}\n";
			total_list << "{towerET_13_0 " << towerET_13_0_depth << "}\n";
			total_list << "{towerET_13_1 " << towerET_13_1_depth << "}\n";
			total_list << "{towerET_13_2 " << towerET_13_2_depth << "}\n";
			total_list << "{towerET_13_3 " << towerET_13_3_depth << "}\n";
			total_list << "{towerET_14_0 " << towerET_14_0_depth << "}\n";
			total_list << "{towerET_14_1 " << towerET_14_1_depth << "}\n";
			total_list << "{towerET_14_2 " << towerET_14_2_depth << "}\n";
			total_list << "{towerET_14_3 " << towerET_14_3_depth << "}\n";
			total_list << "{towerET_15_0 " << towerET_15_0_depth << "}\n";
			total_list << "{towerET_15_1 " << towerET_15_1_depth << "}\n";
			total_list << "{towerET_15_2 " << towerET_15_2_depth << "}\n";
			total_list << "{towerET_15_3 " << towerET_15_3_depth << "}\n";
			total_list << "{towerET_16_0 " << towerET_16_0_depth << "}\n";
			total_list << "{towerET_16_1 " << towerET_16_1_depth << "}\n";
			total_list << "{towerET_16_2 " << towerET_16_2_depth << "}\n";
			total_list << "{towerET_16_3 " << towerET_16_3_depth << "}\n";
			total_list << "{TowerPhi_0 " << TowerPhi_0_depth << "}\n";
			total_list << "{TowerPhi_1 " << TowerPhi_1_depth << "}\n";
			total_list << "{TowerPhi_2 " << TowerPhi_2_depth << "}\n";
			total_list << "{TowerPhi_3 " << TowerPhi_3_depth << "}\n";
			total_list << "{TowerPhi_4 " << TowerPhi_4_depth << "}\n";
			total_list << "{TowerPhi_5 " << TowerPhi_5_depth << "}\n";
			total_list << "{TowerPhi_6 " << TowerPhi_6_depth << "}\n";
			total_list << "{TowerPhi_7 " << TowerPhi_7_depth << "}\n";
			total_list << "{TowerPhi_8 " << TowerPhi_8_depth << "}\n";
			total_list << "{TowerPhi_9 " << TowerPhi_9_depth << "}\n";
			total_list << "{TowerPhi_10 " << TowerPhi_10_depth << "}\n";
			total_list << "{TowerPhi_11 " << TowerPhi_11_depth << "}\n";
			total_list << "{TowerPhi_12 " << TowerPhi_12_depth << "}\n";
			total_list << "{TowerPhi_13 " << TowerPhi_13_depth << "}\n";
			total_list << "{TowerPhi_14 " << TowerPhi_14_depth << "}\n";
			total_list << "{TowerPhi_15 " << TowerPhi_15_depth << "}\n";
			total_list << "{TowerPhi_16 " << TowerPhi_16_depth << "}\n";
			total_list << "{TowerPhi_17 " << TowerPhi_17_depth << "}\n";
			total_list << "{TowerPhi_18 " << TowerPhi_18_depth << "}\n";
			total_list << "{TowerPhi_19 " << TowerPhi_19_depth << "}\n";
			total_list << "{TowerPhi_20 " << TowerPhi_20_depth << "}\n";
			total_list << "{TowerPhi_21 " << TowerPhi_21_depth << "}\n";
			total_list << "{TowerPhi_22 " << TowerPhi_22_depth << "}\n";
			total_list << "{TowerPhi_23 " << TowerPhi_23_depth << "}\n";
			total_list << "{TowerPhi_24 " << TowerPhi_24_depth << "}\n";
			total_list << "{TowerPhi_25 " << TowerPhi_25_depth << "}\n";
			total_list << "{TowerPhi_26 " << TowerPhi_26_depth << "}\n";
			total_list << "{TowerPhi_27 " << TowerPhi_27_depth << "}\n";
			total_list << "{TowerPhi_28 " << TowerPhi_28_depth << "}\n";
			total_list << "{TowerPhi_29 " << TowerPhi_29_depth << "}\n";
			total_list << "{TowerEta_0 " << TowerEta_0_depth << "}\n";
			total_list << "{TowerEta_1 " << TowerEta_1_depth << "}\n";
			total_list << "{TowerEta_2 " << TowerEta_2_depth << "}\n";
			total_list << "{TowerEta_3 " << TowerEta_3_depth << "}\n";
			total_list << "{TowerEta_4 " << TowerEta_4_depth << "}\n";
			total_list << "{TowerEta_5 " << TowerEta_5_depth << "}\n";
			total_list << "{TowerEta_6 " << TowerEta_6_depth << "}\n";
			total_list << "{TowerEta_7 " << TowerEta_7_depth << "}\n";
			total_list << "{TowerEta_8 " << TowerEta_8_depth << "}\n";
			total_list << "{TowerEta_9 " << TowerEta_9_depth << "}\n";
			total_list << "{TowerEta_10 " << TowerEta_10_depth << "}\n";
			total_list << "{TowerEta_11 " << TowerEta_11_depth << "}\n";
			total_list << "{TowerEta_12 " << TowerEta_12_depth << "}\n";
			total_list << "{TowerEta_13 " << TowerEta_13_depth << "}\n";
			total_list << "{TowerEta_14 " << TowerEta_14_depth << "}\n";
			total_list << "{TowerEta_15 " << TowerEta_15_depth << "}\n";
			total_list << "{TowerEta_16 " << TowerEta_16_depth << "}\n";
			total_list << "{TowerEta_17 " << TowerEta_17_depth << "}\n";
			total_list << "{TowerEta_18 " << TowerEta_18_depth << "}\n";
			total_list << "{TowerEta_19 " << TowerEta_19_depth << "}\n";
			total_list << "{TowerEta_20 " << TowerEta_20_depth << "}\n";
			total_list << "{TowerEta_21 " << TowerEta_21_depth << "}\n";
			total_list << "{TowerEta_22 " << TowerEta_22_depth << "}\n";
			total_list << "{TowerEta_23 " << TowerEta_23_depth << "}\n";
			total_list << "{TowerEta_24 " << TowerEta_24_depth << "}\n";
			total_list << "{TowerEta_25 " << TowerEta_25_depth << "}\n";
			total_list << "{TowerEta_26 " << TowerEta_26_depth << "}\n";
			total_list << "{TowerEta_27 " << TowerEta_27_depth << "}\n";
			total_list << "{TowerEta_28 " << TowerEta_28_depth << "}\n";
			total_list << "{TowerEta_29 " << TowerEta_29_depth << "}\n";
			return total_list.str();
		}

		void set_num (int num , int* class_num) {
			(*class_num) = (*class_num) > num ? (*class_num) : num;
		}
	public:
		int towerET_0_0_depth;
		int towerET_0_1_depth;
		int towerET_0_2_depth;
		int towerET_0_3_depth;
		int towerET_1_0_depth;
		int towerET_1_1_depth;
		int towerET_1_2_depth;
		int towerET_1_3_depth;
		int towerET_2_0_depth;
		int towerET_2_1_depth;
		int towerET_2_2_depth;
		int towerET_2_3_depth;
		int towerET_3_0_depth;
		int towerET_3_1_depth;
		int towerET_3_2_depth;
		int towerET_3_3_depth;
		int towerET_4_0_depth;
		int towerET_4_1_depth;
		int towerET_4_2_depth;
		int towerET_4_3_depth;
		int towerET_5_0_depth;
		int towerET_5_1_depth;
		int towerET_5_2_depth;
		int towerET_5_3_depth;
		int towerET_6_0_depth;
		int towerET_6_1_depth;
		int towerET_6_2_depth;
		int towerET_6_3_depth;
		int towerET_7_0_depth;
		int towerET_7_1_depth;
		int towerET_7_2_depth;
		int towerET_7_3_depth;
		int towerET_8_0_depth;
		int towerET_8_1_depth;
		int towerET_8_2_depth;
		int towerET_8_3_depth;
		int towerET_9_0_depth;
		int towerET_9_1_depth;
		int towerET_9_2_depth;
		int towerET_9_3_depth;
		int towerET_10_0_depth;
		int towerET_10_1_depth;
		int towerET_10_2_depth;
		int towerET_10_3_depth;
		int towerET_11_0_depth;
		int towerET_11_1_depth;
		int towerET_11_2_depth;
		int towerET_11_3_depth;
		int towerET_12_0_depth;
		int towerET_12_1_depth;
		int towerET_12_2_depth;
		int towerET_12_3_depth;
		int towerET_13_0_depth;
		int towerET_13_1_depth;
		int towerET_13_2_depth;
		int towerET_13_3_depth;
		int towerET_14_0_depth;
		int towerET_14_1_depth;
		int towerET_14_2_depth;
		int towerET_14_3_depth;
		int towerET_15_0_depth;
		int towerET_15_1_depth;
		int towerET_15_2_depth;
		int towerET_15_3_depth;
		int towerET_16_0_depth;
		int towerET_16_1_depth;
		int towerET_16_2_depth;
		int towerET_16_3_depth;
		int TowerPhi_0_depth;
		int TowerPhi_1_depth;
		int TowerPhi_2_depth;
		int TowerPhi_3_depth;
		int TowerPhi_4_depth;
		int TowerPhi_5_depth;
		int TowerPhi_6_depth;
		int TowerPhi_7_depth;
		int TowerPhi_8_depth;
		int TowerPhi_9_depth;
		int TowerPhi_10_depth;
		int TowerPhi_11_depth;
		int TowerPhi_12_depth;
		int TowerPhi_13_depth;
		int TowerPhi_14_depth;
		int TowerPhi_15_depth;
		int TowerPhi_16_depth;
		int TowerPhi_17_depth;
		int TowerPhi_18_depth;
		int TowerPhi_19_depth;
		int TowerPhi_20_depth;
		int TowerPhi_21_depth;
		int TowerPhi_22_depth;
		int TowerPhi_23_depth;
		int TowerPhi_24_depth;
		int TowerPhi_25_depth;
		int TowerPhi_26_depth;
		int TowerPhi_27_depth;
		int TowerPhi_28_depth;
		int TowerPhi_29_depth;
		int TowerEta_0_depth;
		int TowerEta_1_depth;
		int TowerEta_2_depth;
		int TowerEta_3_depth;
		int TowerEta_4_depth;
		int TowerEta_5_depth;
		int TowerEta_6_depth;
		int TowerEta_7_depth;
		int TowerEta_8_depth;
		int TowerEta_9_depth;
		int TowerEta_10_depth;
		int TowerEta_11_depth;
		int TowerEta_12_depth;
		int TowerEta_13_depth;
		int TowerEta_14_depth;
		int TowerEta_15_depth;
		int TowerEta_16_depth;
		int TowerEta_17_depth;
		int TowerEta_18_depth;
		int TowerEta_19_depth;
		int TowerEta_20_depth;
		int TowerEta_21_depth;
		int TowerEta_22_depth;
		int TowerEta_23_depth;
		int TowerEta_24_depth;
		int TowerEta_25_depth;
		int TowerEta_26_depth;
		int TowerEta_27_depth;
		int TowerEta_28_depth;
		int TowerEta_29_depth;
		int trans_num;

	private:
		ofstream mFile;
		const char* mName;
};

extern void TowerPeaks (
unsigned short towerET[17][4],
unsigned short TowerPhi[30],
unsigned short TowerEta[30]);

void AESL_WRAP_TowerPeaks (
unsigned short towerET[17][4],
unsigned short TowerPhi[30],
unsigned short TowerEta[30])
{
	refine_signal_handler();
	fstream wrapc_switch_file_token;
	wrapc_switch_file_token.open(".hls_cosim_wrapc_switch.log");
	int AESL_i;
	if (wrapc_switch_file_token.good())
	{
		CodeState = ENTER_WRAPC_PC;
		static unsigned AESL_transaction_pc = 0;
		string AESL_token;
		string AESL_num;
		static AESL_FILE_HANDLER aesl_fh;


		// output port post check: "TowerPhi_0"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_0, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_0, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_0, AESL_token); // data

			sc_bv<16> *TowerPhi_0_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_0', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_0', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerPhi_0_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_0, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerPhi_0))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerPhi_0
				{
					// bitslice(15, 0)
					// {
						// celement: TowerPhi(15, 0)
						// {
							sc_lv<16>* TowerPhi_lv0_0_0_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (0) => (0) @ (2)
							for (int i_0 = 0; i_0 <= 0; i_0 += 2)
							{
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi_lv0_0_0_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerPhi_0_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (0) => (0) @ (2)
							for (int i_0 = 0; i_0 <= 0; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerPhi[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerPhi[0]
								// output_left_conversion : TowerPhi[i_0]
								// output_type_conversion : (TowerPhi_lv0_0_0_2[hls_map_index++]).to_uint64()
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi[i_0] = (TowerPhi_lv0_0_0_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerPhi_0_pc_buffer;
		}

		// output port post check: "TowerPhi_1"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_1, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_1, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_1, AESL_token); // data

			sc_bv<16> *TowerPhi_1_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_1', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_1', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerPhi_1_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_1, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerPhi_1))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerPhi_1
				{
					// bitslice(15, 0)
					// {
						// celement: TowerPhi(15, 0)
						// {
							sc_lv<16>* TowerPhi_lv0_1_1_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (1) => (1) @ (2)
							for (int i_0 = 1; i_0 <= 1; i_0 += 2)
							{
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi_lv0_1_1_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerPhi_1_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (1) => (1) @ (2)
							for (int i_0 = 1; i_0 <= 1; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerPhi[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerPhi[0]
								// output_left_conversion : TowerPhi[i_0]
								// output_type_conversion : (TowerPhi_lv0_1_1_2[hls_map_index++]).to_uint64()
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi[i_0] = (TowerPhi_lv0_1_1_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerPhi_1_pc_buffer;
		}

		// output port post check: "TowerPhi_2"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_2, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_2, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_2, AESL_token); // data

			sc_bv<16> *TowerPhi_2_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_2', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_2', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerPhi_2_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_2, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerPhi_2))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerPhi_2
				{
					// bitslice(15, 0)
					// {
						// celement: TowerPhi(15, 0)
						// {
							sc_lv<16>* TowerPhi_lv0_2_2_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (2) => (2) @ (2)
							for (int i_0 = 2; i_0 <= 2; i_0 += 2)
							{
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi_lv0_2_2_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerPhi_2_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (2) => (2) @ (2)
							for (int i_0 = 2; i_0 <= 2; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerPhi[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerPhi[0]
								// output_left_conversion : TowerPhi[i_0]
								// output_type_conversion : (TowerPhi_lv0_2_2_2[hls_map_index++]).to_uint64()
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi[i_0] = (TowerPhi_lv0_2_2_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerPhi_2_pc_buffer;
		}

		// output port post check: "TowerPhi_3"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_3, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_3, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_3, AESL_token); // data

			sc_bv<16> *TowerPhi_3_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_3', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_3', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerPhi_3_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_3, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerPhi_3))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerPhi_3
				{
					// bitslice(15, 0)
					// {
						// celement: TowerPhi(15, 0)
						// {
							sc_lv<16>* TowerPhi_lv0_3_3_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (3) => (3) @ (2)
							for (int i_0 = 3; i_0 <= 3; i_0 += 2)
							{
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi_lv0_3_3_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerPhi_3_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (3) => (3) @ (2)
							for (int i_0 = 3; i_0 <= 3; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerPhi[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerPhi[0]
								// output_left_conversion : TowerPhi[i_0]
								// output_type_conversion : (TowerPhi_lv0_3_3_2[hls_map_index++]).to_uint64()
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi[i_0] = (TowerPhi_lv0_3_3_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerPhi_3_pc_buffer;
		}

		// output port post check: "TowerPhi_4"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_4, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_4, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_4, AESL_token); // data

			sc_bv<16> *TowerPhi_4_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_4', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_4', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerPhi_4_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_4, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerPhi_4))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerPhi_4
				{
					// bitslice(15, 0)
					// {
						// celement: TowerPhi(15, 0)
						// {
							sc_lv<16>* TowerPhi_lv0_4_4_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (4) => (4) @ (2)
							for (int i_0 = 4; i_0 <= 4; i_0 += 2)
							{
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi_lv0_4_4_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerPhi_4_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (4) => (4) @ (2)
							for (int i_0 = 4; i_0 <= 4; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerPhi[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerPhi[0]
								// output_left_conversion : TowerPhi[i_0]
								// output_type_conversion : (TowerPhi_lv0_4_4_2[hls_map_index++]).to_uint64()
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi[i_0] = (TowerPhi_lv0_4_4_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerPhi_4_pc_buffer;
		}

		// output port post check: "TowerPhi_5"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_5, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_5, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_5, AESL_token); // data

			sc_bv<16> *TowerPhi_5_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_5', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_5', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerPhi_5_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_5, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerPhi_5))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerPhi_5
				{
					// bitslice(15, 0)
					// {
						// celement: TowerPhi(15, 0)
						// {
							sc_lv<16>* TowerPhi_lv0_5_5_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (5) => (5) @ (2)
							for (int i_0 = 5; i_0 <= 5; i_0 += 2)
							{
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi_lv0_5_5_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerPhi_5_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (5) => (5) @ (2)
							for (int i_0 = 5; i_0 <= 5; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerPhi[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerPhi[0]
								// output_left_conversion : TowerPhi[i_0]
								// output_type_conversion : (TowerPhi_lv0_5_5_2[hls_map_index++]).to_uint64()
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi[i_0] = (TowerPhi_lv0_5_5_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerPhi_5_pc_buffer;
		}

		// output port post check: "TowerPhi_6"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_6, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_6, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_6, AESL_token); // data

			sc_bv<16> *TowerPhi_6_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_6', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_6', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerPhi_6_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_6, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerPhi_6))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerPhi_6
				{
					// bitslice(15, 0)
					// {
						// celement: TowerPhi(15, 0)
						// {
							sc_lv<16>* TowerPhi_lv0_6_6_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (6) => (6) @ (2)
							for (int i_0 = 6; i_0 <= 6; i_0 += 2)
							{
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi_lv0_6_6_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerPhi_6_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (6) => (6) @ (2)
							for (int i_0 = 6; i_0 <= 6; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerPhi[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerPhi[0]
								// output_left_conversion : TowerPhi[i_0]
								// output_type_conversion : (TowerPhi_lv0_6_6_2[hls_map_index++]).to_uint64()
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi[i_0] = (TowerPhi_lv0_6_6_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerPhi_6_pc_buffer;
		}

		// output port post check: "TowerPhi_7"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_7, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_7, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_7, AESL_token); // data

			sc_bv<16> *TowerPhi_7_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_7', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_7', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerPhi_7_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_7, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerPhi_7))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerPhi_7
				{
					// bitslice(15, 0)
					// {
						// celement: TowerPhi(15, 0)
						// {
							sc_lv<16>* TowerPhi_lv0_7_7_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (7) => (7) @ (2)
							for (int i_0 = 7; i_0 <= 7; i_0 += 2)
							{
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi_lv0_7_7_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerPhi_7_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (7) => (7) @ (2)
							for (int i_0 = 7; i_0 <= 7; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerPhi[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerPhi[0]
								// output_left_conversion : TowerPhi[i_0]
								// output_type_conversion : (TowerPhi_lv0_7_7_2[hls_map_index++]).to_uint64()
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi[i_0] = (TowerPhi_lv0_7_7_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerPhi_7_pc_buffer;
		}

		// output port post check: "TowerPhi_8"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_8, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_8, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_8, AESL_token); // data

			sc_bv<16> *TowerPhi_8_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_8', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_8', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerPhi_8_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_8, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerPhi_8))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerPhi_8
				{
					// bitslice(15, 0)
					// {
						// celement: TowerPhi(15, 0)
						// {
							sc_lv<16>* TowerPhi_lv0_8_8_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (8) => (8) @ (2)
							for (int i_0 = 8; i_0 <= 8; i_0 += 2)
							{
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi_lv0_8_8_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerPhi_8_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (8) => (8) @ (2)
							for (int i_0 = 8; i_0 <= 8; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerPhi[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerPhi[0]
								// output_left_conversion : TowerPhi[i_0]
								// output_type_conversion : (TowerPhi_lv0_8_8_2[hls_map_index++]).to_uint64()
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi[i_0] = (TowerPhi_lv0_8_8_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerPhi_8_pc_buffer;
		}

		// output port post check: "TowerPhi_9"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_9, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_9, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_9, AESL_token); // data

			sc_bv<16> *TowerPhi_9_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_9', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_9', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerPhi_9_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_9, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerPhi_9))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerPhi_9
				{
					// bitslice(15, 0)
					// {
						// celement: TowerPhi(15, 0)
						// {
							sc_lv<16>* TowerPhi_lv0_9_9_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (9) => (9) @ (2)
							for (int i_0 = 9; i_0 <= 9; i_0 += 2)
							{
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi_lv0_9_9_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerPhi_9_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (9) => (9) @ (2)
							for (int i_0 = 9; i_0 <= 9; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerPhi[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerPhi[0]
								// output_left_conversion : TowerPhi[i_0]
								// output_type_conversion : (TowerPhi_lv0_9_9_2[hls_map_index++]).to_uint64()
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi[i_0] = (TowerPhi_lv0_9_9_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerPhi_9_pc_buffer;
		}

		// output port post check: "TowerPhi_10"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_10, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_10, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_10, AESL_token); // data

			sc_bv<16> *TowerPhi_10_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_10', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_10', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerPhi_10_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_10, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerPhi_10))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerPhi_10
				{
					// bitslice(15, 0)
					// {
						// celement: TowerPhi(15, 0)
						// {
							sc_lv<16>* TowerPhi_lv0_10_10_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (10) => (10) @ (2)
							for (int i_0 = 10; i_0 <= 10; i_0 += 2)
							{
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi_lv0_10_10_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerPhi_10_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (10) => (10) @ (2)
							for (int i_0 = 10; i_0 <= 10; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerPhi[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerPhi[0]
								// output_left_conversion : TowerPhi[i_0]
								// output_type_conversion : (TowerPhi_lv0_10_10_2[hls_map_index++]).to_uint64()
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi[i_0] = (TowerPhi_lv0_10_10_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerPhi_10_pc_buffer;
		}

		// output port post check: "TowerPhi_11"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_11, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_11, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_11, AESL_token); // data

			sc_bv<16> *TowerPhi_11_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_11', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_11', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerPhi_11_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_11, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerPhi_11))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerPhi_11
				{
					// bitslice(15, 0)
					// {
						// celement: TowerPhi(15, 0)
						// {
							sc_lv<16>* TowerPhi_lv0_11_11_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (11) => (11) @ (2)
							for (int i_0 = 11; i_0 <= 11; i_0 += 2)
							{
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi_lv0_11_11_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerPhi_11_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (11) => (11) @ (2)
							for (int i_0 = 11; i_0 <= 11; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerPhi[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerPhi[0]
								// output_left_conversion : TowerPhi[i_0]
								// output_type_conversion : (TowerPhi_lv0_11_11_2[hls_map_index++]).to_uint64()
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi[i_0] = (TowerPhi_lv0_11_11_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerPhi_11_pc_buffer;
		}

		// output port post check: "TowerPhi_12"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_12, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_12, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_12, AESL_token); // data

			sc_bv<16> *TowerPhi_12_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_12', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_12', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerPhi_12_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_12, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerPhi_12))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerPhi_12
				{
					// bitslice(15, 0)
					// {
						// celement: TowerPhi(15, 0)
						// {
							sc_lv<16>* TowerPhi_lv0_12_12_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (12) => (12) @ (2)
							for (int i_0 = 12; i_0 <= 12; i_0 += 2)
							{
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi_lv0_12_12_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerPhi_12_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (12) => (12) @ (2)
							for (int i_0 = 12; i_0 <= 12; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerPhi[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerPhi[0]
								// output_left_conversion : TowerPhi[i_0]
								// output_type_conversion : (TowerPhi_lv0_12_12_2[hls_map_index++]).to_uint64()
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi[i_0] = (TowerPhi_lv0_12_12_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerPhi_12_pc_buffer;
		}

		// output port post check: "TowerPhi_13"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_13, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_13, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_13, AESL_token); // data

			sc_bv<16> *TowerPhi_13_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_13', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_13', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerPhi_13_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_13, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerPhi_13))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerPhi_13
				{
					// bitslice(15, 0)
					// {
						// celement: TowerPhi(15, 0)
						// {
							sc_lv<16>* TowerPhi_lv0_13_13_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (13) => (13) @ (2)
							for (int i_0 = 13; i_0 <= 13; i_0 += 2)
							{
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi_lv0_13_13_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerPhi_13_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (13) => (13) @ (2)
							for (int i_0 = 13; i_0 <= 13; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerPhi[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerPhi[0]
								// output_left_conversion : TowerPhi[i_0]
								// output_type_conversion : (TowerPhi_lv0_13_13_2[hls_map_index++]).to_uint64()
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi[i_0] = (TowerPhi_lv0_13_13_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerPhi_13_pc_buffer;
		}

		// output port post check: "TowerPhi_14"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_14, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_14, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_14, AESL_token); // data

			sc_bv<16> *TowerPhi_14_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_14', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_14', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerPhi_14_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_14, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerPhi_14))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerPhi_14
				{
					// bitslice(15, 0)
					// {
						// celement: TowerPhi(15, 0)
						// {
							sc_lv<16>* TowerPhi_lv0_14_14_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (14) => (14) @ (2)
							for (int i_0 = 14; i_0 <= 14; i_0 += 2)
							{
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi_lv0_14_14_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerPhi_14_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (14) => (14) @ (2)
							for (int i_0 = 14; i_0 <= 14; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerPhi[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerPhi[0]
								// output_left_conversion : TowerPhi[i_0]
								// output_type_conversion : (TowerPhi_lv0_14_14_2[hls_map_index++]).to_uint64()
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi[i_0] = (TowerPhi_lv0_14_14_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerPhi_14_pc_buffer;
		}

		// output port post check: "TowerPhi_15"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_15, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_15, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_15, AESL_token); // data

			sc_bv<16> *TowerPhi_15_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_15', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_15', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerPhi_15_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_15, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerPhi_15))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerPhi_15
				{
					// bitslice(15, 0)
					// {
						// celement: TowerPhi(15, 0)
						// {
							sc_lv<16>* TowerPhi_lv0_15_15_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (15) => (15) @ (2)
							for (int i_0 = 15; i_0 <= 15; i_0 += 2)
							{
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi_lv0_15_15_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerPhi_15_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (15) => (15) @ (2)
							for (int i_0 = 15; i_0 <= 15; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerPhi[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerPhi[0]
								// output_left_conversion : TowerPhi[i_0]
								// output_type_conversion : (TowerPhi_lv0_15_15_2[hls_map_index++]).to_uint64()
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi[i_0] = (TowerPhi_lv0_15_15_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerPhi_15_pc_buffer;
		}

		// output port post check: "TowerPhi_16"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_16, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_16, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_16, AESL_token); // data

			sc_bv<16> *TowerPhi_16_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_16', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_16', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerPhi_16_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_16, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerPhi_16))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerPhi_16
				{
					// bitslice(15, 0)
					// {
						// celement: TowerPhi(15, 0)
						// {
							sc_lv<16>* TowerPhi_lv0_16_16_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (16) => (16) @ (2)
							for (int i_0 = 16; i_0 <= 16; i_0 += 2)
							{
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi_lv0_16_16_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerPhi_16_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (16) => (16) @ (2)
							for (int i_0 = 16; i_0 <= 16; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerPhi[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerPhi[0]
								// output_left_conversion : TowerPhi[i_0]
								// output_type_conversion : (TowerPhi_lv0_16_16_2[hls_map_index++]).to_uint64()
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi[i_0] = (TowerPhi_lv0_16_16_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerPhi_16_pc_buffer;
		}

		// output port post check: "TowerPhi_17"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_17, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_17, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_17, AESL_token); // data

			sc_bv<16> *TowerPhi_17_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_17', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_17', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerPhi_17_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_17, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerPhi_17))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerPhi_17
				{
					// bitslice(15, 0)
					// {
						// celement: TowerPhi(15, 0)
						// {
							sc_lv<16>* TowerPhi_lv0_17_17_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (17) => (17) @ (2)
							for (int i_0 = 17; i_0 <= 17; i_0 += 2)
							{
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi_lv0_17_17_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerPhi_17_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (17) => (17) @ (2)
							for (int i_0 = 17; i_0 <= 17; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerPhi[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerPhi[0]
								// output_left_conversion : TowerPhi[i_0]
								// output_type_conversion : (TowerPhi_lv0_17_17_2[hls_map_index++]).to_uint64()
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi[i_0] = (TowerPhi_lv0_17_17_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerPhi_17_pc_buffer;
		}

		// output port post check: "TowerPhi_18"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_18, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_18, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_18, AESL_token); // data

			sc_bv<16> *TowerPhi_18_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_18', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_18', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerPhi_18_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_18, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerPhi_18))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerPhi_18
				{
					// bitslice(15, 0)
					// {
						// celement: TowerPhi(15, 0)
						// {
							sc_lv<16>* TowerPhi_lv0_18_18_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (18) => (18) @ (2)
							for (int i_0 = 18; i_0 <= 18; i_0 += 2)
							{
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi_lv0_18_18_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerPhi_18_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (18) => (18) @ (2)
							for (int i_0 = 18; i_0 <= 18; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerPhi[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerPhi[0]
								// output_left_conversion : TowerPhi[i_0]
								// output_type_conversion : (TowerPhi_lv0_18_18_2[hls_map_index++]).to_uint64()
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi[i_0] = (TowerPhi_lv0_18_18_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerPhi_18_pc_buffer;
		}

		// output port post check: "TowerPhi_19"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_19, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_19, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_19, AESL_token); // data

			sc_bv<16> *TowerPhi_19_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_19', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_19', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerPhi_19_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_19, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerPhi_19))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerPhi_19
				{
					// bitslice(15, 0)
					// {
						// celement: TowerPhi(15, 0)
						// {
							sc_lv<16>* TowerPhi_lv0_19_19_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (19) => (19) @ (2)
							for (int i_0 = 19; i_0 <= 19; i_0 += 2)
							{
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi_lv0_19_19_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerPhi_19_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (19) => (19) @ (2)
							for (int i_0 = 19; i_0 <= 19; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerPhi[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerPhi[0]
								// output_left_conversion : TowerPhi[i_0]
								// output_type_conversion : (TowerPhi_lv0_19_19_2[hls_map_index++]).to_uint64()
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi[i_0] = (TowerPhi_lv0_19_19_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerPhi_19_pc_buffer;
		}

		// output port post check: "TowerPhi_20"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_20, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_20, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_20, AESL_token); // data

			sc_bv<16> *TowerPhi_20_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_20', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_20', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerPhi_20_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_20, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerPhi_20))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerPhi_20
				{
					// bitslice(15, 0)
					// {
						// celement: TowerPhi(15, 0)
						// {
							sc_lv<16>* TowerPhi_lv0_20_20_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (20) => (20) @ (2)
							for (int i_0 = 20; i_0 <= 20; i_0 += 2)
							{
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi_lv0_20_20_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerPhi_20_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (20) => (20) @ (2)
							for (int i_0 = 20; i_0 <= 20; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerPhi[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerPhi[0]
								// output_left_conversion : TowerPhi[i_0]
								// output_type_conversion : (TowerPhi_lv0_20_20_2[hls_map_index++]).to_uint64()
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi[i_0] = (TowerPhi_lv0_20_20_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerPhi_20_pc_buffer;
		}

		// output port post check: "TowerPhi_21"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_21, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_21, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_21, AESL_token); // data

			sc_bv<16> *TowerPhi_21_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_21', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_21', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerPhi_21_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_21, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerPhi_21))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerPhi_21
				{
					// bitslice(15, 0)
					// {
						// celement: TowerPhi(15, 0)
						// {
							sc_lv<16>* TowerPhi_lv0_21_21_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (21) => (21) @ (2)
							for (int i_0 = 21; i_0 <= 21; i_0 += 2)
							{
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi_lv0_21_21_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerPhi_21_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (21) => (21) @ (2)
							for (int i_0 = 21; i_0 <= 21; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerPhi[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerPhi[0]
								// output_left_conversion : TowerPhi[i_0]
								// output_type_conversion : (TowerPhi_lv0_21_21_2[hls_map_index++]).to_uint64()
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi[i_0] = (TowerPhi_lv0_21_21_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerPhi_21_pc_buffer;
		}

		// output port post check: "TowerPhi_22"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_22, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_22, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_22, AESL_token); // data

			sc_bv<16> *TowerPhi_22_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_22', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_22', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerPhi_22_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_22, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerPhi_22))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerPhi_22
				{
					// bitslice(15, 0)
					// {
						// celement: TowerPhi(15, 0)
						// {
							sc_lv<16>* TowerPhi_lv0_22_22_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (22) => (22) @ (2)
							for (int i_0 = 22; i_0 <= 22; i_0 += 2)
							{
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi_lv0_22_22_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerPhi_22_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (22) => (22) @ (2)
							for (int i_0 = 22; i_0 <= 22; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerPhi[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerPhi[0]
								// output_left_conversion : TowerPhi[i_0]
								// output_type_conversion : (TowerPhi_lv0_22_22_2[hls_map_index++]).to_uint64()
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi[i_0] = (TowerPhi_lv0_22_22_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerPhi_22_pc_buffer;
		}

		// output port post check: "TowerPhi_23"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_23, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_23, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_23, AESL_token); // data

			sc_bv<16> *TowerPhi_23_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_23', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_23', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerPhi_23_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_23, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerPhi_23))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerPhi_23
				{
					// bitslice(15, 0)
					// {
						// celement: TowerPhi(15, 0)
						// {
							sc_lv<16>* TowerPhi_lv0_23_23_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (23) => (23) @ (2)
							for (int i_0 = 23; i_0 <= 23; i_0 += 2)
							{
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi_lv0_23_23_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerPhi_23_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (23) => (23) @ (2)
							for (int i_0 = 23; i_0 <= 23; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerPhi[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerPhi[0]
								// output_left_conversion : TowerPhi[i_0]
								// output_type_conversion : (TowerPhi_lv0_23_23_2[hls_map_index++]).to_uint64()
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi[i_0] = (TowerPhi_lv0_23_23_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerPhi_23_pc_buffer;
		}

		// output port post check: "TowerPhi_24"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_24, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_24, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_24, AESL_token); // data

			sc_bv<16> *TowerPhi_24_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_24', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_24', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerPhi_24_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_24, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerPhi_24))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerPhi_24
				{
					// bitslice(15, 0)
					// {
						// celement: TowerPhi(15, 0)
						// {
							sc_lv<16>* TowerPhi_lv0_24_24_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (24) => (24) @ (2)
							for (int i_0 = 24; i_0 <= 24; i_0 += 2)
							{
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi_lv0_24_24_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerPhi_24_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (24) => (24) @ (2)
							for (int i_0 = 24; i_0 <= 24; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerPhi[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerPhi[0]
								// output_left_conversion : TowerPhi[i_0]
								// output_type_conversion : (TowerPhi_lv0_24_24_2[hls_map_index++]).to_uint64()
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi[i_0] = (TowerPhi_lv0_24_24_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerPhi_24_pc_buffer;
		}

		// output port post check: "TowerPhi_25"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_25, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_25, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_25, AESL_token); // data

			sc_bv<16> *TowerPhi_25_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_25', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_25', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerPhi_25_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_25, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerPhi_25))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerPhi_25
				{
					// bitslice(15, 0)
					// {
						// celement: TowerPhi(15, 0)
						// {
							sc_lv<16>* TowerPhi_lv0_25_25_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (25) => (25) @ (2)
							for (int i_0 = 25; i_0 <= 25; i_0 += 2)
							{
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi_lv0_25_25_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerPhi_25_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (25) => (25) @ (2)
							for (int i_0 = 25; i_0 <= 25; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerPhi[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerPhi[0]
								// output_left_conversion : TowerPhi[i_0]
								// output_type_conversion : (TowerPhi_lv0_25_25_2[hls_map_index++]).to_uint64()
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi[i_0] = (TowerPhi_lv0_25_25_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerPhi_25_pc_buffer;
		}

		// output port post check: "TowerPhi_26"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_26, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_26, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_26, AESL_token); // data

			sc_bv<16> *TowerPhi_26_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_26', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_26', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerPhi_26_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_26, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerPhi_26))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerPhi_26
				{
					// bitslice(15, 0)
					// {
						// celement: TowerPhi(15, 0)
						// {
							sc_lv<16>* TowerPhi_lv0_26_26_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (26) => (26) @ (2)
							for (int i_0 = 26; i_0 <= 26; i_0 += 2)
							{
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi_lv0_26_26_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerPhi_26_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (26) => (26) @ (2)
							for (int i_0 = 26; i_0 <= 26; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerPhi[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerPhi[0]
								// output_left_conversion : TowerPhi[i_0]
								// output_type_conversion : (TowerPhi_lv0_26_26_2[hls_map_index++]).to_uint64()
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi[i_0] = (TowerPhi_lv0_26_26_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerPhi_26_pc_buffer;
		}

		// output port post check: "TowerPhi_27"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_27, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_27, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_27, AESL_token); // data

			sc_bv<16> *TowerPhi_27_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_27', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_27', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerPhi_27_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_27, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerPhi_27))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerPhi_27
				{
					// bitslice(15, 0)
					// {
						// celement: TowerPhi(15, 0)
						// {
							sc_lv<16>* TowerPhi_lv0_27_27_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (27) => (27) @ (2)
							for (int i_0 = 27; i_0 <= 27; i_0 += 2)
							{
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi_lv0_27_27_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerPhi_27_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (27) => (27) @ (2)
							for (int i_0 = 27; i_0 <= 27; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerPhi[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerPhi[0]
								// output_left_conversion : TowerPhi[i_0]
								// output_type_conversion : (TowerPhi_lv0_27_27_2[hls_map_index++]).to_uint64()
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi[i_0] = (TowerPhi_lv0_27_27_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerPhi_27_pc_buffer;
		}

		// output port post check: "TowerPhi_28"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_28, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_28, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_28, AESL_token); // data

			sc_bv<16> *TowerPhi_28_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_28', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_28', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerPhi_28_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_28, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerPhi_28))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerPhi_28
				{
					// bitslice(15, 0)
					// {
						// celement: TowerPhi(15, 0)
						// {
							sc_lv<16>* TowerPhi_lv0_28_28_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (28) => (28) @ (2)
							for (int i_0 = 28; i_0 <= 28; i_0 += 2)
							{
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi_lv0_28_28_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerPhi_28_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (28) => (28) @ (2)
							for (int i_0 = 28; i_0 <= 28; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerPhi[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerPhi[0]
								// output_left_conversion : TowerPhi[i_0]
								// output_type_conversion : (TowerPhi_lv0_28_28_2[hls_map_index++]).to_uint64()
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi[i_0] = (TowerPhi_lv0_28_28_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerPhi_28_pc_buffer;
		}

		// output port post check: "TowerPhi_29"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_29, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_29, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_29, AESL_token); // data

			sc_bv<16> *TowerPhi_29_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_29', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerPhi_29', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerPhi_29_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerPhi_29, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerPhi_29))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerPhi_29
				{
					// bitslice(15, 0)
					// {
						// celement: TowerPhi(15, 0)
						// {
							sc_lv<16>* TowerPhi_lv0_29_29_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (29) => (29) @ (2)
							for (int i_0 = 29; i_0 <= 29; i_0 += 2)
							{
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi_lv0_29_29_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerPhi_29_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerPhi(15, 0)
						{
							// carray: (29) => (29) @ (2)
							for (int i_0 = 29; i_0 <= 29; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerPhi[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerPhi[0]
								// output_left_conversion : TowerPhi[i_0]
								// output_type_conversion : (TowerPhi_lv0_29_29_2[hls_map_index++]).to_uint64()
								if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerPhi[i_0] = (TowerPhi_lv0_29_29_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerPhi_29_pc_buffer;
		}

		// output port post check: "TowerEta_0"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_0, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_0, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_0, AESL_token); // data

			sc_bv<16> *TowerEta_0_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_0', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_0', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerEta_0_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_0, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerEta_0))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerEta_0
				{
					// bitslice(15, 0)
					// {
						// celement: TowerEta(15, 0)
						// {
							sc_lv<16>* TowerEta_lv0_0_0_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (0) => (0) @ (2)
							for (int i_0 = 0; i_0 <= 0; i_0 += 2)
							{
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta_lv0_0_0_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerEta_0_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (0) => (0) @ (2)
							for (int i_0 = 0; i_0 <= 0; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerEta[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerEta[0]
								// output_left_conversion : TowerEta[i_0]
								// output_type_conversion : (TowerEta_lv0_0_0_2[hls_map_index++]).to_uint64()
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta[i_0] = (TowerEta_lv0_0_0_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerEta_0_pc_buffer;
		}

		// output port post check: "TowerEta_1"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_1, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_1, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_1, AESL_token); // data

			sc_bv<16> *TowerEta_1_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_1', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_1', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerEta_1_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_1, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerEta_1))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerEta_1
				{
					// bitslice(15, 0)
					// {
						// celement: TowerEta(15, 0)
						// {
							sc_lv<16>* TowerEta_lv0_1_1_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (1) => (1) @ (2)
							for (int i_0 = 1; i_0 <= 1; i_0 += 2)
							{
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta_lv0_1_1_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerEta_1_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (1) => (1) @ (2)
							for (int i_0 = 1; i_0 <= 1; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerEta[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerEta[0]
								// output_left_conversion : TowerEta[i_0]
								// output_type_conversion : (TowerEta_lv0_1_1_2[hls_map_index++]).to_uint64()
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta[i_0] = (TowerEta_lv0_1_1_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerEta_1_pc_buffer;
		}

		// output port post check: "TowerEta_2"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_2, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_2, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_2, AESL_token); // data

			sc_bv<16> *TowerEta_2_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_2', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_2', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerEta_2_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_2, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerEta_2))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerEta_2
				{
					// bitslice(15, 0)
					// {
						// celement: TowerEta(15, 0)
						// {
							sc_lv<16>* TowerEta_lv0_2_2_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (2) => (2) @ (2)
							for (int i_0 = 2; i_0 <= 2; i_0 += 2)
							{
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta_lv0_2_2_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerEta_2_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (2) => (2) @ (2)
							for (int i_0 = 2; i_0 <= 2; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerEta[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerEta[0]
								// output_left_conversion : TowerEta[i_0]
								// output_type_conversion : (TowerEta_lv0_2_2_2[hls_map_index++]).to_uint64()
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta[i_0] = (TowerEta_lv0_2_2_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerEta_2_pc_buffer;
		}

		// output port post check: "TowerEta_3"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_3, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_3, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_3, AESL_token); // data

			sc_bv<16> *TowerEta_3_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_3', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_3', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerEta_3_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_3, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerEta_3))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerEta_3
				{
					// bitslice(15, 0)
					// {
						// celement: TowerEta(15, 0)
						// {
							sc_lv<16>* TowerEta_lv0_3_3_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (3) => (3) @ (2)
							for (int i_0 = 3; i_0 <= 3; i_0 += 2)
							{
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta_lv0_3_3_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerEta_3_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (3) => (3) @ (2)
							for (int i_0 = 3; i_0 <= 3; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerEta[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerEta[0]
								// output_left_conversion : TowerEta[i_0]
								// output_type_conversion : (TowerEta_lv0_3_3_2[hls_map_index++]).to_uint64()
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta[i_0] = (TowerEta_lv0_3_3_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerEta_3_pc_buffer;
		}

		// output port post check: "TowerEta_4"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_4, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_4, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_4, AESL_token); // data

			sc_bv<16> *TowerEta_4_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_4', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_4', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerEta_4_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_4, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerEta_4))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerEta_4
				{
					// bitslice(15, 0)
					// {
						// celement: TowerEta(15, 0)
						// {
							sc_lv<16>* TowerEta_lv0_4_4_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (4) => (4) @ (2)
							for (int i_0 = 4; i_0 <= 4; i_0 += 2)
							{
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta_lv0_4_4_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerEta_4_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (4) => (4) @ (2)
							for (int i_0 = 4; i_0 <= 4; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerEta[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerEta[0]
								// output_left_conversion : TowerEta[i_0]
								// output_type_conversion : (TowerEta_lv0_4_4_2[hls_map_index++]).to_uint64()
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta[i_0] = (TowerEta_lv0_4_4_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerEta_4_pc_buffer;
		}

		// output port post check: "TowerEta_5"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_5, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_5, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_5, AESL_token); // data

			sc_bv<16> *TowerEta_5_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_5', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_5', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerEta_5_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_5, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerEta_5))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerEta_5
				{
					// bitslice(15, 0)
					// {
						// celement: TowerEta(15, 0)
						// {
							sc_lv<16>* TowerEta_lv0_5_5_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (5) => (5) @ (2)
							for (int i_0 = 5; i_0 <= 5; i_0 += 2)
							{
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta_lv0_5_5_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerEta_5_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (5) => (5) @ (2)
							for (int i_0 = 5; i_0 <= 5; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerEta[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerEta[0]
								// output_left_conversion : TowerEta[i_0]
								// output_type_conversion : (TowerEta_lv0_5_5_2[hls_map_index++]).to_uint64()
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta[i_0] = (TowerEta_lv0_5_5_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerEta_5_pc_buffer;
		}

		// output port post check: "TowerEta_6"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_6, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_6, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_6, AESL_token); // data

			sc_bv<16> *TowerEta_6_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_6', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_6', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerEta_6_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_6, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerEta_6))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerEta_6
				{
					// bitslice(15, 0)
					// {
						// celement: TowerEta(15, 0)
						// {
							sc_lv<16>* TowerEta_lv0_6_6_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (6) => (6) @ (2)
							for (int i_0 = 6; i_0 <= 6; i_0 += 2)
							{
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta_lv0_6_6_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerEta_6_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (6) => (6) @ (2)
							for (int i_0 = 6; i_0 <= 6; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerEta[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerEta[0]
								// output_left_conversion : TowerEta[i_0]
								// output_type_conversion : (TowerEta_lv0_6_6_2[hls_map_index++]).to_uint64()
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta[i_0] = (TowerEta_lv0_6_6_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerEta_6_pc_buffer;
		}

		// output port post check: "TowerEta_7"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_7, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_7, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_7, AESL_token); // data

			sc_bv<16> *TowerEta_7_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_7', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_7', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerEta_7_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_7, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerEta_7))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerEta_7
				{
					// bitslice(15, 0)
					// {
						// celement: TowerEta(15, 0)
						// {
							sc_lv<16>* TowerEta_lv0_7_7_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (7) => (7) @ (2)
							for (int i_0 = 7; i_0 <= 7; i_0 += 2)
							{
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta_lv0_7_7_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerEta_7_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (7) => (7) @ (2)
							for (int i_0 = 7; i_0 <= 7; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerEta[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerEta[0]
								// output_left_conversion : TowerEta[i_0]
								// output_type_conversion : (TowerEta_lv0_7_7_2[hls_map_index++]).to_uint64()
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta[i_0] = (TowerEta_lv0_7_7_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerEta_7_pc_buffer;
		}

		// output port post check: "TowerEta_8"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_8, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_8, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_8, AESL_token); // data

			sc_bv<16> *TowerEta_8_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_8', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_8', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerEta_8_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_8, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerEta_8))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerEta_8
				{
					// bitslice(15, 0)
					// {
						// celement: TowerEta(15, 0)
						// {
							sc_lv<16>* TowerEta_lv0_8_8_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (8) => (8) @ (2)
							for (int i_0 = 8; i_0 <= 8; i_0 += 2)
							{
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta_lv0_8_8_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerEta_8_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (8) => (8) @ (2)
							for (int i_0 = 8; i_0 <= 8; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerEta[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerEta[0]
								// output_left_conversion : TowerEta[i_0]
								// output_type_conversion : (TowerEta_lv0_8_8_2[hls_map_index++]).to_uint64()
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta[i_0] = (TowerEta_lv0_8_8_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerEta_8_pc_buffer;
		}

		// output port post check: "TowerEta_9"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_9, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_9, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_9, AESL_token); // data

			sc_bv<16> *TowerEta_9_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_9', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_9', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerEta_9_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_9, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerEta_9))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerEta_9
				{
					// bitslice(15, 0)
					// {
						// celement: TowerEta(15, 0)
						// {
							sc_lv<16>* TowerEta_lv0_9_9_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (9) => (9) @ (2)
							for (int i_0 = 9; i_0 <= 9; i_0 += 2)
							{
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta_lv0_9_9_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerEta_9_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (9) => (9) @ (2)
							for (int i_0 = 9; i_0 <= 9; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerEta[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerEta[0]
								// output_left_conversion : TowerEta[i_0]
								// output_type_conversion : (TowerEta_lv0_9_9_2[hls_map_index++]).to_uint64()
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta[i_0] = (TowerEta_lv0_9_9_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerEta_9_pc_buffer;
		}

		// output port post check: "TowerEta_10"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_10, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_10, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_10, AESL_token); // data

			sc_bv<16> *TowerEta_10_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_10', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_10', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerEta_10_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_10, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerEta_10))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerEta_10
				{
					// bitslice(15, 0)
					// {
						// celement: TowerEta(15, 0)
						// {
							sc_lv<16>* TowerEta_lv0_10_10_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (10) => (10) @ (2)
							for (int i_0 = 10; i_0 <= 10; i_0 += 2)
							{
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta_lv0_10_10_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerEta_10_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (10) => (10) @ (2)
							for (int i_0 = 10; i_0 <= 10; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerEta[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerEta[0]
								// output_left_conversion : TowerEta[i_0]
								// output_type_conversion : (TowerEta_lv0_10_10_2[hls_map_index++]).to_uint64()
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta[i_0] = (TowerEta_lv0_10_10_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerEta_10_pc_buffer;
		}

		// output port post check: "TowerEta_11"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_11, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_11, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_11, AESL_token); // data

			sc_bv<16> *TowerEta_11_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_11', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_11', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerEta_11_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_11, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerEta_11))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerEta_11
				{
					// bitslice(15, 0)
					// {
						// celement: TowerEta(15, 0)
						// {
							sc_lv<16>* TowerEta_lv0_11_11_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (11) => (11) @ (2)
							for (int i_0 = 11; i_0 <= 11; i_0 += 2)
							{
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta_lv0_11_11_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerEta_11_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (11) => (11) @ (2)
							for (int i_0 = 11; i_0 <= 11; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerEta[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerEta[0]
								// output_left_conversion : TowerEta[i_0]
								// output_type_conversion : (TowerEta_lv0_11_11_2[hls_map_index++]).to_uint64()
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta[i_0] = (TowerEta_lv0_11_11_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerEta_11_pc_buffer;
		}

		// output port post check: "TowerEta_12"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_12, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_12, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_12, AESL_token); // data

			sc_bv<16> *TowerEta_12_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_12', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_12', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerEta_12_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_12, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerEta_12))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerEta_12
				{
					// bitslice(15, 0)
					// {
						// celement: TowerEta(15, 0)
						// {
							sc_lv<16>* TowerEta_lv0_12_12_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (12) => (12) @ (2)
							for (int i_0 = 12; i_0 <= 12; i_0 += 2)
							{
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta_lv0_12_12_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerEta_12_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (12) => (12) @ (2)
							for (int i_0 = 12; i_0 <= 12; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerEta[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerEta[0]
								// output_left_conversion : TowerEta[i_0]
								// output_type_conversion : (TowerEta_lv0_12_12_2[hls_map_index++]).to_uint64()
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta[i_0] = (TowerEta_lv0_12_12_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerEta_12_pc_buffer;
		}

		// output port post check: "TowerEta_13"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_13, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_13, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_13, AESL_token); // data

			sc_bv<16> *TowerEta_13_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_13', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_13', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerEta_13_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_13, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerEta_13))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerEta_13
				{
					// bitslice(15, 0)
					// {
						// celement: TowerEta(15, 0)
						// {
							sc_lv<16>* TowerEta_lv0_13_13_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (13) => (13) @ (2)
							for (int i_0 = 13; i_0 <= 13; i_0 += 2)
							{
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta_lv0_13_13_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerEta_13_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (13) => (13) @ (2)
							for (int i_0 = 13; i_0 <= 13; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerEta[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerEta[0]
								// output_left_conversion : TowerEta[i_0]
								// output_type_conversion : (TowerEta_lv0_13_13_2[hls_map_index++]).to_uint64()
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta[i_0] = (TowerEta_lv0_13_13_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerEta_13_pc_buffer;
		}

		// output port post check: "TowerEta_14"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_14, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_14, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_14, AESL_token); // data

			sc_bv<16> *TowerEta_14_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_14', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_14', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerEta_14_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_14, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerEta_14))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerEta_14
				{
					// bitslice(15, 0)
					// {
						// celement: TowerEta(15, 0)
						// {
							sc_lv<16>* TowerEta_lv0_14_14_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (14) => (14) @ (2)
							for (int i_0 = 14; i_0 <= 14; i_0 += 2)
							{
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta_lv0_14_14_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerEta_14_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (14) => (14) @ (2)
							for (int i_0 = 14; i_0 <= 14; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerEta[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerEta[0]
								// output_left_conversion : TowerEta[i_0]
								// output_type_conversion : (TowerEta_lv0_14_14_2[hls_map_index++]).to_uint64()
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta[i_0] = (TowerEta_lv0_14_14_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerEta_14_pc_buffer;
		}

		// output port post check: "TowerEta_15"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_15, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_15, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_15, AESL_token); // data

			sc_bv<16> *TowerEta_15_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_15', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_15', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerEta_15_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_15, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerEta_15))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerEta_15
				{
					// bitslice(15, 0)
					// {
						// celement: TowerEta(15, 0)
						// {
							sc_lv<16>* TowerEta_lv0_15_15_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (15) => (15) @ (2)
							for (int i_0 = 15; i_0 <= 15; i_0 += 2)
							{
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta_lv0_15_15_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerEta_15_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (15) => (15) @ (2)
							for (int i_0 = 15; i_0 <= 15; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerEta[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerEta[0]
								// output_left_conversion : TowerEta[i_0]
								// output_type_conversion : (TowerEta_lv0_15_15_2[hls_map_index++]).to_uint64()
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta[i_0] = (TowerEta_lv0_15_15_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerEta_15_pc_buffer;
		}

		// output port post check: "TowerEta_16"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_16, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_16, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_16, AESL_token); // data

			sc_bv<16> *TowerEta_16_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_16', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_16', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerEta_16_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_16, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerEta_16))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerEta_16
				{
					// bitslice(15, 0)
					// {
						// celement: TowerEta(15, 0)
						// {
							sc_lv<16>* TowerEta_lv0_16_16_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (16) => (16) @ (2)
							for (int i_0 = 16; i_0 <= 16; i_0 += 2)
							{
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta_lv0_16_16_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerEta_16_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (16) => (16) @ (2)
							for (int i_0 = 16; i_0 <= 16; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerEta[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerEta[0]
								// output_left_conversion : TowerEta[i_0]
								// output_type_conversion : (TowerEta_lv0_16_16_2[hls_map_index++]).to_uint64()
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta[i_0] = (TowerEta_lv0_16_16_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerEta_16_pc_buffer;
		}

		// output port post check: "TowerEta_17"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_17, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_17, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_17, AESL_token); // data

			sc_bv<16> *TowerEta_17_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_17', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_17', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerEta_17_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_17, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerEta_17))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerEta_17
				{
					// bitslice(15, 0)
					// {
						// celement: TowerEta(15, 0)
						// {
							sc_lv<16>* TowerEta_lv0_17_17_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (17) => (17) @ (2)
							for (int i_0 = 17; i_0 <= 17; i_0 += 2)
							{
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta_lv0_17_17_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerEta_17_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (17) => (17) @ (2)
							for (int i_0 = 17; i_0 <= 17; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerEta[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerEta[0]
								// output_left_conversion : TowerEta[i_0]
								// output_type_conversion : (TowerEta_lv0_17_17_2[hls_map_index++]).to_uint64()
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta[i_0] = (TowerEta_lv0_17_17_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerEta_17_pc_buffer;
		}

		// output port post check: "TowerEta_18"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_18, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_18, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_18, AESL_token); // data

			sc_bv<16> *TowerEta_18_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_18', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_18', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerEta_18_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_18, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerEta_18))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerEta_18
				{
					// bitslice(15, 0)
					// {
						// celement: TowerEta(15, 0)
						// {
							sc_lv<16>* TowerEta_lv0_18_18_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (18) => (18) @ (2)
							for (int i_0 = 18; i_0 <= 18; i_0 += 2)
							{
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta_lv0_18_18_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerEta_18_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (18) => (18) @ (2)
							for (int i_0 = 18; i_0 <= 18; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerEta[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerEta[0]
								// output_left_conversion : TowerEta[i_0]
								// output_type_conversion : (TowerEta_lv0_18_18_2[hls_map_index++]).to_uint64()
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta[i_0] = (TowerEta_lv0_18_18_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerEta_18_pc_buffer;
		}

		// output port post check: "TowerEta_19"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_19, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_19, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_19, AESL_token); // data

			sc_bv<16> *TowerEta_19_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_19', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_19', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerEta_19_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_19, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerEta_19))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerEta_19
				{
					// bitslice(15, 0)
					// {
						// celement: TowerEta(15, 0)
						// {
							sc_lv<16>* TowerEta_lv0_19_19_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (19) => (19) @ (2)
							for (int i_0 = 19; i_0 <= 19; i_0 += 2)
							{
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta_lv0_19_19_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerEta_19_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (19) => (19) @ (2)
							for (int i_0 = 19; i_0 <= 19; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerEta[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerEta[0]
								// output_left_conversion : TowerEta[i_0]
								// output_type_conversion : (TowerEta_lv0_19_19_2[hls_map_index++]).to_uint64()
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta[i_0] = (TowerEta_lv0_19_19_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerEta_19_pc_buffer;
		}

		// output port post check: "TowerEta_20"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_20, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_20, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_20, AESL_token); // data

			sc_bv<16> *TowerEta_20_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_20', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_20', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerEta_20_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_20, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerEta_20))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerEta_20
				{
					// bitslice(15, 0)
					// {
						// celement: TowerEta(15, 0)
						// {
							sc_lv<16>* TowerEta_lv0_20_20_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (20) => (20) @ (2)
							for (int i_0 = 20; i_0 <= 20; i_0 += 2)
							{
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta_lv0_20_20_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerEta_20_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (20) => (20) @ (2)
							for (int i_0 = 20; i_0 <= 20; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerEta[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerEta[0]
								// output_left_conversion : TowerEta[i_0]
								// output_type_conversion : (TowerEta_lv0_20_20_2[hls_map_index++]).to_uint64()
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta[i_0] = (TowerEta_lv0_20_20_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerEta_20_pc_buffer;
		}

		// output port post check: "TowerEta_21"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_21, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_21, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_21, AESL_token); // data

			sc_bv<16> *TowerEta_21_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_21', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_21', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerEta_21_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_21, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerEta_21))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerEta_21
				{
					// bitslice(15, 0)
					// {
						// celement: TowerEta(15, 0)
						// {
							sc_lv<16>* TowerEta_lv0_21_21_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (21) => (21) @ (2)
							for (int i_0 = 21; i_0 <= 21; i_0 += 2)
							{
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta_lv0_21_21_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerEta_21_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (21) => (21) @ (2)
							for (int i_0 = 21; i_0 <= 21; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerEta[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerEta[0]
								// output_left_conversion : TowerEta[i_0]
								// output_type_conversion : (TowerEta_lv0_21_21_2[hls_map_index++]).to_uint64()
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta[i_0] = (TowerEta_lv0_21_21_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerEta_21_pc_buffer;
		}

		// output port post check: "TowerEta_22"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_22, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_22, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_22, AESL_token); // data

			sc_bv<16> *TowerEta_22_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_22', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_22', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerEta_22_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_22, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerEta_22))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerEta_22
				{
					// bitslice(15, 0)
					// {
						// celement: TowerEta(15, 0)
						// {
							sc_lv<16>* TowerEta_lv0_22_22_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (22) => (22) @ (2)
							for (int i_0 = 22; i_0 <= 22; i_0 += 2)
							{
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta_lv0_22_22_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerEta_22_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (22) => (22) @ (2)
							for (int i_0 = 22; i_0 <= 22; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerEta[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerEta[0]
								// output_left_conversion : TowerEta[i_0]
								// output_type_conversion : (TowerEta_lv0_22_22_2[hls_map_index++]).to_uint64()
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta[i_0] = (TowerEta_lv0_22_22_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerEta_22_pc_buffer;
		}

		// output port post check: "TowerEta_23"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_23, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_23, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_23, AESL_token); // data

			sc_bv<16> *TowerEta_23_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_23', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_23', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerEta_23_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_23, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerEta_23))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerEta_23
				{
					// bitslice(15, 0)
					// {
						// celement: TowerEta(15, 0)
						// {
							sc_lv<16>* TowerEta_lv0_23_23_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (23) => (23) @ (2)
							for (int i_0 = 23; i_0 <= 23; i_0 += 2)
							{
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta_lv0_23_23_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerEta_23_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (23) => (23) @ (2)
							for (int i_0 = 23; i_0 <= 23; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerEta[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerEta[0]
								// output_left_conversion : TowerEta[i_0]
								// output_type_conversion : (TowerEta_lv0_23_23_2[hls_map_index++]).to_uint64()
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta[i_0] = (TowerEta_lv0_23_23_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerEta_23_pc_buffer;
		}

		// output port post check: "TowerEta_24"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_24, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_24, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_24, AESL_token); // data

			sc_bv<16> *TowerEta_24_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_24', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_24', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerEta_24_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_24, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerEta_24))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerEta_24
				{
					// bitslice(15, 0)
					// {
						// celement: TowerEta(15, 0)
						// {
							sc_lv<16>* TowerEta_lv0_24_24_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (24) => (24) @ (2)
							for (int i_0 = 24; i_0 <= 24; i_0 += 2)
							{
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta_lv0_24_24_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerEta_24_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (24) => (24) @ (2)
							for (int i_0 = 24; i_0 <= 24; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerEta[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerEta[0]
								// output_left_conversion : TowerEta[i_0]
								// output_type_conversion : (TowerEta_lv0_24_24_2[hls_map_index++]).to_uint64()
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta[i_0] = (TowerEta_lv0_24_24_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerEta_24_pc_buffer;
		}

		// output port post check: "TowerEta_25"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_25, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_25, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_25, AESL_token); // data

			sc_bv<16> *TowerEta_25_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_25', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_25', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerEta_25_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_25, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerEta_25))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerEta_25
				{
					// bitslice(15, 0)
					// {
						// celement: TowerEta(15, 0)
						// {
							sc_lv<16>* TowerEta_lv0_25_25_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (25) => (25) @ (2)
							for (int i_0 = 25; i_0 <= 25; i_0 += 2)
							{
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta_lv0_25_25_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerEta_25_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (25) => (25) @ (2)
							for (int i_0 = 25; i_0 <= 25; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerEta[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerEta[0]
								// output_left_conversion : TowerEta[i_0]
								// output_type_conversion : (TowerEta_lv0_25_25_2[hls_map_index++]).to_uint64()
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta[i_0] = (TowerEta_lv0_25_25_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerEta_25_pc_buffer;
		}

		// output port post check: "TowerEta_26"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_26, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_26, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_26, AESL_token); // data

			sc_bv<16> *TowerEta_26_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_26', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_26', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerEta_26_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_26, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerEta_26))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerEta_26
				{
					// bitslice(15, 0)
					// {
						// celement: TowerEta(15, 0)
						// {
							sc_lv<16>* TowerEta_lv0_26_26_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (26) => (26) @ (2)
							for (int i_0 = 26; i_0 <= 26; i_0 += 2)
							{
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta_lv0_26_26_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerEta_26_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (26) => (26) @ (2)
							for (int i_0 = 26; i_0 <= 26; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerEta[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerEta[0]
								// output_left_conversion : TowerEta[i_0]
								// output_type_conversion : (TowerEta_lv0_26_26_2[hls_map_index++]).to_uint64()
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta[i_0] = (TowerEta_lv0_26_26_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerEta_26_pc_buffer;
		}

		// output port post check: "TowerEta_27"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_27, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_27, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_27, AESL_token); // data

			sc_bv<16> *TowerEta_27_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_27', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_27', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerEta_27_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_27, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerEta_27))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerEta_27
				{
					// bitslice(15, 0)
					// {
						// celement: TowerEta(15, 0)
						// {
							sc_lv<16>* TowerEta_lv0_27_27_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (27) => (27) @ (2)
							for (int i_0 = 27; i_0 <= 27; i_0 += 2)
							{
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta_lv0_27_27_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerEta_27_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (27) => (27) @ (2)
							for (int i_0 = 27; i_0 <= 27; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerEta[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerEta[0]
								// output_left_conversion : TowerEta[i_0]
								// output_type_conversion : (TowerEta_lv0_27_27_2[hls_map_index++]).to_uint64()
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta[i_0] = (TowerEta_lv0_27_27_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerEta_27_pc_buffer;
		}

		// output port post check: "TowerEta_28"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_28, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_28, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_28, AESL_token); // data

			sc_bv<16> *TowerEta_28_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_28', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_28', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerEta_28_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_28, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerEta_28))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerEta_28
				{
					// bitslice(15, 0)
					// {
						// celement: TowerEta(15, 0)
						// {
							sc_lv<16>* TowerEta_lv0_28_28_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (28) => (28) @ (2)
							for (int i_0 = 28; i_0 <= 28; i_0 += 2)
							{
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta_lv0_28_28_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerEta_28_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (28) => (28) @ (2)
							for (int i_0 = 28; i_0 <= 28; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerEta[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerEta[0]
								// output_left_conversion : TowerEta[i_0]
								// output_type_conversion : (TowerEta_lv0_28_28_2[hls_map_index++]).to_uint64()
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta[i_0] = (TowerEta_lv0_28_28_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerEta_28_pc_buffer;
		}

		// output port post check: "TowerEta_29"
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_29, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_29, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_29, AESL_token); // data

			sc_bv<16> *TowerEta_29_pc_buffer = new sc_bv<16>[1];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_29', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "WARNING: [SIM 212-201] RTL produces unknown value 'X' on port 'TowerEta_29', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					TowerEta_29_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_TowerEta_29, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_TowerEta_29))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				// RTL Name: TowerEta_29
				{
					// bitslice(15, 0)
					// {
						// celement: TowerEta(15, 0)
						// {
							sc_lv<16>* TowerEta_lv0_29_29_2 = new sc_lv<16>[1];
						// }
					// }

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (29) => (29) @ (2)
							for (int i_0 = 29; i_0 <= 29; i_0 += 2)
							{
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta_lv0_29_29_2[hls_map_index++].range(15, 0) = sc_bv<16>(TowerEta_29_pc_buffer[hls_map_index].range(15, 0));
								}
							}
						}
					}

					// bitslice(15, 0)
					{
						int hls_map_index = 0;
						// celement: TowerEta(15, 0)
						{
							// carray: (29) => (29) @ (2)
							for (int i_0 = 29; i_0 <= 29; i_0 += 2)
							{
								// sub                    : i_0
								// ori_name               : TowerEta[i_0]
								// sub_1st_elem           : 0
								// ori_name_1st_elem      : TowerEta[0]
								// output_left_conversion : TowerEta[i_0]
								// output_type_conversion : (TowerEta_lv0_29_29_2[hls_map_index++]).to_uint64()
								if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
								{
									TowerEta[i_0] = (TowerEta_lv0_29_29_2[hls_map_index++]).to_uint64();
								}
							}
						}
					}
				}
			}

			// release memory allocation
			delete [] TowerEta_29_pc_buffer;
		}

		AESL_transaction_pc++;
	}
	else
	{
		CodeState = ENTER_WRAPC;
		static unsigned AESL_transaction;

		static AESL_FILE_HANDLER aesl_fh;

		// "towerET_0_0"
		char* tvin_towerET_0_0 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_0_0);

		// "towerET_0_1"
		char* tvin_towerET_0_1 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_0_1);

		// "towerET_0_2"
		char* tvin_towerET_0_2 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_0_2);

		// "towerET_0_3"
		char* tvin_towerET_0_3 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_0_3);

		// "towerET_1_0"
		char* tvin_towerET_1_0 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_1_0);

		// "towerET_1_1"
		char* tvin_towerET_1_1 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_1_1);

		// "towerET_1_2"
		char* tvin_towerET_1_2 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_1_2);

		// "towerET_1_3"
		char* tvin_towerET_1_3 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_1_3);

		// "towerET_2_0"
		char* tvin_towerET_2_0 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_2_0);

		// "towerET_2_1"
		char* tvin_towerET_2_1 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_2_1);

		// "towerET_2_2"
		char* tvin_towerET_2_2 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_2_2);

		// "towerET_2_3"
		char* tvin_towerET_2_3 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_2_3);

		// "towerET_3_0"
		char* tvin_towerET_3_0 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_3_0);

		// "towerET_3_1"
		char* tvin_towerET_3_1 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_3_1);

		// "towerET_3_2"
		char* tvin_towerET_3_2 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_3_2);

		// "towerET_3_3"
		char* tvin_towerET_3_3 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_3_3);

		// "towerET_4_0"
		char* tvin_towerET_4_0 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_4_0);

		// "towerET_4_1"
		char* tvin_towerET_4_1 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_4_1);

		// "towerET_4_2"
		char* tvin_towerET_4_2 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_4_2);

		// "towerET_4_3"
		char* tvin_towerET_4_3 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_4_3);

		// "towerET_5_0"
		char* tvin_towerET_5_0 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_5_0);

		// "towerET_5_1"
		char* tvin_towerET_5_1 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_5_1);

		// "towerET_5_2"
		char* tvin_towerET_5_2 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_5_2);

		// "towerET_5_3"
		char* tvin_towerET_5_3 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_5_3);

		// "towerET_6_0"
		char* tvin_towerET_6_0 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_6_0);

		// "towerET_6_1"
		char* tvin_towerET_6_1 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_6_1);

		// "towerET_6_2"
		char* tvin_towerET_6_2 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_6_2);

		// "towerET_6_3"
		char* tvin_towerET_6_3 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_6_3);

		// "towerET_7_0"
		char* tvin_towerET_7_0 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_7_0);

		// "towerET_7_1"
		char* tvin_towerET_7_1 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_7_1);

		// "towerET_7_2"
		char* tvin_towerET_7_2 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_7_2);

		// "towerET_7_3"
		char* tvin_towerET_7_3 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_7_3);

		// "towerET_8_0"
		char* tvin_towerET_8_0 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_8_0);

		// "towerET_8_1"
		char* tvin_towerET_8_1 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_8_1);

		// "towerET_8_2"
		char* tvin_towerET_8_2 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_8_2);

		// "towerET_8_3"
		char* tvin_towerET_8_3 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_8_3);

		// "towerET_9_0"
		char* tvin_towerET_9_0 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_9_0);

		// "towerET_9_1"
		char* tvin_towerET_9_1 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_9_1);

		// "towerET_9_2"
		char* tvin_towerET_9_2 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_9_2);

		// "towerET_9_3"
		char* tvin_towerET_9_3 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_9_3);

		// "towerET_10_0"
		char* tvin_towerET_10_0 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_10_0);

		// "towerET_10_1"
		char* tvin_towerET_10_1 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_10_1);

		// "towerET_10_2"
		char* tvin_towerET_10_2 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_10_2);

		// "towerET_10_3"
		char* tvin_towerET_10_3 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_10_3);

		// "towerET_11_0"
		char* tvin_towerET_11_0 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_11_0);

		// "towerET_11_1"
		char* tvin_towerET_11_1 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_11_1);

		// "towerET_11_2"
		char* tvin_towerET_11_2 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_11_2);

		// "towerET_11_3"
		char* tvin_towerET_11_3 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_11_3);

		// "towerET_12_0"
		char* tvin_towerET_12_0 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_12_0);

		// "towerET_12_1"
		char* tvin_towerET_12_1 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_12_1);

		// "towerET_12_2"
		char* tvin_towerET_12_2 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_12_2);

		// "towerET_12_3"
		char* tvin_towerET_12_3 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_12_3);

		// "towerET_13_0"
		char* tvin_towerET_13_0 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_13_0);

		// "towerET_13_1"
		char* tvin_towerET_13_1 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_13_1);

		// "towerET_13_2"
		char* tvin_towerET_13_2 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_13_2);

		// "towerET_13_3"
		char* tvin_towerET_13_3 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_13_3);

		// "towerET_14_0"
		char* tvin_towerET_14_0 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_14_0);

		// "towerET_14_1"
		char* tvin_towerET_14_1 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_14_1);

		// "towerET_14_2"
		char* tvin_towerET_14_2 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_14_2);

		// "towerET_14_3"
		char* tvin_towerET_14_3 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_14_3);

		// "towerET_15_0"
		char* tvin_towerET_15_0 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_15_0);

		// "towerET_15_1"
		char* tvin_towerET_15_1 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_15_1);

		// "towerET_15_2"
		char* tvin_towerET_15_2 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_15_2);

		// "towerET_15_3"
		char* tvin_towerET_15_3 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_15_3);

		// "towerET_16_0"
		char* tvin_towerET_16_0 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_16_0);

		// "towerET_16_1"
		char* tvin_towerET_16_1 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_16_1);

		// "towerET_16_2"
		char* tvin_towerET_16_2 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_16_2);

		// "towerET_16_3"
		char* tvin_towerET_16_3 = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_towerET_16_3);

		// "TowerPhi_0"
		char* tvout_TowerPhi_0 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerPhi_0);

		// "TowerPhi_1"
		char* tvout_TowerPhi_1 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerPhi_1);

		// "TowerPhi_2"
		char* tvout_TowerPhi_2 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerPhi_2);

		// "TowerPhi_3"
		char* tvout_TowerPhi_3 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerPhi_3);

		// "TowerPhi_4"
		char* tvout_TowerPhi_4 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerPhi_4);

		// "TowerPhi_5"
		char* tvout_TowerPhi_5 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerPhi_5);

		// "TowerPhi_6"
		char* tvout_TowerPhi_6 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerPhi_6);

		// "TowerPhi_7"
		char* tvout_TowerPhi_7 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerPhi_7);

		// "TowerPhi_8"
		char* tvout_TowerPhi_8 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerPhi_8);

		// "TowerPhi_9"
		char* tvout_TowerPhi_9 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerPhi_9);

		// "TowerPhi_10"
		char* tvout_TowerPhi_10 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerPhi_10);

		// "TowerPhi_11"
		char* tvout_TowerPhi_11 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerPhi_11);

		// "TowerPhi_12"
		char* tvout_TowerPhi_12 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerPhi_12);

		// "TowerPhi_13"
		char* tvout_TowerPhi_13 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerPhi_13);

		// "TowerPhi_14"
		char* tvout_TowerPhi_14 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerPhi_14);

		// "TowerPhi_15"
		char* tvout_TowerPhi_15 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerPhi_15);

		// "TowerPhi_16"
		char* tvout_TowerPhi_16 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerPhi_16);

		// "TowerPhi_17"
		char* tvout_TowerPhi_17 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerPhi_17);

		// "TowerPhi_18"
		char* tvout_TowerPhi_18 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerPhi_18);

		// "TowerPhi_19"
		char* tvout_TowerPhi_19 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerPhi_19);

		// "TowerPhi_20"
		char* tvout_TowerPhi_20 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerPhi_20);

		// "TowerPhi_21"
		char* tvout_TowerPhi_21 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerPhi_21);

		// "TowerPhi_22"
		char* tvout_TowerPhi_22 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerPhi_22);

		// "TowerPhi_23"
		char* tvout_TowerPhi_23 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerPhi_23);

		// "TowerPhi_24"
		char* tvout_TowerPhi_24 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerPhi_24);

		// "TowerPhi_25"
		char* tvout_TowerPhi_25 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerPhi_25);

		// "TowerPhi_26"
		char* tvout_TowerPhi_26 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerPhi_26);

		// "TowerPhi_27"
		char* tvout_TowerPhi_27 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerPhi_27);

		// "TowerPhi_28"
		char* tvout_TowerPhi_28 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerPhi_28);

		// "TowerPhi_29"
		char* tvout_TowerPhi_29 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerPhi_29);

		// "TowerEta_0"
		char* tvout_TowerEta_0 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerEta_0);

		// "TowerEta_1"
		char* tvout_TowerEta_1 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerEta_1);

		// "TowerEta_2"
		char* tvout_TowerEta_2 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerEta_2);

		// "TowerEta_3"
		char* tvout_TowerEta_3 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerEta_3);

		// "TowerEta_4"
		char* tvout_TowerEta_4 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerEta_4);

		// "TowerEta_5"
		char* tvout_TowerEta_5 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerEta_5);

		// "TowerEta_6"
		char* tvout_TowerEta_6 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerEta_6);

		// "TowerEta_7"
		char* tvout_TowerEta_7 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerEta_7);

		// "TowerEta_8"
		char* tvout_TowerEta_8 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerEta_8);

		// "TowerEta_9"
		char* tvout_TowerEta_9 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerEta_9);

		// "TowerEta_10"
		char* tvout_TowerEta_10 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerEta_10);

		// "TowerEta_11"
		char* tvout_TowerEta_11 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerEta_11);

		// "TowerEta_12"
		char* tvout_TowerEta_12 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerEta_12);

		// "TowerEta_13"
		char* tvout_TowerEta_13 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerEta_13);

		// "TowerEta_14"
		char* tvout_TowerEta_14 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerEta_14);

		// "TowerEta_15"
		char* tvout_TowerEta_15 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerEta_15);

		// "TowerEta_16"
		char* tvout_TowerEta_16 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerEta_16);

		// "TowerEta_17"
		char* tvout_TowerEta_17 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerEta_17);

		// "TowerEta_18"
		char* tvout_TowerEta_18 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerEta_18);

		// "TowerEta_19"
		char* tvout_TowerEta_19 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerEta_19);

		// "TowerEta_20"
		char* tvout_TowerEta_20 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerEta_20);

		// "TowerEta_21"
		char* tvout_TowerEta_21 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerEta_21);

		// "TowerEta_22"
		char* tvout_TowerEta_22 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerEta_22);

		// "TowerEta_23"
		char* tvout_TowerEta_23 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerEta_23);

		// "TowerEta_24"
		char* tvout_TowerEta_24 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerEta_24);

		// "TowerEta_25"
		char* tvout_TowerEta_25 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerEta_25);

		// "TowerEta_26"
		char* tvout_TowerEta_26 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerEta_26);

		// "TowerEta_27"
		char* tvout_TowerEta_27 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerEta_27);

		// "TowerEta_28"
		char* tvout_TowerEta_28 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerEta_28);

		// "TowerEta_29"
		char* tvout_TowerEta_29 = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_TowerEta_29);

		CodeState = DUMP_INPUTS;
		static INTER_TCL_FILE tcl_file(INTER_TCL);
		int leading_zero;

		// [[transaction]]
		sprintf(tvin_towerET_0_0, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_0_0, tvin_towerET_0_0);

		sc_bv<16>* towerET_0_0_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_0_0
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (0) => (0) @ (2)
					for (int i_0 = 0; i_0 <= 0; i_0 += 2)
					{
						// carray: (0) => (0) @ (2)
						for (int i_1 = 0; i_1 <= 0; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_0_0_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_0_0, "%s\n", (towerET_0_0_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_0_0, tvin_towerET_0_0);
		}

		tcl_file.set_num(1, &tcl_file.towerET_0_0_depth);
		sprintf(tvin_towerET_0_0, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_0_0, tvin_towerET_0_0);

		// release memory allocation
		delete [] towerET_0_0_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_0_1, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_0_1, tvin_towerET_0_1);

		sc_bv<16>* towerET_0_1_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_0_1
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (0) => (0) @ (2)
					for (int i_0 = 0; i_0 <= 0; i_0 += 2)
					{
						// carray: (1) => (1) @ (2)
						for (int i_1 = 1; i_1 <= 1; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_0_1_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_0_1, "%s\n", (towerET_0_1_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_0_1, tvin_towerET_0_1);
		}

		tcl_file.set_num(1, &tcl_file.towerET_0_1_depth);
		sprintf(tvin_towerET_0_1, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_0_1, tvin_towerET_0_1);

		// release memory allocation
		delete [] towerET_0_1_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_0_2, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_0_2, tvin_towerET_0_2);

		sc_bv<16>* towerET_0_2_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_0_2
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (0) => (0) @ (2)
					for (int i_0 = 0; i_0 <= 0; i_0 += 2)
					{
						// carray: (2) => (2) @ (2)
						for (int i_1 = 2; i_1 <= 2; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_0_2_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_0_2, "%s\n", (towerET_0_2_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_0_2, tvin_towerET_0_2);
		}

		tcl_file.set_num(1, &tcl_file.towerET_0_2_depth);
		sprintf(tvin_towerET_0_2, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_0_2, tvin_towerET_0_2);

		// release memory allocation
		delete [] towerET_0_2_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_0_3, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_0_3, tvin_towerET_0_3);

		sc_bv<16>* towerET_0_3_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_0_3
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (0) => (0) @ (2)
					for (int i_0 = 0; i_0 <= 0; i_0 += 2)
					{
						// carray: (3) => (3) @ (2)
						for (int i_1 = 3; i_1 <= 3; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_0_3_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_0_3, "%s\n", (towerET_0_3_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_0_3, tvin_towerET_0_3);
		}

		tcl_file.set_num(1, &tcl_file.towerET_0_3_depth);
		sprintf(tvin_towerET_0_3, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_0_3, tvin_towerET_0_3);

		// release memory allocation
		delete [] towerET_0_3_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_1_0, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_1_0, tvin_towerET_1_0);

		sc_bv<16>* towerET_1_0_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_1_0
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (1) => (1) @ (2)
					for (int i_0 = 1; i_0 <= 1; i_0 += 2)
					{
						// carray: (0) => (0) @ (2)
						for (int i_1 = 0; i_1 <= 0; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_1_0_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_1_0, "%s\n", (towerET_1_0_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_1_0, tvin_towerET_1_0);
		}

		tcl_file.set_num(1, &tcl_file.towerET_1_0_depth);
		sprintf(tvin_towerET_1_0, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_1_0, tvin_towerET_1_0);

		// release memory allocation
		delete [] towerET_1_0_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_1_1, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_1_1, tvin_towerET_1_1);

		sc_bv<16>* towerET_1_1_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_1_1
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (1) => (1) @ (2)
					for (int i_0 = 1; i_0 <= 1; i_0 += 2)
					{
						// carray: (1) => (1) @ (2)
						for (int i_1 = 1; i_1 <= 1; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_1_1_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_1_1, "%s\n", (towerET_1_1_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_1_1, tvin_towerET_1_1);
		}

		tcl_file.set_num(1, &tcl_file.towerET_1_1_depth);
		sprintf(tvin_towerET_1_1, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_1_1, tvin_towerET_1_1);

		// release memory allocation
		delete [] towerET_1_1_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_1_2, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_1_2, tvin_towerET_1_2);

		sc_bv<16>* towerET_1_2_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_1_2
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (1) => (1) @ (2)
					for (int i_0 = 1; i_0 <= 1; i_0 += 2)
					{
						// carray: (2) => (2) @ (2)
						for (int i_1 = 2; i_1 <= 2; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_1_2_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_1_2, "%s\n", (towerET_1_2_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_1_2, tvin_towerET_1_2);
		}

		tcl_file.set_num(1, &tcl_file.towerET_1_2_depth);
		sprintf(tvin_towerET_1_2, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_1_2, tvin_towerET_1_2);

		// release memory allocation
		delete [] towerET_1_2_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_1_3, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_1_3, tvin_towerET_1_3);

		sc_bv<16>* towerET_1_3_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_1_3
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (1) => (1) @ (2)
					for (int i_0 = 1; i_0 <= 1; i_0 += 2)
					{
						// carray: (3) => (3) @ (2)
						for (int i_1 = 3; i_1 <= 3; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_1_3_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_1_3, "%s\n", (towerET_1_3_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_1_3, tvin_towerET_1_3);
		}

		tcl_file.set_num(1, &tcl_file.towerET_1_3_depth);
		sprintf(tvin_towerET_1_3, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_1_3, tvin_towerET_1_3);

		// release memory allocation
		delete [] towerET_1_3_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_2_0, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_2_0, tvin_towerET_2_0);

		sc_bv<16>* towerET_2_0_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_2_0
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (2) => (2) @ (2)
					for (int i_0 = 2; i_0 <= 2; i_0 += 2)
					{
						// carray: (0) => (0) @ (2)
						for (int i_1 = 0; i_1 <= 0; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_2_0_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_2_0, "%s\n", (towerET_2_0_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_2_0, tvin_towerET_2_0);
		}

		tcl_file.set_num(1, &tcl_file.towerET_2_0_depth);
		sprintf(tvin_towerET_2_0, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_2_0, tvin_towerET_2_0);

		// release memory allocation
		delete [] towerET_2_0_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_2_1, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_2_1, tvin_towerET_2_1);

		sc_bv<16>* towerET_2_1_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_2_1
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (2) => (2) @ (2)
					for (int i_0 = 2; i_0 <= 2; i_0 += 2)
					{
						// carray: (1) => (1) @ (2)
						for (int i_1 = 1; i_1 <= 1; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_2_1_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_2_1, "%s\n", (towerET_2_1_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_2_1, tvin_towerET_2_1);
		}

		tcl_file.set_num(1, &tcl_file.towerET_2_1_depth);
		sprintf(tvin_towerET_2_1, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_2_1, tvin_towerET_2_1);

		// release memory allocation
		delete [] towerET_2_1_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_2_2, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_2_2, tvin_towerET_2_2);

		sc_bv<16>* towerET_2_2_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_2_2
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (2) => (2) @ (2)
					for (int i_0 = 2; i_0 <= 2; i_0 += 2)
					{
						// carray: (2) => (2) @ (2)
						for (int i_1 = 2; i_1 <= 2; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_2_2_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_2_2, "%s\n", (towerET_2_2_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_2_2, tvin_towerET_2_2);
		}

		tcl_file.set_num(1, &tcl_file.towerET_2_2_depth);
		sprintf(tvin_towerET_2_2, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_2_2, tvin_towerET_2_2);

		// release memory allocation
		delete [] towerET_2_2_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_2_3, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_2_3, tvin_towerET_2_3);

		sc_bv<16>* towerET_2_3_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_2_3
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (2) => (2) @ (2)
					for (int i_0 = 2; i_0 <= 2; i_0 += 2)
					{
						// carray: (3) => (3) @ (2)
						for (int i_1 = 3; i_1 <= 3; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_2_3_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_2_3, "%s\n", (towerET_2_3_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_2_3, tvin_towerET_2_3);
		}

		tcl_file.set_num(1, &tcl_file.towerET_2_3_depth);
		sprintf(tvin_towerET_2_3, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_2_3, tvin_towerET_2_3);

		// release memory allocation
		delete [] towerET_2_3_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_3_0, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_3_0, tvin_towerET_3_0);

		sc_bv<16>* towerET_3_0_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_3_0
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (3) => (3) @ (2)
					for (int i_0 = 3; i_0 <= 3; i_0 += 2)
					{
						// carray: (0) => (0) @ (2)
						for (int i_1 = 0; i_1 <= 0; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_3_0_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_3_0, "%s\n", (towerET_3_0_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_3_0, tvin_towerET_3_0);
		}

		tcl_file.set_num(1, &tcl_file.towerET_3_0_depth);
		sprintf(tvin_towerET_3_0, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_3_0, tvin_towerET_3_0);

		// release memory allocation
		delete [] towerET_3_0_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_3_1, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_3_1, tvin_towerET_3_1);

		sc_bv<16>* towerET_3_1_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_3_1
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (3) => (3) @ (2)
					for (int i_0 = 3; i_0 <= 3; i_0 += 2)
					{
						// carray: (1) => (1) @ (2)
						for (int i_1 = 1; i_1 <= 1; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_3_1_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_3_1, "%s\n", (towerET_3_1_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_3_1, tvin_towerET_3_1);
		}

		tcl_file.set_num(1, &tcl_file.towerET_3_1_depth);
		sprintf(tvin_towerET_3_1, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_3_1, tvin_towerET_3_1);

		// release memory allocation
		delete [] towerET_3_1_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_3_2, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_3_2, tvin_towerET_3_2);

		sc_bv<16>* towerET_3_2_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_3_2
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (3) => (3) @ (2)
					for (int i_0 = 3; i_0 <= 3; i_0 += 2)
					{
						// carray: (2) => (2) @ (2)
						for (int i_1 = 2; i_1 <= 2; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_3_2_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_3_2, "%s\n", (towerET_3_2_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_3_2, tvin_towerET_3_2);
		}

		tcl_file.set_num(1, &tcl_file.towerET_3_2_depth);
		sprintf(tvin_towerET_3_2, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_3_2, tvin_towerET_3_2);

		// release memory allocation
		delete [] towerET_3_2_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_3_3, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_3_3, tvin_towerET_3_3);

		sc_bv<16>* towerET_3_3_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_3_3
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (3) => (3) @ (2)
					for (int i_0 = 3; i_0 <= 3; i_0 += 2)
					{
						// carray: (3) => (3) @ (2)
						for (int i_1 = 3; i_1 <= 3; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_3_3_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_3_3, "%s\n", (towerET_3_3_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_3_3, tvin_towerET_3_3);
		}

		tcl_file.set_num(1, &tcl_file.towerET_3_3_depth);
		sprintf(tvin_towerET_3_3, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_3_3, tvin_towerET_3_3);

		// release memory allocation
		delete [] towerET_3_3_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_4_0, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_4_0, tvin_towerET_4_0);

		sc_bv<16>* towerET_4_0_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_4_0
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (4) => (4) @ (2)
					for (int i_0 = 4; i_0 <= 4; i_0 += 2)
					{
						// carray: (0) => (0) @ (2)
						for (int i_1 = 0; i_1 <= 0; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_4_0_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_4_0, "%s\n", (towerET_4_0_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_4_0, tvin_towerET_4_0);
		}

		tcl_file.set_num(1, &tcl_file.towerET_4_0_depth);
		sprintf(tvin_towerET_4_0, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_4_0, tvin_towerET_4_0);

		// release memory allocation
		delete [] towerET_4_0_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_4_1, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_4_1, tvin_towerET_4_1);

		sc_bv<16>* towerET_4_1_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_4_1
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (4) => (4) @ (2)
					for (int i_0 = 4; i_0 <= 4; i_0 += 2)
					{
						// carray: (1) => (1) @ (2)
						for (int i_1 = 1; i_1 <= 1; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_4_1_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_4_1, "%s\n", (towerET_4_1_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_4_1, tvin_towerET_4_1);
		}

		tcl_file.set_num(1, &tcl_file.towerET_4_1_depth);
		sprintf(tvin_towerET_4_1, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_4_1, tvin_towerET_4_1);

		// release memory allocation
		delete [] towerET_4_1_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_4_2, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_4_2, tvin_towerET_4_2);

		sc_bv<16>* towerET_4_2_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_4_2
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (4) => (4) @ (2)
					for (int i_0 = 4; i_0 <= 4; i_0 += 2)
					{
						// carray: (2) => (2) @ (2)
						for (int i_1 = 2; i_1 <= 2; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_4_2_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_4_2, "%s\n", (towerET_4_2_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_4_2, tvin_towerET_4_2);
		}

		tcl_file.set_num(1, &tcl_file.towerET_4_2_depth);
		sprintf(tvin_towerET_4_2, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_4_2, tvin_towerET_4_2);

		// release memory allocation
		delete [] towerET_4_2_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_4_3, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_4_3, tvin_towerET_4_3);

		sc_bv<16>* towerET_4_3_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_4_3
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (4) => (4) @ (2)
					for (int i_0 = 4; i_0 <= 4; i_0 += 2)
					{
						// carray: (3) => (3) @ (2)
						for (int i_1 = 3; i_1 <= 3; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_4_3_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_4_3, "%s\n", (towerET_4_3_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_4_3, tvin_towerET_4_3);
		}

		tcl_file.set_num(1, &tcl_file.towerET_4_3_depth);
		sprintf(tvin_towerET_4_3, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_4_3, tvin_towerET_4_3);

		// release memory allocation
		delete [] towerET_4_3_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_5_0, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_5_0, tvin_towerET_5_0);

		sc_bv<16>* towerET_5_0_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_5_0
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (5) => (5) @ (2)
					for (int i_0 = 5; i_0 <= 5; i_0 += 2)
					{
						// carray: (0) => (0) @ (2)
						for (int i_1 = 0; i_1 <= 0; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_5_0_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_5_0, "%s\n", (towerET_5_0_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_5_0, tvin_towerET_5_0);
		}

		tcl_file.set_num(1, &tcl_file.towerET_5_0_depth);
		sprintf(tvin_towerET_5_0, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_5_0, tvin_towerET_5_0);

		// release memory allocation
		delete [] towerET_5_0_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_5_1, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_5_1, tvin_towerET_5_1);

		sc_bv<16>* towerET_5_1_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_5_1
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (5) => (5) @ (2)
					for (int i_0 = 5; i_0 <= 5; i_0 += 2)
					{
						// carray: (1) => (1) @ (2)
						for (int i_1 = 1; i_1 <= 1; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_5_1_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_5_1, "%s\n", (towerET_5_1_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_5_1, tvin_towerET_5_1);
		}

		tcl_file.set_num(1, &tcl_file.towerET_5_1_depth);
		sprintf(tvin_towerET_5_1, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_5_1, tvin_towerET_5_1);

		// release memory allocation
		delete [] towerET_5_1_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_5_2, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_5_2, tvin_towerET_5_2);

		sc_bv<16>* towerET_5_2_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_5_2
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (5) => (5) @ (2)
					for (int i_0 = 5; i_0 <= 5; i_0 += 2)
					{
						// carray: (2) => (2) @ (2)
						for (int i_1 = 2; i_1 <= 2; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_5_2_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_5_2, "%s\n", (towerET_5_2_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_5_2, tvin_towerET_5_2);
		}

		tcl_file.set_num(1, &tcl_file.towerET_5_2_depth);
		sprintf(tvin_towerET_5_2, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_5_2, tvin_towerET_5_2);

		// release memory allocation
		delete [] towerET_5_2_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_5_3, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_5_3, tvin_towerET_5_3);

		sc_bv<16>* towerET_5_3_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_5_3
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (5) => (5) @ (2)
					for (int i_0 = 5; i_0 <= 5; i_0 += 2)
					{
						// carray: (3) => (3) @ (2)
						for (int i_1 = 3; i_1 <= 3; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_5_3_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_5_3, "%s\n", (towerET_5_3_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_5_3, tvin_towerET_5_3);
		}

		tcl_file.set_num(1, &tcl_file.towerET_5_3_depth);
		sprintf(tvin_towerET_5_3, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_5_3, tvin_towerET_5_3);

		// release memory allocation
		delete [] towerET_5_3_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_6_0, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_6_0, tvin_towerET_6_0);

		sc_bv<16>* towerET_6_0_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_6_0
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (6) => (6) @ (2)
					for (int i_0 = 6; i_0 <= 6; i_0 += 2)
					{
						// carray: (0) => (0) @ (2)
						for (int i_1 = 0; i_1 <= 0; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_6_0_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_6_0, "%s\n", (towerET_6_0_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_6_0, tvin_towerET_6_0);
		}

		tcl_file.set_num(1, &tcl_file.towerET_6_0_depth);
		sprintf(tvin_towerET_6_0, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_6_0, tvin_towerET_6_0);

		// release memory allocation
		delete [] towerET_6_0_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_6_1, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_6_1, tvin_towerET_6_1);

		sc_bv<16>* towerET_6_1_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_6_1
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (6) => (6) @ (2)
					for (int i_0 = 6; i_0 <= 6; i_0 += 2)
					{
						// carray: (1) => (1) @ (2)
						for (int i_1 = 1; i_1 <= 1; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_6_1_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_6_1, "%s\n", (towerET_6_1_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_6_1, tvin_towerET_6_1);
		}

		tcl_file.set_num(1, &tcl_file.towerET_6_1_depth);
		sprintf(tvin_towerET_6_1, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_6_1, tvin_towerET_6_1);

		// release memory allocation
		delete [] towerET_6_1_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_6_2, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_6_2, tvin_towerET_6_2);

		sc_bv<16>* towerET_6_2_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_6_2
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (6) => (6) @ (2)
					for (int i_0 = 6; i_0 <= 6; i_0 += 2)
					{
						// carray: (2) => (2) @ (2)
						for (int i_1 = 2; i_1 <= 2; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_6_2_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_6_2, "%s\n", (towerET_6_2_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_6_2, tvin_towerET_6_2);
		}

		tcl_file.set_num(1, &tcl_file.towerET_6_2_depth);
		sprintf(tvin_towerET_6_2, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_6_2, tvin_towerET_6_2);

		// release memory allocation
		delete [] towerET_6_2_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_6_3, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_6_3, tvin_towerET_6_3);

		sc_bv<16>* towerET_6_3_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_6_3
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (6) => (6) @ (2)
					for (int i_0 = 6; i_0 <= 6; i_0 += 2)
					{
						// carray: (3) => (3) @ (2)
						for (int i_1 = 3; i_1 <= 3; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_6_3_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_6_3, "%s\n", (towerET_6_3_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_6_3, tvin_towerET_6_3);
		}

		tcl_file.set_num(1, &tcl_file.towerET_6_3_depth);
		sprintf(tvin_towerET_6_3, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_6_3, tvin_towerET_6_3);

		// release memory allocation
		delete [] towerET_6_3_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_7_0, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_7_0, tvin_towerET_7_0);

		sc_bv<16>* towerET_7_0_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_7_0
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (7) => (7) @ (2)
					for (int i_0 = 7; i_0 <= 7; i_0 += 2)
					{
						// carray: (0) => (0) @ (2)
						for (int i_1 = 0; i_1 <= 0; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_7_0_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_7_0, "%s\n", (towerET_7_0_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_7_0, tvin_towerET_7_0);
		}

		tcl_file.set_num(1, &tcl_file.towerET_7_0_depth);
		sprintf(tvin_towerET_7_0, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_7_0, tvin_towerET_7_0);

		// release memory allocation
		delete [] towerET_7_0_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_7_1, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_7_1, tvin_towerET_7_1);

		sc_bv<16>* towerET_7_1_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_7_1
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (7) => (7) @ (2)
					for (int i_0 = 7; i_0 <= 7; i_0 += 2)
					{
						// carray: (1) => (1) @ (2)
						for (int i_1 = 1; i_1 <= 1; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_7_1_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_7_1, "%s\n", (towerET_7_1_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_7_1, tvin_towerET_7_1);
		}

		tcl_file.set_num(1, &tcl_file.towerET_7_1_depth);
		sprintf(tvin_towerET_7_1, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_7_1, tvin_towerET_7_1);

		// release memory allocation
		delete [] towerET_7_1_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_7_2, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_7_2, tvin_towerET_7_2);

		sc_bv<16>* towerET_7_2_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_7_2
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (7) => (7) @ (2)
					for (int i_0 = 7; i_0 <= 7; i_0 += 2)
					{
						// carray: (2) => (2) @ (2)
						for (int i_1 = 2; i_1 <= 2; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_7_2_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_7_2, "%s\n", (towerET_7_2_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_7_2, tvin_towerET_7_2);
		}

		tcl_file.set_num(1, &tcl_file.towerET_7_2_depth);
		sprintf(tvin_towerET_7_2, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_7_2, tvin_towerET_7_2);

		// release memory allocation
		delete [] towerET_7_2_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_7_3, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_7_3, tvin_towerET_7_3);

		sc_bv<16>* towerET_7_3_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_7_3
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (7) => (7) @ (2)
					for (int i_0 = 7; i_0 <= 7; i_0 += 2)
					{
						// carray: (3) => (3) @ (2)
						for (int i_1 = 3; i_1 <= 3; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_7_3_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_7_3, "%s\n", (towerET_7_3_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_7_3, tvin_towerET_7_3);
		}

		tcl_file.set_num(1, &tcl_file.towerET_7_3_depth);
		sprintf(tvin_towerET_7_3, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_7_3, tvin_towerET_7_3);

		// release memory allocation
		delete [] towerET_7_3_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_8_0, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_8_0, tvin_towerET_8_0);

		sc_bv<16>* towerET_8_0_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_8_0
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (8) => (8) @ (2)
					for (int i_0 = 8; i_0 <= 8; i_0 += 2)
					{
						// carray: (0) => (0) @ (2)
						for (int i_1 = 0; i_1 <= 0; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_8_0_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_8_0, "%s\n", (towerET_8_0_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_8_0, tvin_towerET_8_0);
		}

		tcl_file.set_num(1, &tcl_file.towerET_8_0_depth);
		sprintf(tvin_towerET_8_0, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_8_0, tvin_towerET_8_0);

		// release memory allocation
		delete [] towerET_8_0_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_8_1, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_8_1, tvin_towerET_8_1);

		sc_bv<16>* towerET_8_1_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_8_1
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (8) => (8) @ (2)
					for (int i_0 = 8; i_0 <= 8; i_0 += 2)
					{
						// carray: (1) => (1) @ (2)
						for (int i_1 = 1; i_1 <= 1; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_8_1_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_8_1, "%s\n", (towerET_8_1_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_8_1, tvin_towerET_8_1);
		}

		tcl_file.set_num(1, &tcl_file.towerET_8_1_depth);
		sprintf(tvin_towerET_8_1, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_8_1, tvin_towerET_8_1);

		// release memory allocation
		delete [] towerET_8_1_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_8_2, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_8_2, tvin_towerET_8_2);

		sc_bv<16>* towerET_8_2_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_8_2
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (8) => (8) @ (2)
					for (int i_0 = 8; i_0 <= 8; i_0 += 2)
					{
						// carray: (2) => (2) @ (2)
						for (int i_1 = 2; i_1 <= 2; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_8_2_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_8_2, "%s\n", (towerET_8_2_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_8_2, tvin_towerET_8_2);
		}

		tcl_file.set_num(1, &tcl_file.towerET_8_2_depth);
		sprintf(tvin_towerET_8_2, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_8_2, tvin_towerET_8_2);

		// release memory allocation
		delete [] towerET_8_2_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_8_3, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_8_3, tvin_towerET_8_3);

		sc_bv<16>* towerET_8_3_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_8_3
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (8) => (8) @ (2)
					for (int i_0 = 8; i_0 <= 8; i_0 += 2)
					{
						// carray: (3) => (3) @ (2)
						for (int i_1 = 3; i_1 <= 3; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_8_3_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_8_3, "%s\n", (towerET_8_3_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_8_3, tvin_towerET_8_3);
		}

		tcl_file.set_num(1, &tcl_file.towerET_8_3_depth);
		sprintf(tvin_towerET_8_3, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_8_3, tvin_towerET_8_3);

		// release memory allocation
		delete [] towerET_8_3_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_9_0, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_9_0, tvin_towerET_9_0);

		sc_bv<16>* towerET_9_0_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_9_0
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (9) => (9) @ (2)
					for (int i_0 = 9; i_0 <= 9; i_0 += 2)
					{
						// carray: (0) => (0) @ (2)
						for (int i_1 = 0; i_1 <= 0; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_9_0_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_9_0, "%s\n", (towerET_9_0_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_9_0, tvin_towerET_9_0);
		}

		tcl_file.set_num(1, &tcl_file.towerET_9_0_depth);
		sprintf(tvin_towerET_9_0, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_9_0, tvin_towerET_9_0);

		// release memory allocation
		delete [] towerET_9_0_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_9_1, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_9_1, tvin_towerET_9_1);

		sc_bv<16>* towerET_9_1_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_9_1
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (9) => (9) @ (2)
					for (int i_0 = 9; i_0 <= 9; i_0 += 2)
					{
						// carray: (1) => (1) @ (2)
						for (int i_1 = 1; i_1 <= 1; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_9_1_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_9_1, "%s\n", (towerET_9_1_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_9_1, tvin_towerET_9_1);
		}

		tcl_file.set_num(1, &tcl_file.towerET_9_1_depth);
		sprintf(tvin_towerET_9_1, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_9_1, tvin_towerET_9_1);

		// release memory allocation
		delete [] towerET_9_1_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_9_2, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_9_2, tvin_towerET_9_2);

		sc_bv<16>* towerET_9_2_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_9_2
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (9) => (9) @ (2)
					for (int i_0 = 9; i_0 <= 9; i_0 += 2)
					{
						// carray: (2) => (2) @ (2)
						for (int i_1 = 2; i_1 <= 2; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_9_2_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_9_2, "%s\n", (towerET_9_2_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_9_2, tvin_towerET_9_2);
		}

		tcl_file.set_num(1, &tcl_file.towerET_9_2_depth);
		sprintf(tvin_towerET_9_2, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_9_2, tvin_towerET_9_2);

		// release memory allocation
		delete [] towerET_9_2_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_9_3, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_9_3, tvin_towerET_9_3);

		sc_bv<16>* towerET_9_3_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_9_3
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (9) => (9) @ (2)
					for (int i_0 = 9; i_0 <= 9; i_0 += 2)
					{
						// carray: (3) => (3) @ (2)
						for (int i_1 = 3; i_1 <= 3; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_9_3_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_9_3, "%s\n", (towerET_9_3_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_9_3, tvin_towerET_9_3);
		}

		tcl_file.set_num(1, &tcl_file.towerET_9_3_depth);
		sprintf(tvin_towerET_9_3, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_9_3, tvin_towerET_9_3);

		// release memory allocation
		delete [] towerET_9_3_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_10_0, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_10_0, tvin_towerET_10_0);

		sc_bv<16>* towerET_10_0_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_10_0
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (10) => (10) @ (2)
					for (int i_0 = 10; i_0 <= 10; i_0 += 2)
					{
						// carray: (0) => (0) @ (2)
						for (int i_1 = 0; i_1 <= 0; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_10_0_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_10_0, "%s\n", (towerET_10_0_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_10_0, tvin_towerET_10_0);
		}

		tcl_file.set_num(1, &tcl_file.towerET_10_0_depth);
		sprintf(tvin_towerET_10_0, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_10_0, tvin_towerET_10_0);

		// release memory allocation
		delete [] towerET_10_0_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_10_1, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_10_1, tvin_towerET_10_1);

		sc_bv<16>* towerET_10_1_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_10_1
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (10) => (10) @ (2)
					for (int i_0 = 10; i_0 <= 10; i_0 += 2)
					{
						// carray: (1) => (1) @ (2)
						for (int i_1 = 1; i_1 <= 1; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_10_1_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_10_1, "%s\n", (towerET_10_1_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_10_1, tvin_towerET_10_1);
		}

		tcl_file.set_num(1, &tcl_file.towerET_10_1_depth);
		sprintf(tvin_towerET_10_1, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_10_1, tvin_towerET_10_1);

		// release memory allocation
		delete [] towerET_10_1_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_10_2, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_10_2, tvin_towerET_10_2);

		sc_bv<16>* towerET_10_2_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_10_2
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (10) => (10) @ (2)
					for (int i_0 = 10; i_0 <= 10; i_0 += 2)
					{
						// carray: (2) => (2) @ (2)
						for (int i_1 = 2; i_1 <= 2; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_10_2_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_10_2, "%s\n", (towerET_10_2_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_10_2, tvin_towerET_10_2);
		}

		tcl_file.set_num(1, &tcl_file.towerET_10_2_depth);
		sprintf(tvin_towerET_10_2, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_10_2, tvin_towerET_10_2);

		// release memory allocation
		delete [] towerET_10_2_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_10_3, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_10_3, tvin_towerET_10_3);

		sc_bv<16>* towerET_10_3_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_10_3
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (10) => (10) @ (2)
					for (int i_0 = 10; i_0 <= 10; i_0 += 2)
					{
						// carray: (3) => (3) @ (2)
						for (int i_1 = 3; i_1 <= 3; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_10_3_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_10_3, "%s\n", (towerET_10_3_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_10_3, tvin_towerET_10_3);
		}

		tcl_file.set_num(1, &tcl_file.towerET_10_3_depth);
		sprintf(tvin_towerET_10_3, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_10_3, tvin_towerET_10_3);

		// release memory allocation
		delete [] towerET_10_3_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_11_0, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_11_0, tvin_towerET_11_0);

		sc_bv<16>* towerET_11_0_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_11_0
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (11) => (11) @ (2)
					for (int i_0 = 11; i_0 <= 11; i_0 += 2)
					{
						// carray: (0) => (0) @ (2)
						for (int i_1 = 0; i_1 <= 0; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_11_0_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_11_0, "%s\n", (towerET_11_0_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_11_0, tvin_towerET_11_0);
		}

		tcl_file.set_num(1, &tcl_file.towerET_11_0_depth);
		sprintf(tvin_towerET_11_0, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_11_0, tvin_towerET_11_0);

		// release memory allocation
		delete [] towerET_11_0_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_11_1, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_11_1, tvin_towerET_11_1);

		sc_bv<16>* towerET_11_1_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_11_1
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (11) => (11) @ (2)
					for (int i_0 = 11; i_0 <= 11; i_0 += 2)
					{
						// carray: (1) => (1) @ (2)
						for (int i_1 = 1; i_1 <= 1; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_11_1_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_11_1, "%s\n", (towerET_11_1_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_11_1, tvin_towerET_11_1);
		}

		tcl_file.set_num(1, &tcl_file.towerET_11_1_depth);
		sprintf(tvin_towerET_11_1, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_11_1, tvin_towerET_11_1);

		// release memory allocation
		delete [] towerET_11_1_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_11_2, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_11_2, tvin_towerET_11_2);

		sc_bv<16>* towerET_11_2_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_11_2
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (11) => (11) @ (2)
					for (int i_0 = 11; i_0 <= 11; i_0 += 2)
					{
						// carray: (2) => (2) @ (2)
						for (int i_1 = 2; i_1 <= 2; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_11_2_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_11_2, "%s\n", (towerET_11_2_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_11_2, tvin_towerET_11_2);
		}

		tcl_file.set_num(1, &tcl_file.towerET_11_2_depth);
		sprintf(tvin_towerET_11_2, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_11_2, tvin_towerET_11_2);

		// release memory allocation
		delete [] towerET_11_2_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_11_3, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_11_3, tvin_towerET_11_3);

		sc_bv<16>* towerET_11_3_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_11_3
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (11) => (11) @ (2)
					for (int i_0 = 11; i_0 <= 11; i_0 += 2)
					{
						// carray: (3) => (3) @ (2)
						for (int i_1 = 3; i_1 <= 3; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_11_3_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_11_3, "%s\n", (towerET_11_3_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_11_3, tvin_towerET_11_3);
		}

		tcl_file.set_num(1, &tcl_file.towerET_11_3_depth);
		sprintf(tvin_towerET_11_3, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_11_3, tvin_towerET_11_3);

		// release memory allocation
		delete [] towerET_11_3_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_12_0, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_12_0, tvin_towerET_12_0);

		sc_bv<16>* towerET_12_0_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_12_0
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (12) => (12) @ (2)
					for (int i_0 = 12; i_0 <= 12; i_0 += 2)
					{
						// carray: (0) => (0) @ (2)
						for (int i_1 = 0; i_1 <= 0; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_12_0_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_12_0, "%s\n", (towerET_12_0_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_12_0, tvin_towerET_12_0);
		}

		tcl_file.set_num(1, &tcl_file.towerET_12_0_depth);
		sprintf(tvin_towerET_12_0, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_12_0, tvin_towerET_12_0);

		// release memory allocation
		delete [] towerET_12_0_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_12_1, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_12_1, tvin_towerET_12_1);

		sc_bv<16>* towerET_12_1_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_12_1
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (12) => (12) @ (2)
					for (int i_0 = 12; i_0 <= 12; i_0 += 2)
					{
						// carray: (1) => (1) @ (2)
						for (int i_1 = 1; i_1 <= 1; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_12_1_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_12_1, "%s\n", (towerET_12_1_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_12_1, tvin_towerET_12_1);
		}

		tcl_file.set_num(1, &tcl_file.towerET_12_1_depth);
		sprintf(tvin_towerET_12_1, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_12_1, tvin_towerET_12_1);

		// release memory allocation
		delete [] towerET_12_1_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_12_2, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_12_2, tvin_towerET_12_2);

		sc_bv<16>* towerET_12_2_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_12_2
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (12) => (12) @ (2)
					for (int i_0 = 12; i_0 <= 12; i_0 += 2)
					{
						// carray: (2) => (2) @ (2)
						for (int i_1 = 2; i_1 <= 2; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_12_2_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_12_2, "%s\n", (towerET_12_2_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_12_2, tvin_towerET_12_2);
		}

		tcl_file.set_num(1, &tcl_file.towerET_12_2_depth);
		sprintf(tvin_towerET_12_2, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_12_2, tvin_towerET_12_2);

		// release memory allocation
		delete [] towerET_12_2_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_12_3, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_12_3, tvin_towerET_12_3);

		sc_bv<16>* towerET_12_3_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_12_3
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (12) => (12) @ (2)
					for (int i_0 = 12; i_0 <= 12; i_0 += 2)
					{
						// carray: (3) => (3) @ (2)
						for (int i_1 = 3; i_1 <= 3; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_12_3_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_12_3, "%s\n", (towerET_12_3_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_12_3, tvin_towerET_12_3);
		}

		tcl_file.set_num(1, &tcl_file.towerET_12_3_depth);
		sprintf(tvin_towerET_12_3, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_12_3, tvin_towerET_12_3);

		// release memory allocation
		delete [] towerET_12_3_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_13_0, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_13_0, tvin_towerET_13_0);

		sc_bv<16>* towerET_13_0_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_13_0
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (13) => (13) @ (2)
					for (int i_0 = 13; i_0 <= 13; i_0 += 2)
					{
						// carray: (0) => (0) @ (2)
						for (int i_1 = 0; i_1 <= 0; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_13_0_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_13_0, "%s\n", (towerET_13_0_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_13_0, tvin_towerET_13_0);
		}

		tcl_file.set_num(1, &tcl_file.towerET_13_0_depth);
		sprintf(tvin_towerET_13_0, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_13_0, tvin_towerET_13_0);

		// release memory allocation
		delete [] towerET_13_0_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_13_1, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_13_1, tvin_towerET_13_1);

		sc_bv<16>* towerET_13_1_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_13_1
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (13) => (13) @ (2)
					for (int i_0 = 13; i_0 <= 13; i_0 += 2)
					{
						// carray: (1) => (1) @ (2)
						for (int i_1 = 1; i_1 <= 1; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_13_1_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_13_1, "%s\n", (towerET_13_1_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_13_1, tvin_towerET_13_1);
		}

		tcl_file.set_num(1, &tcl_file.towerET_13_1_depth);
		sprintf(tvin_towerET_13_1, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_13_1, tvin_towerET_13_1);

		// release memory allocation
		delete [] towerET_13_1_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_13_2, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_13_2, tvin_towerET_13_2);

		sc_bv<16>* towerET_13_2_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_13_2
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (13) => (13) @ (2)
					for (int i_0 = 13; i_0 <= 13; i_0 += 2)
					{
						// carray: (2) => (2) @ (2)
						for (int i_1 = 2; i_1 <= 2; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_13_2_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_13_2, "%s\n", (towerET_13_2_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_13_2, tvin_towerET_13_2);
		}

		tcl_file.set_num(1, &tcl_file.towerET_13_2_depth);
		sprintf(tvin_towerET_13_2, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_13_2, tvin_towerET_13_2);

		// release memory allocation
		delete [] towerET_13_2_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_13_3, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_13_3, tvin_towerET_13_3);

		sc_bv<16>* towerET_13_3_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_13_3
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (13) => (13) @ (2)
					for (int i_0 = 13; i_0 <= 13; i_0 += 2)
					{
						// carray: (3) => (3) @ (2)
						for (int i_1 = 3; i_1 <= 3; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_13_3_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_13_3, "%s\n", (towerET_13_3_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_13_3, tvin_towerET_13_3);
		}

		tcl_file.set_num(1, &tcl_file.towerET_13_3_depth);
		sprintf(tvin_towerET_13_3, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_13_3, tvin_towerET_13_3);

		// release memory allocation
		delete [] towerET_13_3_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_14_0, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_14_0, tvin_towerET_14_0);

		sc_bv<16>* towerET_14_0_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_14_0
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (14) => (14) @ (2)
					for (int i_0 = 14; i_0 <= 14; i_0 += 2)
					{
						// carray: (0) => (0) @ (2)
						for (int i_1 = 0; i_1 <= 0; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_14_0_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_14_0, "%s\n", (towerET_14_0_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_14_0, tvin_towerET_14_0);
		}

		tcl_file.set_num(1, &tcl_file.towerET_14_0_depth);
		sprintf(tvin_towerET_14_0, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_14_0, tvin_towerET_14_0);

		// release memory allocation
		delete [] towerET_14_0_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_14_1, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_14_1, tvin_towerET_14_1);

		sc_bv<16>* towerET_14_1_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_14_1
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (14) => (14) @ (2)
					for (int i_0 = 14; i_0 <= 14; i_0 += 2)
					{
						// carray: (1) => (1) @ (2)
						for (int i_1 = 1; i_1 <= 1; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_14_1_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_14_1, "%s\n", (towerET_14_1_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_14_1, tvin_towerET_14_1);
		}

		tcl_file.set_num(1, &tcl_file.towerET_14_1_depth);
		sprintf(tvin_towerET_14_1, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_14_1, tvin_towerET_14_1);

		// release memory allocation
		delete [] towerET_14_1_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_14_2, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_14_2, tvin_towerET_14_2);

		sc_bv<16>* towerET_14_2_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_14_2
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (14) => (14) @ (2)
					for (int i_0 = 14; i_0 <= 14; i_0 += 2)
					{
						// carray: (2) => (2) @ (2)
						for (int i_1 = 2; i_1 <= 2; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_14_2_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_14_2, "%s\n", (towerET_14_2_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_14_2, tvin_towerET_14_2);
		}

		tcl_file.set_num(1, &tcl_file.towerET_14_2_depth);
		sprintf(tvin_towerET_14_2, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_14_2, tvin_towerET_14_2);

		// release memory allocation
		delete [] towerET_14_2_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_14_3, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_14_3, tvin_towerET_14_3);

		sc_bv<16>* towerET_14_3_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_14_3
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (14) => (14) @ (2)
					for (int i_0 = 14; i_0 <= 14; i_0 += 2)
					{
						// carray: (3) => (3) @ (2)
						for (int i_1 = 3; i_1 <= 3; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_14_3_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_14_3, "%s\n", (towerET_14_3_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_14_3, tvin_towerET_14_3);
		}

		tcl_file.set_num(1, &tcl_file.towerET_14_3_depth);
		sprintf(tvin_towerET_14_3, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_14_3, tvin_towerET_14_3);

		// release memory allocation
		delete [] towerET_14_3_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_15_0, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_15_0, tvin_towerET_15_0);

		sc_bv<16>* towerET_15_0_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_15_0
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (15) => (15) @ (2)
					for (int i_0 = 15; i_0 <= 15; i_0 += 2)
					{
						// carray: (0) => (0) @ (2)
						for (int i_1 = 0; i_1 <= 0; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_15_0_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_15_0, "%s\n", (towerET_15_0_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_15_0, tvin_towerET_15_0);
		}

		tcl_file.set_num(1, &tcl_file.towerET_15_0_depth);
		sprintf(tvin_towerET_15_0, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_15_0, tvin_towerET_15_0);

		// release memory allocation
		delete [] towerET_15_0_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_15_1, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_15_1, tvin_towerET_15_1);

		sc_bv<16>* towerET_15_1_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_15_1
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (15) => (15) @ (2)
					for (int i_0 = 15; i_0 <= 15; i_0 += 2)
					{
						// carray: (1) => (1) @ (2)
						for (int i_1 = 1; i_1 <= 1; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_15_1_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_15_1, "%s\n", (towerET_15_1_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_15_1, tvin_towerET_15_1);
		}

		tcl_file.set_num(1, &tcl_file.towerET_15_1_depth);
		sprintf(tvin_towerET_15_1, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_15_1, tvin_towerET_15_1);

		// release memory allocation
		delete [] towerET_15_1_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_15_2, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_15_2, tvin_towerET_15_2);

		sc_bv<16>* towerET_15_2_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_15_2
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (15) => (15) @ (2)
					for (int i_0 = 15; i_0 <= 15; i_0 += 2)
					{
						// carray: (2) => (2) @ (2)
						for (int i_1 = 2; i_1 <= 2; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_15_2_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_15_2, "%s\n", (towerET_15_2_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_15_2, tvin_towerET_15_2);
		}

		tcl_file.set_num(1, &tcl_file.towerET_15_2_depth);
		sprintf(tvin_towerET_15_2, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_15_2, tvin_towerET_15_2);

		// release memory allocation
		delete [] towerET_15_2_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_15_3, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_15_3, tvin_towerET_15_3);

		sc_bv<16>* towerET_15_3_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_15_3
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (15) => (15) @ (2)
					for (int i_0 = 15; i_0 <= 15; i_0 += 2)
					{
						// carray: (3) => (3) @ (2)
						for (int i_1 = 3; i_1 <= 3; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_15_3_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_15_3, "%s\n", (towerET_15_3_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_15_3, tvin_towerET_15_3);
		}

		tcl_file.set_num(1, &tcl_file.towerET_15_3_depth);
		sprintf(tvin_towerET_15_3, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_15_3, tvin_towerET_15_3);

		// release memory allocation
		delete [] towerET_15_3_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_16_0, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_16_0, tvin_towerET_16_0);

		sc_bv<16>* towerET_16_0_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_16_0
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (16) => (16) @ (2)
					for (int i_0 = 16; i_0 <= 16; i_0 += 2)
					{
						// carray: (0) => (0) @ (2)
						for (int i_1 = 0; i_1 <= 0; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_16_0_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_16_0, "%s\n", (towerET_16_0_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_16_0, tvin_towerET_16_0);
		}

		tcl_file.set_num(1, &tcl_file.towerET_16_0_depth);
		sprintf(tvin_towerET_16_0, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_16_0, tvin_towerET_16_0);

		// release memory allocation
		delete [] towerET_16_0_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_16_1, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_16_1, tvin_towerET_16_1);

		sc_bv<16>* towerET_16_1_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_16_1
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (16) => (16) @ (2)
					for (int i_0 = 16; i_0 <= 16; i_0 += 2)
					{
						// carray: (1) => (1) @ (2)
						for (int i_1 = 1; i_1 <= 1; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_16_1_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_16_1, "%s\n", (towerET_16_1_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_16_1, tvin_towerET_16_1);
		}

		tcl_file.set_num(1, &tcl_file.towerET_16_1_depth);
		sprintf(tvin_towerET_16_1, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_16_1, tvin_towerET_16_1);

		// release memory allocation
		delete [] towerET_16_1_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_16_2, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_16_2, tvin_towerET_16_2);

		sc_bv<16>* towerET_16_2_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_16_2
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (16) => (16) @ (2)
					for (int i_0 = 16; i_0 <= 16; i_0 += 2)
					{
						// carray: (2) => (2) @ (2)
						for (int i_1 = 2; i_1 <= 2; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_16_2_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_16_2, "%s\n", (towerET_16_2_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_16_2, tvin_towerET_16_2);
		}

		tcl_file.set_num(1, &tcl_file.towerET_16_2_depth);
		sprintf(tvin_towerET_16_2, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_16_2, tvin_towerET_16_2);

		// release memory allocation
		delete [] towerET_16_2_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_towerET_16_3, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_towerET_16_3, tvin_towerET_16_3);

		sc_bv<16>* towerET_16_3_tvin_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: towerET_16_3
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: towerET(15, 0)
				{
					// carray: (16) => (16) @ (2)
					for (int i_0 = 16; i_0 <= 16; i_0 += 2)
					{
						// carray: (3) => (3) @ (2)
						for (int i_1 = 3; i_1 <= 3; i_1 += 2)
						{
							// sub                   : i_0 i_1
							// ori_name              : towerET[i_0][i_1]
							// sub_1st_elem          : 0 0
							// ori_name_1st_elem     : towerET[0][0]
							// regulate_c_name       : towerET
							// input_type_conversion : towerET[i_0][i_1]
							if (&(towerET[0][0]) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<16> towerET_tmp_mem;
								towerET_tmp_mem = towerET[i_0][i_1];
								towerET_16_3_tvin_wrapc_buffer[hls_map_index++].range(15, 0) = towerET_tmp_mem.range(15, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_towerET_16_3, "%s\n", (towerET_16_3_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_towerET_16_3, tvin_towerET_16_3);
		}

		tcl_file.set_num(1, &tcl_file.towerET_16_3_depth);
		sprintf(tvin_towerET_16_3, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_towerET_16_3, tvin_towerET_16_3);

		// release memory allocation
		delete [] towerET_16_3_tvin_wrapc_buffer;

// [call_c_dut] ---------->

		CodeState = CALL_C_DUT;
		TowerPeaks(towerET, TowerPhi, TowerEta);

		CodeState = DUMP_OUTPUTS;

		// [[transaction]]
		sprintf(tvout_TowerPhi_0, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_0, tvout_TowerPhi_0);

		sc_bv<16>* TowerPhi_0_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerPhi_0
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerPhi(15, 0)
				{
					// carray: (0) => (0) @ (2)
					for (int i_0 = 0; i_0 <= 0; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerPhi[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerPhi[0]
						// regulate_c_name       : TowerPhi
						// input_type_conversion : TowerPhi[i_0]
						if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerPhi_tmp_mem;
							TowerPhi_tmp_mem = TowerPhi[i_0];
							TowerPhi_0_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerPhi_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerPhi_0, "%s\n", (TowerPhi_0_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerPhi_0, tvout_TowerPhi_0);
		}

		tcl_file.set_num(1, &tcl_file.TowerPhi_0_depth);
		sprintf(tvout_TowerPhi_0, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_0, tvout_TowerPhi_0);

		// release memory allocation
		delete [] TowerPhi_0_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerPhi_1, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_1, tvout_TowerPhi_1);

		sc_bv<16>* TowerPhi_1_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerPhi_1
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerPhi(15, 0)
				{
					// carray: (1) => (1) @ (2)
					for (int i_0 = 1; i_0 <= 1; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerPhi[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerPhi[0]
						// regulate_c_name       : TowerPhi
						// input_type_conversion : TowerPhi[i_0]
						if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerPhi_tmp_mem;
							TowerPhi_tmp_mem = TowerPhi[i_0];
							TowerPhi_1_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerPhi_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerPhi_1, "%s\n", (TowerPhi_1_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerPhi_1, tvout_TowerPhi_1);
		}

		tcl_file.set_num(1, &tcl_file.TowerPhi_1_depth);
		sprintf(tvout_TowerPhi_1, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_1, tvout_TowerPhi_1);

		// release memory allocation
		delete [] TowerPhi_1_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerPhi_2, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_2, tvout_TowerPhi_2);

		sc_bv<16>* TowerPhi_2_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerPhi_2
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerPhi(15, 0)
				{
					// carray: (2) => (2) @ (2)
					for (int i_0 = 2; i_0 <= 2; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerPhi[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerPhi[0]
						// regulate_c_name       : TowerPhi
						// input_type_conversion : TowerPhi[i_0]
						if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerPhi_tmp_mem;
							TowerPhi_tmp_mem = TowerPhi[i_0];
							TowerPhi_2_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerPhi_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerPhi_2, "%s\n", (TowerPhi_2_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerPhi_2, tvout_TowerPhi_2);
		}

		tcl_file.set_num(1, &tcl_file.TowerPhi_2_depth);
		sprintf(tvout_TowerPhi_2, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_2, tvout_TowerPhi_2);

		// release memory allocation
		delete [] TowerPhi_2_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerPhi_3, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_3, tvout_TowerPhi_3);

		sc_bv<16>* TowerPhi_3_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerPhi_3
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerPhi(15, 0)
				{
					// carray: (3) => (3) @ (2)
					for (int i_0 = 3; i_0 <= 3; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerPhi[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerPhi[0]
						// regulate_c_name       : TowerPhi
						// input_type_conversion : TowerPhi[i_0]
						if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerPhi_tmp_mem;
							TowerPhi_tmp_mem = TowerPhi[i_0];
							TowerPhi_3_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerPhi_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerPhi_3, "%s\n", (TowerPhi_3_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerPhi_3, tvout_TowerPhi_3);
		}

		tcl_file.set_num(1, &tcl_file.TowerPhi_3_depth);
		sprintf(tvout_TowerPhi_3, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_3, tvout_TowerPhi_3);

		// release memory allocation
		delete [] TowerPhi_3_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerPhi_4, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_4, tvout_TowerPhi_4);

		sc_bv<16>* TowerPhi_4_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerPhi_4
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerPhi(15, 0)
				{
					// carray: (4) => (4) @ (2)
					for (int i_0 = 4; i_0 <= 4; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerPhi[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerPhi[0]
						// regulate_c_name       : TowerPhi
						// input_type_conversion : TowerPhi[i_0]
						if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerPhi_tmp_mem;
							TowerPhi_tmp_mem = TowerPhi[i_0];
							TowerPhi_4_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerPhi_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerPhi_4, "%s\n", (TowerPhi_4_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerPhi_4, tvout_TowerPhi_4);
		}

		tcl_file.set_num(1, &tcl_file.TowerPhi_4_depth);
		sprintf(tvout_TowerPhi_4, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_4, tvout_TowerPhi_4);

		// release memory allocation
		delete [] TowerPhi_4_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerPhi_5, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_5, tvout_TowerPhi_5);

		sc_bv<16>* TowerPhi_5_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerPhi_5
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerPhi(15, 0)
				{
					// carray: (5) => (5) @ (2)
					for (int i_0 = 5; i_0 <= 5; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerPhi[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerPhi[0]
						// regulate_c_name       : TowerPhi
						// input_type_conversion : TowerPhi[i_0]
						if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerPhi_tmp_mem;
							TowerPhi_tmp_mem = TowerPhi[i_0];
							TowerPhi_5_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerPhi_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerPhi_5, "%s\n", (TowerPhi_5_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerPhi_5, tvout_TowerPhi_5);
		}

		tcl_file.set_num(1, &tcl_file.TowerPhi_5_depth);
		sprintf(tvout_TowerPhi_5, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_5, tvout_TowerPhi_5);

		// release memory allocation
		delete [] TowerPhi_5_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerPhi_6, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_6, tvout_TowerPhi_6);

		sc_bv<16>* TowerPhi_6_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerPhi_6
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerPhi(15, 0)
				{
					// carray: (6) => (6) @ (2)
					for (int i_0 = 6; i_0 <= 6; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerPhi[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerPhi[0]
						// regulate_c_name       : TowerPhi
						// input_type_conversion : TowerPhi[i_0]
						if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerPhi_tmp_mem;
							TowerPhi_tmp_mem = TowerPhi[i_0];
							TowerPhi_6_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerPhi_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerPhi_6, "%s\n", (TowerPhi_6_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerPhi_6, tvout_TowerPhi_6);
		}

		tcl_file.set_num(1, &tcl_file.TowerPhi_6_depth);
		sprintf(tvout_TowerPhi_6, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_6, tvout_TowerPhi_6);

		// release memory allocation
		delete [] TowerPhi_6_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerPhi_7, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_7, tvout_TowerPhi_7);

		sc_bv<16>* TowerPhi_7_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerPhi_7
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerPhi(15, 0)
				{
					// carray: (7) => (7) @ (2)
					for (int i_0 = 7; i_0 <= 7; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerPhi[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerPhi[0]
						// regulate_c_name       : TowerPhi
						// input_type_conversion : TowerPhi[i_0]
						if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerPhi_tmp_mem;
							TowerPhi_tmp_mem = TowerPhi[i_0];
							TowerPhi_7_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerPhi_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerPhi_7, "%s\n", (TowerPhi_7_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerPhi_7, tvout_TowerPhi_7);
		}

		tcl_file.set_num(1, &tcl_file.TowerPhi_7_depth);
		sprintf(tvout_TowerPhi_7, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_7, tvout_TowerPhi_7);

		// release memory allocation
		delete [] TowerPhi_7_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerPhi_8, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_8, tvout_TowerPhi_8);

		sc_bv<16>* TowerPhi_8_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerPhi_8
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerPhi(15, 0)
				{
					// carray: (8) => (8) @ (2)
					for (int i_0 = 8; i_0 <= 8; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerPhi[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerPhi[0]
						// regulate_c_name       : TowerPhi
						// input_type_conversion : TowerPhi[i_0]
						if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerPhi_tmp_mem;
							TowerPhi_tmp_mem = TowerPhi[i_0];
							TowerPhi_8_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerPhi_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerPhi_8, "%s\n", (TowerPhi_8_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerPhi_8, tvout_TowerPhi_8);
		}

		tcl_file.set_num(1, &tcl_file.TowerPhi_8_depth);
		sprintf(tvout_TowerPhi_8, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_8, tvout_TowerPhi_8);

		// release memory allocation
		delete [] TowerPhi_8_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerPhi_9, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_9, tvout_TowerPhi_9);

		sc_bv<16>* TowerPhi_9_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerPhi_9
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerPhi(15, 0)
				{
					// carray: (9) => (9) @ (2)
					for (int i_0 = 9; i_0 <= 9; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerPhi[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerPhi[0]
						// regulate_c_name       : TowerPhi
						// input_type_conversion : TowerPhi[i_0]
						if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerPhi_tmp_mem;
							TowerPhi_tmp_mem = TowerPhi[i_0];
							TowerPhi_9_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerPhi_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerPhi_9, "%s\n", (TowerPhi_9_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerPhi_9, tvout_TowerPhi_9);
		}

		tcl_file.set_num(1, &tcl_file.TowerPhi_9_depth);
		sprintf(tvout_TowerPhi_9, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_9, tvout_TowerPhi_9);

		// release memory allocation
		delete [] TowerPhi_9_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerPhi_10, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_10, tvout_TowerPhi_10);

		sc_bv<16>* TowerPhi_10_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerPhi_10
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerPhi(15, 0)
				{
					// carray: (10) => (10) @ (2)
					for (int i_0 = 10; i_0 <= 10; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerPhi[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerPhi[0]
						// regulate_c_name       : TowerPhi
						// input_type_conversion : TowerPhi[i_0]
						if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerPhi_tmp_mem;
							TowerPhi_tmp_mem = TowerPhi[i_0];
							TowerPhi_10_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerPhi_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerPhi_10, "%s\n", (TowerPhi_10_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerPhi_10, tvout_TowerPhi_10);
		}

		tcl_file.set_num(1, &tcl_file.TowerPhi_10_depth);
		sprintf(tvout_TowerPhi_10, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_10, tvout_TowerPhi_10);

		// release memory allocation
		delete [] TowerPhi_10_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerPhi_11, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_11, tvout_TowerPhi_11);

		sc_bv<16>* TowerPhi_11_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerPhi_11
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerPhi(15, 0)
				{
					// carray: (11) => (11) @ (2)
					for (int i_0 = 11; i_0 <= 11; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerPhi[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerPhi[0]
						// regulate_c_name       : TowerPhi
						// input_type_conversion : TowerPhi[i_0]
						if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerPhi_tmp_mem;
							TowerPhi_tmp_mem = TowerPhi[i_0];
							TowerPhi_11_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerPhi_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerPhi_11, "%s\n", (TowerPhi_11_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerPhi_11, tvout_TowerPhi_11);
		}

		tcl_file.set_num(1, &tcl_file.TowerPhi_11_depth);
		sprintf(tvout_TowerPhi_11, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_11, tvout_TowerPhi_11);

		// release memory allocation
		delete [] TowerPhi_11_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerPhi_12, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_12, tvout_TowerPhi_12);

		sc_bv<16>* TowerPhi_12_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerPhi_12
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerPhi(15, 0)
				{
					// carray: (12) => (12) @ (2)
					for (int i_0 = 12; i_0 <= 12; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerPhi[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerPhi[0]
						// regulate_c_name       : TowerPhi
						// input_type_conversion : TowerPhi[i_0]
						if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerPhi_tmp_mem;
							TowerPhi_tmp_mem = TowerPhi[i_0];
							TowerPhi_12_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerPhi_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerPhi_12, "%s\n", (TowerPhi_12_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerPhi_12, tvout_TowerPhi_12);
		}

		tcl_file.set_num(1, &tcl_file.TowerPhi_12_depth);
		sprintf(tvout_TowerPhi_12, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_12, tvout_TowerPhi_12);

		// release memory allocation
		delete [] TowerPhi_12_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerPhi_13, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_13, tvout_TowerPhi_13);

		sc_bv<16>* TowerPhi_13_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerPhi_13
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerPhi(15, 0)
				{
					// carray: (13) => (13) @ (2)
					for (int i_0 = 13; i_0 <= 13; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerPhi[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerPhi[0]
						// regulate_c_name       : TowerPhi
						// input_type_conversion : TowerPhi[i_0]
						if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerPhi_tmp_mem;
							TowerPhi_tmp_mem = TowerPhi[i_0];
							TowerPhi_13_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerPhi_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerPhi_13, "%s\n", (TowerPhi_13_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerPhi_13, tvout_TowerPhi_13);
		}

		tcl_file.set_num(1, &tcl_file.TowerPhi_13_depth);
		sprintf(tvout_TowerPhi_13, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_13, tvout_TowerPhi_13);

		// release memory allocation
		delete [] TowerPhi_13_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerPhi_14, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_14, tvout_TowerPhi_14);

		sc_bv<16>* TowerPhi_14_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerPhi_14
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerPhi(15, 0)
				{
					// carray: (14) => (14) @ (2)
					for (int i_0 = 14; i_0 <= 14; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerPhi[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerPhi[0]
						// regulate_c_name       : TowerPhi
						// input_type_conversion : TowerPhi[i_0]
						if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerPhi_tmp_mem;
							TowerPhi_tmp_mem = TowerPhi[i_0];
							TowerPhi_14_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerPhi_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerPhi_14, "%s\n", (TowerPhi_14_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerPhi_14, tvout_TowerPhi_14);
		}

		tcl_file.set_num(1, &tcl_file.TowerPhi_14_depth);
		sprintf(tvout_TowerPhi_14, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_14, tvout_TowerPhi_14);

		// release memory allocation
		delete [] TowerPhi_14_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerPhi_15, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_15, tvout_TowerPhi_15);

		sc_bv<16>* TowerPhi_15_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerPhi_15
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerPhi(15, 0)
				{
					// carray: (15) => (15) @ (2)
					for (int i_0 = 15; i_0 <= 15; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerPhi[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerPhi[0]
						// regulate_c_name       : TowerPhi
						// input_type_conversion : TowerPhi[i_0]
						if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerPhi_tmp_mem;
							TowerPhi_tmp_mem = TowerPhi[i_0];
							TowerPhi_15_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerPhi_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerPhi_15, "%s\n", (TowerPhi_15_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerPhi_15, tvout_TowerPhi_15);
		}

		tcl_file.set_num(1, &tcl_file.TowerPhi_15_depth);
		sprintf(tvout_TowerPhi_15, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_15, tvout_TowerPhi_15);

		// release memory allocation
		delete [] TowerPhi_15_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerPhi_16, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_16, tvout_TowerPhi_16);

		sc_bv<16>* TowerPhi_16_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerPhi_16
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerPhi(15, 0)
				{
					// carray: (16) => (16) @ (2)
					for (int i_0 = 16; i_0 <= 16; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerPhi[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerPhi[0]
						// regulate_c_name       : TowerPhi
						// input_type_conversion : TowerPhi[i_0]
						if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerPhi_tmp_mem;
							TowerPhi_tmp_mem = TowerPhi[i_0];
							TowerPhi_16_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerPhi_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerPhi_16, "%s\n", (TowerPhi_16_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerPhi_16, tvout_TowerPhi_16);
		}

		tcl_file.set_num(1, &tcl_file.TowerPhi_16_depth);
		sprintf(tvout_TowerPhi_16, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_16, tvout_TowerPhi_16);

		// release memory allocation
		delete [] TowerPhi_16_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerPhi_17, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_17, tvout_TowerPhi_17);

		sc_bv<16>* TowerPhi_17_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerPhi_17
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerPhi(15, 0)
				{
					// carray: (17) => (17) @ (2)
					for (int i_0 = 17; i_0 <= 17; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerPhi[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerPhi[0]
						// regulate_c_name       : TowerPhi
						// input_type_conversion : TowerPhi[i_0]
						if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerPhi_tmp_mem;
							TowerPhi_tmp_mem = TowerPhi[i_0];
							TowerPhi_17_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerPhi_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerPhi_17, "%s\n", (TowerPhi_17_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerPhi_17, tvout_TowerPhi_17);
		}

		tcl_file.set_num(1, &tcl_file.TowerPhi_17_depth);
		sprintf(tvout_TowerPhi_17, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_17, tvout_TowerPhi_17);

		// release memory allocation
		delete [] TowerPhi_17_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerPhi_18, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_18, tvout_TowerPhi_18);

		sc_bv<16>* TowerPhi_18_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerPhi_18
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerPhi(15, 0)
				{
					// carray: (18) => (18) @ (2)
					for (int i_0 = 18; i_0 <= 18; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerPhi[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerPhi[0]
						// regulate_c_name       : TowerPhi
						// input_type_conversion : TowerPhi[i_0]
						if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerPhi_tmp_mem;
							TowerPhi_tmp_mem = TowerPhi[i_0];
							TowerPhi_18_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerPhi_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerPhi_18, "%s\n", (TowerPhi_18_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerPhi_18, tvout_TowerPhi_18);
		}

		tcl_file.set_num(1, &tcl_file.TowerPhi_18_depth);
		sprintf(tvout_TowerPhi_18, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_18, tvout_TowerPhi_18);

		// release memory allocation
		delete [] TowerPhi_18_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerPhi_19, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_19, tvout_TowerPhi_19);

		sc_bv<16>* TowerPhi_19_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerPhi_19
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerPhi(15, 0)
				{
					// carray: (19) => (19) @ (2)
					for (int i_0 = 19; i_0 <= 19; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerPhi[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerPhi[0]
						// regulate_c_name       : TowerPhi
						// input_type_conversion : TowerPhi[i_0]
						if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerPhi_tmp_mem;
							TowerPhi_tmp_mem = TowerPhi[i_0];
							TowerPhi_19_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerPhi_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerPhi_19, "%s\n", (TowerPhi_19_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerPhi_19, tvout_TowerPhi_19);
		}

		tcl_file.set_num(1, &tcl_file.TowerPhi_19_depth);
		sprintf(tvout_TowerPhi_19, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_19, tvout_TowerPhi_19);

		// release memory allocation
		delete [] TowerPhi_19_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerPhi_20, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_20, tvout_TowerPhi_20);

		sc_bv<16>* TowerPhi_20_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerPhi_20
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerPhi(15, 0)
				{
					// carray: (20) => (20) @ (2)
					for (int i_0 = 20; i_0 <= 20; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerPhi[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerPhi[0]
						// regulate_c_name       : TowerPhi
						// input_type_conversion : TowerPhi[i_0]
						if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerPhi_tmp_mem;
							TowerPhi_tmp_mem = TowerPhi[i_0];
							TowerPhi_20_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerPhi_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerPhi_20, "%s\n", (TowerPhi_20_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerPhi_20, tvout_TowerPhi_20);
		}

		tcl_file.set_num(1, &tcl_file.TowerPhi_20_depth);
		sprintf(tvout_TowerPhi_20, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_20, tvout_TowerPhi_20);

		// release memory allocation
		delete [] TowerPhi_20_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerPhi_21, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_21, tvout_TowerPhi_21);

		sc_bv<16>* TowerPhi_21_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerPhi_21
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerPhi(15, 0)
				{
					// carray: (21) => (21) @ (2)
					for (int i_0 = 21; i_0 <= 21; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerPhi[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerPhi[0]
						// regulate_c_name       : TowerPhi
						// input_type_conversion : TowerPhi[i_0]
						if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerPhi_tmp_mem;
							TowerPhi_tmp_mem = TowerPhi[i_0];
							TowerPhi_21_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerPhi_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerPhi_21, "%s\n", (TowerPhi_21_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerPhi_21, tvout_TowerPhi_21);
		}

		tcl_file.set_num(1, &tcl_file.TowerPhi_21_depth);
		sprintf(tvout_TowerPhi_21, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_21, tvout_TowerPhi_21);

		// release memory allocation
		delete [] TowerPhi_21_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerPhi_22, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_22, tvout_TowerPhi_22);

		sc_bv<16>* TowerPhi_22_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerPhi_22
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerPhi(15, 0)
				{
					// carray: (22) => (22) @ (2)
					for (int i_0 = 22; i_0 <= 22; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerPhi[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerPhi[0]
						// regulate_c_name       : TowerPhi
						// input_type_conversion : TowerPhi[i_0]
						if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerPhi_tmp_mem;
							TowerPhi_tmp_mem = TowerPhi[i_0];
							TowerPhi_22_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerPhi_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerPhi_22, "%s\n", (TowerPhi_22_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerPhi_22, tvout_TowerPhi_22);
		}

		tcl_file.set_num(1, &tcl_file.TowerPhi_22_depth);
		sprintf(tvout_TowerPhi_22, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_22, tvout_TowerPhi_22);

		// release memory allocation
		delete [] TowerPhi_22_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerPhi_23, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_23, tvout_TowerPhi_23);

		sc_bv<16>* TowerPhi_23_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerPhi_23
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerPhi(15, 0)
				{
					// carray: (23) => (23) @ (2)
					for (int i_0 = 23; i_0 <= 23; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerPhi[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerPhi[0]
						// regulate_c_name       : TowerPhi
						// input_type_conversion : TowerPhi[i_0]
						if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerPhi_tmp_mem;
							TowerPhi_tmp_mem = TowerPhi[i_0];
							TowerPhi_23_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerPhi_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerPhi_23, "%s\n", (TowerPhi_23_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerPhi_23, tvout_TowerPhi_23);
		}

		tcl_file.set_num(1, &tcl_file.TowerPhi_23_depth);
		sprintf(tvout_TowerPhi_23, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_23, tvout_TowerPhi_23);

		// release memory allocation
		delete [] TowerPhi_23_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerPhi_24, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_24, tvout_TowerPhi_24);

		sc_bv<16>* TowerPhi_24_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerPhi_24
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerPhi(15, 0)
				{
					// carray: (24) => (24) @ (2)
					for (int i_0 = 24; i_0 <= 24; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerPhi[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerPhi[0]
						// regulate_c_name       : TowerPhi
						// input_type_conversion : TowerPhi[i_0]
						if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerPhi_tmp_mem;
							TowerPhi_tmp_mem = TowerPhi[i_0];
							TowerPhi_24_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerPhi_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerPhi_24, "%s\n", (TowerPhi_24_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerPhi_24, tvout_TowerPhi_24);
		}

		tcl_file.set_num(1, &tcl_file.TowerPhi_24_depth);
		sprintf(tvout_TowerPhi_24, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_24, tvout_TowerPhi_24);

		// release memory allocation
		delete [] TowerPhi_24_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerPhi_25, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_25, tvout_TowerPhi_25);

		sc_bv<16>* TowerPhi_25_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerPhi_25
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerPhi(15, 0)
				{
					// carray: (25) => (25) @ (2)
					for (int i_0 = 25; i_0 <= 25; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerPhi[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerPhi[0]
						// regulate_c_name       : TowerPhi
						// input_type_conversion : TowerPhi[i_0]
						if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerPhi_tmp_mem;
							TowerPhi_tmp_mem = TowerPhi[i_0];
							TowerPhi_25_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerPhi_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerPhi_25, "%s\n", (TowerPhi_25_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerPhi_25, tvout_TowerPhi_25);
		}

		tcl_file.set_num(1, &tcl_file.TowerPhi_25_depth);
		sprintf(tvout_TowerPhi_25, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_25, tvout_TowerPhi_25);

		// release memory allocation
		delete [] TowerPhi_25_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerPhi_26, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_26, tvout_TowerPhi_26);

		sc_bv<16>* TowerPhi_26_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerPhi_26
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerPhi(15, 0)
				{
					// carray: (26) => (26) @ (2)
					for (int i_0 = 26; i_0 <= 26; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerPhi[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerPhi[0]
						// regulate_c_name       : TowerPhi
						// input_type_conversion : TowerPhi[i_0]
						if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerPhi_tmp_mem;
							TowerPhi_tmp_mem = TowerPhi[i_0];
							TowerPhi_26_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerPhi_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerPhi_26, "%s\n", (TowerPhi_26_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerPhi_26, tvout_TowerPhi_26);
		}

		tcl_file.set_num(1, &tcl_file.TowerPhi_26_depth);
		sprintf(tvout_TowerPhi_26, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_26, tvout_TowerPhi_26);

		// release memory allocation
		delete [] TowerPhi_26_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerPhi_27, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_27, tvout_TowerPhi_27);

		sc_bv<16>* TowerPhi_27_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerPhi_27
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerPhi(15, 0)
				{
					// carray: (27) => (27) @ (2)
					for (int i_0 = 27; i_0 <= 27; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerPhi[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerPhi[0]
						// regulate_c_name       : TowerPhi
						// input_type_conversion : TowerPhi[i_0]
						if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerPhi_tmp_mem;
							TowerPhi_tmp_mem = TowerPhi[i_0];
							TowerPhi_27_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerPhi_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerPhi_27, "%s\n", (TowerPhi_27_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerPhi_27, tvout_TowerPhi_27);
		}

		tcl_file.set_num(1, &tcl_file.TowerPhi_27_depth);
		sprintf(tvout_TowerPhi_27, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_27, tvout_TowerPhi_27);

		// release memory allocation
		delete [] TowerPhi_27_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerPhi_28, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_28, tvout_TowerPhi_28);

		sc_bv<16>* TowerPhi_28_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerPhi_28
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerPhi(15, 0)
				{
					// carray: (28) => (28) @ (2)
					for (int i_0 = 28; i_0 <= 28; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerPhi[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerPhi[0]
						// regulate_c_name       : TowerPhi
						// input_type_conversion : TowerPhi[i_0]
						if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerPhi_tmp_mem;
							TowerPhi_tmp_mem = TowerPhi[i_0];
							TowerPhi_28_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerPhi_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerPhi_28, "%s\n", (TowerPhi_28_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerPhi_28, tvout_TowerPhi_28);
		}

		tcl_file.set_num(1, &tcl_file.TowerPhi_28_depth);
		sprintf(tvout_TowerPhi_28, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_28, tvout_TowerPhi_28);

		// release memory allocation
		delete [] TowerPhi_28_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerPhi_29, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_29, tvout_TowerPhi_29);

		sc_bv<16>* TowerPhi_29_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerPhi_29
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerPhi(15, 0)
				{
					// carray: (29) => (29) @ (2)
					for (int i_0 = 29; i_0 <= 29; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerPhi[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerPhi[0]
						// regulate_c_name       : TowerPhi
						// input_type_conversion : TowerPhi[i_0]
						if (&(TowerPhi[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerPhi_tmp_mem;
							TowerPhi_tmp_mem = TowerPhi[i_0];
							TowerPhi_29_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerPhi_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerPhi_29, "%s\n", (TowerPhi_29_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerPhi_29, tvout_TowerPhi_29);
		}

		tcl_file.set_num(1, &tcl_file.TowerPhi_29_depth);
		sprintf(tvout_TowerPhi_29, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerPhi_29, tvout_TowerPhi_29);

		// release memory allocation
		delete [] TowerPhi_29_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerEta_0, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_0, tvout_TowerEta_0);

		sc_bv<16>* TowerEta_0_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerEta_0
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerEta(15, 0)
				{
					// carray: (0) => (0) @ (2)
					for (int i_0 = 0; i_0 <= 0; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerEta[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerEta[0]
						// regulate_c_name       : TowerEta
						// input_type_conversion : TowerEta[i_0]
						if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerEta_tmp_mem;
							TowerEta_tmp_mem = TowerEta[i_0];
							TowerEta_0_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerEta_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerEta_0, "%s\n", (TowerEta_0_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerEta_0, tvout_TowerEta_0);
		}

		tcl_file.set_num(1, &tcl_file.TowerEta_0_depth);
		sprintf(tvout_TowerEta_0, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_0, tvout_TowerEta_0);

		// release memory allocation
		delete [] TowerEta_0_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerEta_1, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_1, tvout_TowerEta_1);

		sc_bv<16>* TowerEta_1_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerEta_1
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerEta(15, 0)
				{
					// carray: (1) => (1) @ (2)
					for (int i_0 = 1; i_0 <= 1; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerEta[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerEta[0]
						// regulate_c_name       : TowerEta
						// input_type_conversion : TowerEta[i_0]
						if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerEta_tmp_mem;
							TowerEta_tmp_mem = TowerEta[i_0];
							TowerEta_1_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerEta_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerEta_1, "%s\n", (TowerEta_1_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerEta_1, tvout_TowerEta_1);
		}

		tcl_file.set_num(1, &tcl_file.TowerEta_1_depth);
		sprintf(tvout_TowerEta_1, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_1, tvout_TowerEta_1);

		// release memory allocation
		delete [] TowerEta_1_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerEta_2, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_2, tvout_TowerEta_2);

		sc_bv<16>* TowerEta_2_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerEta_2
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerEta(15, 0)
				{
					// carray: (2) => (2) @ (2)
					for (int i_0 = 2; i_0 <= 2; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerEta[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerEta[0]
						// regulate_c_name       : TowerEta
						// input_type_conversion : TowerEta[i_0]
						if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerEta_tmp_mem;
							TowerEta_tmp_mem = TowerEta[i_0];
							TowerEta_2_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerEta_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerEta_2, "%s\n", (TowerEta_2_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerEta_2, tvout_TowerEta_2);
		}

		tcl_file.set_num(1, &tcl_file.TowerEta_2_depth);
		sprintf(tvout_TowerEta_2, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_2, tvout_TowerEta_2);

		// release memory allocation
		delete [] TowerEta_2_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerEta_3, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_3, tvout_TowerEta_3);

		sc_bv<16>* TowerEta_3_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerEta_3
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerEta(15, 0)
				{
					// carray: (3) => (3) @ (2)
					for (int i_0 = 3; i_0 <= 3; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerEta[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerEta[0]
						// regulate_c_name       : TowerEta
						// input_type_conversion : TowerEta[i_0]
						if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerEta_tmp_mem;
							TowerEta_tmp_mem = TowerEta[i_0];
							TowerEta_3_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerEta_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerEta_3, "%s\n", (TowerEta_3_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerEta_3, tvout_TowerEta_3);
		}

		tcl_file.set_num(1, &tcl_file.TowerEta_3_depth);
		sprintf(tvout_TowerEta_3, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_3, tvout_TowerEta_3);

		// release memory allocation
		delete [] TowerEta_3_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerEta_4, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_4, tvout_TowerEta_4);

		sc_bv<16>* TowerEta_4_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerEta_4
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerEta(15, 0)
				{
					// carray: (4) => (4) @ (2)
					for (int i_0 = 4; i_0 <= 4; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerEta[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerEta[0]
						// regulate_c_name       : TowerEta
						// input_type_conversion : TowerEta[i_0]
						if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerEta_tmp_mem;
							TowerEta_tmp_mem = TowerEta[i_0];
							TowerEta_4_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerEta_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerEta_4, "%s\n", (TowerEta_4_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerEta_4, tvout_TowerEta_4);
		}

		tcl_file.set_num(1, &tcl_file.TowerEta_4_depth);
		sprintf(tvout_TowerEta_4, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_4, tvout_TowerEta_4);

		// release memory allocation
		delete [] TowerEta_4_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerEta_5, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_5, tvout_TowerEta_5);

		sc_bv<16>* TowerEta_5_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerEta_5
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerEta(15, 0)
				{
					// carray: (5) => (5) @ (2)
					for (int i_0 = 5; i_0 <= 5; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerEta[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerEta[0]
						// regulate_c_name       : TowerEta
						// input_type_conversion : TowerEta[i_0]
						if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerEta_tmp_mem;
							TowerEta_tmp_mem = TowerEta[i_0];
							TowerEta_5_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerEta_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerEta_5, "%s\n", (TowerEta_5_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerEta_5, tvout_TowerEta_5);
		}

		tcl_file.set_num(1, &tcl_file.TowerEta_5_depth);
		sprintf(tvout_TowerEta_5, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_5, tvout_TowerEta_5);

		// release memory allocation
		delete [] TowerEta_5_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerEta_6, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_6, tvout_TowerEta_6);

		sc_bv<16>* TowerEta_6_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerEta_6
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerEta(15, 0)
				{
					// carray: (6) => (6) @ (2)
					for (int i_0 = 6; i_0 <= 6; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerEta[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerEta[0]
						// regulate_c_name       : TowerEta
						// input_type_conversion : TowerEta[i_0]
						if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerEta_tmp_mem;
							TowerEta_tmp_mem = TowerEta[i_0];
							TowerEta_6_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerEta_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerEta_6, "%s\n", (TowerEta_6_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerEta_6, tvout_TowerEta_6);
		}

		tcl_file.set_num(1, &tcl_file.TowerEta_6_depth);
		sprintf(tvout_TowerEta_6, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_6, tvout_TowerEta_6);

		// release memory allocation
		delete [] TowerEta_6_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerEta_7, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_7, tvout_TowerEta_7);

		sc_bv<16>* TowerEta_7_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerEta_7
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerEta(15, 0)
				{
					// carray: (7) => (7) @ (2)
					for (int i_0 = 7; i_0 <= 7; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerEta[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerEta[0]
						// regulate_c_name       : TowerEta
						// input_type_conversion : TowerEta[i_0]
						if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerEta_tmp_mem;
							TowerEta_tmp_mem = TowerEta[i_0];
							TowerEta_7_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerEta_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerEta_7, "%s\n", (TowerEta_7_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerEta_7, tvout_TowerEta_7);
		}

		tcl_file.set_num(1, &tcl_file.TowerEta_7_depth);
		sprintf(tvout_TowerEta_7, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_7, tvout_TowerEta_7);

		// release memory allocation
		delete [] TowerEta_7_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerEta_8, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_8, tvout_TowerEta_8);

		sc_bv<16>* TowerEta_8_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerEta_8
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerEta(15, 0)
				{
					// carray: (8) => (8) @ (2)
					for (int i_0 = 8; i_0 <= 8; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerEta[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerEta[0]
						// regulate_c_name       : TowerEta
						// input_type_conversion : TowerEta[i_0]
						if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerEta_tmp_mem;
							TowerEta_tmp_mem = TowerEta[i_0];
							TowerEta_8_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerEta_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerEta_8, "%s\n", (TowerEta_8_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerEta_8, tvout_TowerEta_8);
		}

		tcl_file.set_num(1, &tcl_file.TowerEta_8_depth);
		sprintf(tvout_TowerEta_8, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_8, tvout_TowerEta_8);

		// release memory allocation
		delete [] TowerEta_8_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerEta_9, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_9, tvout_TowerEta_9);

		sc_bv<16>* TowerEta_9_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerEta_9
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerEta(15, 0)
				{
					// carray: (9) => (9) @ (2)
					for (int i_0 = 9; i_0 <= 9; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerEta[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerEta[0]
						// regulate_c_name       : TowerEta
						// input_type_conversion : TowerEta[i_0]
						if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerEta_tmp_mem;
							TowerEta_tmp_mem = TowerEta[i_0];
							TowerEta_9_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerEta_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerEta_9, "%s\n", (TowerEta_9_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerEta_9, tvout_TowerEta_9);
		}

		tcl_file.set_num(1, &tcl_file.TowerEta_9_depth);
		sprintf(tvout_TowerEta_9, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_9, tvout_TowerEta_9);

		// release memory allocation
		delete [] TowerEta_9_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerEta_10, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_10, tvout_TowerEta_10);

		sc_bv<16>* TowerEta_10_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerEta_10
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerEta(15, 0)
				{
					// carray: (10) => (10) @ (2)
					for (int i_0 = 10; i_0 <= 10; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerEta[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerEta[0]
						// regulate_c_name       : TowerEta
						// input_type_conversion : TowerEta[i_0]
						if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerEta_tmp_mem;
							TowerEta_tmp_mem = TowerEta[i_0];
							TowerEta_10_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerEta_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerEta_10, "%s\n", (TowerEta_10_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerEta_10, tvout_TowerEta_10);
		}

		tcl_file.set_num(1, &tcl_file.TowerEta_10_depth);
		sprintf(tvout_TowerEta_10, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_10, tvout_TowerEta_10);

		// release memory allocation
		delete [] TowerEta_10_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerEta_11, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_11, tvout_TowerEta_11);

		sc_bv<16>* TowerEta_11_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerEta_11
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerEta(15, 0)
				{
					// carray: (11) => (11) @ (2)
					for (int i_0 = 11; i_0 <= 11; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerEta[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerEta[0]
						// regulate_c_name       : TowerEta
						// input_type_conversion : TowerEta[i_0]
						if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerEta_tmp_mem;
							TowerEta_tmp_mem = TowerEta[i_0];
							TowerEta_11_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerEta_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerEta_11, "%s\n", (TowerEta_11_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerEta_11, tvout_TowerEta_11);
		}

		tcl_file.set_num(1, &tcl_file.TowerEta_11_depth);
		sprintf(tvout_TowerEta_11, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_11, tvout_TowerEta_11);

		// release memory allocation
		delete [] TowerEta_11_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerEta_12, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_12, tvout_TowerEta_12);

		sc_bv<16>* TowerEta_12_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerEta_12
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerEta(15, 0)
				{
					// carray: (12) => (12) @ (2)
					for (int i_0 = 12; i_0 <= 12; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerEta[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerEta[0]
						// regulate_c_name       : TowerEta
						// input_type_conversion : TowerEta[i_0]
						if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerEta_tmp_mem;
							TowerEta_tmp_mem = TowerEta[i_0];
							TowerEta_12_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerEta_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerEta_12, "%s\n", (TowerEta_12_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerEta_12, tvout_TowerEta_12);
		}

		tcl_file.set_num(1, &tcl_file.TowerEta_12_depth);
		sprintf(tvout_TowerEta_12, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_12, tvout_TowerEta_12);

		// release memory allocation
		delete [] TowerEta_12_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerEta_13, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_13, tvout_TowerEta_13);

		sc_bv<16>* TowerEta_13_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerEta_13
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerEta(15, 0)
				{
					// carray: (13) => (13) @ (2)
					for (int i_0 = 13; i_0 <= 13; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerEta[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerEta[0]
						// regulate_c_name       : TowerEta
						// input_type_conversion : TowerEta[i_0]
						if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerEta_tmp_mem;
							TowerEta_tmp_mem = TowerEta[i_0];
							TowerEta_13_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerEta_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerEta_13, "%s\n", (TowerEta_13_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerEta_13, tvout_TowerEta_13);
		}

		tcl_file.set_num(1, &tcl_file.TowerEta_13_depth);
		sprintf(tvout_TowerEta_13, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_13, tvout_TowerEta_13);

		// release memory allocation
		delete [] TowerEta_13_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerEta_14, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_14, tvout_TowerEta_14);

		sc_bv<16>* TowerEta_14_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerEta_14
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerEta(15, 0)
				{
					// carray: (14) => (14) @ (2)
					for (int i_0 = 14; i_0 <= 14; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerEta[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerEta[0]
						// regulate_c_name       : TowerEta
						// input_type_conversion : TowerEta[i_0]
						if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerEta_tmp_mem;
							TowerEta_tmp_mem = TowerEta[i_0];
							TowerEta_14_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerEta_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerEta_14, "%s\n", (TowerEta_14_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerEta_14, tvout_TowerEta_14);
		}

		tcl_file.set_num(1, &tcl_file.TowerEta_14_depth);
		sprintf(tvout_TowerEta_14, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_14, tvout_TowerEta_14);

		// release memory allocation
		delete [] TowerEta_14_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerEta_15, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_15, tvout_TowerEta_15);

		sc_bv<16>* TowerEta_15_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerEta_15
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerEta(15, 0)
				{
					// carray: (15) => (15) @ (2)
					for (int i_0 = 15; i_0 <= 15; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerEta[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerEta[0]
						// regulate_c_name       : TowerEta
						// input_type_conversion : TowerEta[i_0]
						if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerEta_tmp_mem;
							TowerEta_tmp_mem = TowerEta[i_0];
							TowerEta_15_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerEta_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerEta_15, "%s\n", (TowerEta_15_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerEta_15, tvout_TowerEta_15);
		}

		tcl_file.set_num(1, &tcl_file.TowerEta_15_depth);
		sprintf(tvout_TowerEta_15, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_15, tvout_TowerEta_15);

		// release memory allocation
		delete [] TowerEta_15_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerEta_16, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_16, tvout_TowerEta_16);

		sc_bv<16>* TowerEta_16_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerEta_16
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerEta(15, 0)
				{
					// carray: (16) => (16) @ (2)
					for (int i_0 = 16; i_0 <= 16; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerEta[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerEta[0]
						// regulate_c_name       : TowerEta
						// input_type_conversion : TowerEta[i_0]
						if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerEta_tmp_mem;
							TowerEta_tmp_mem = TowerEta[i_0];
							TowerEta_16_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerEta_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerEta_16, "%s\n", (TowerEta_16_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerEta_16, tvout_TowerEta_16);
		}

		tcl_file.set_num(1, &tcl_file.TowerEta_16_depth);
		sprintf(tvout_TowerEta_16, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_16, tvout_TowerEta_16);

		// release memory allocation
		delete [] TowerEta_16_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerEta_17, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_17, tvout_TowerEta_17);

		sc_bv<16>* TowerEta_17_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerEta_17
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerEta(15, 0)
				{
					// carray: (17) => (17) @ (2)
					for (int i_0 = 17; i_0 <= 17; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerEta[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerEta[0]
						// regulate_c_name       : TowerEta
						// input_type_conversion : TowerEta[i_0]
						if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerEta_tmp_mem;
							TowerEta_tmp_mem = TowerEta[i_0];
							TowerEta_17_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerEta_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerEta_17, "%s\n", (TowerEta_17_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerEta_17, tvout_TowerEta_17);
		}

		tcl_file.set_num(1, &tcl_file.TowerEta_17_depth);
		sprintf(tvout_TowerEta_17, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_17, tvout_TowerEta_17);

		// release memory allocation
		delete [] TowerEta_17_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerEta_18, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_18, tvout_TowerEta_18);

		sc_bv<16>* TowerEta_18_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerEta_18
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerEta(15, 0)
				{
					// carray: (18) => (18) @ (2)
					for (int i_0 = 18; i_0 <= 18; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerEta[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerEta[0]
						// regulate_c_name       : TowerEta
						// input_type_conversion : TowerEta[i_0]
						if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerEta_tmp_mem;
							TowerEta_tmp_mem = TowerEta[i_0];
							TowerEta_18_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerEta_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerEta_18, "%s\n", (TowerEta_18_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerEta_18, tvout_TowerEta_18);
		}

		tcl_file.set_num(1, &tcl_file.TowerEta_18_depth);
		sprintf(tvout_TowerEta_18, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_18, tvout_TowerEta_18);

		// release memory allocation
		delete [] TowerEta_18_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerEta_19, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_19, tvout_TowerEta_19);

		sc_bv<16>* TowerEta_19_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerEta_19
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerEta(15, 0)
				{
					// carray: (19) => (19) @ (2)
					for (int i_0 = 19; i_0 <= 19; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerEta[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerEta[0]
						// regulate_c_name       : TowerEta
						// input_type_conversion : TowerEta[i_0]
						if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerEta_tmp_mem;
							TowerEta_tmp_mem = TowerEta[i_0];
							TowerEta_19_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerEta_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerEta_19, "%s\n", (TowerEta_19_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerEta_19, tvout_TowerEta_19);
		}

		tcl_file.set_num(1, &tcl_file.TowerEta_19_depth);
		sprintf(tvout_TowerEta_19, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_19, tvout_TowerEta_19);

		// release memory allocation
		delete [] TowerEta_19_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerEta_20, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_20, tvout_TowerEta_20);

		sc_bv<16>* TowerEta_20_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerEta_20
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerEta(15, 0)
				{
					// carray: (20) => (20) @ (2)
					for (int i_0 = 20; i_0 <= 20; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerEta[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerEta[0]
						// regulate_c_name       : TowerEta
						// input_type_conversion : TowerEta[i_0]
						if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerEta_tmp_mem;
							TowerEta_tmp_mem = TowerEta[i_0];
							TowerEta_20_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerEta_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerEta_20, "%s\n", (TowerEta_20_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerEta_20, tvout_TowerEta_20);
		}

		tcl_file.set_num(1, &tcl_file.TowerEta_20_depth);
		sprintf(tvout_TowerEta_20, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_20, tvout_TowerEta_20);

		// release memory allocation
		delete [] TowerEta_20_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerEta_21, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_21, tvout_TowerEta_21);

		sc_bv<16>* TowerEta_21_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerEta_21
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerEta(15, 0)
				{
					// carray: (21) => (21) @ (2)
					for (int i_0 = 21; i_0 <= 21; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerEta[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerEta[0]
						// regulate_c_name       : TowerEta
						// input_type_conversion : TowerEta[i_0]
						if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerEta_tmp_mem;
							TowerEta_tmp_mem = TowerEta[i_0];
							TowerEta_21_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerEta_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerEta_21, "%s\n", (TowerEta_21_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerEta_21, tvout_TowerEta_21);
		}

		tcl_file.set_num(1, &tcl_file.TowerEta_21_depth);
		sprintf(tvout_TowerEta_21, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_21, tvout_TowerEta_21);

		// release memory allocation
		delete [] TowerEta_21_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerEta_22, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_22, tvout_TowerEta_22);

		sc_bv<16>* TowerEta_22_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerEta_22
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerEta(15, 0)
				{
					// carray: (22) => (22) @ (2)
					for (int i_0 = 22; i_0 <= 22; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerEta[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerEta[0]
						// regulate_c_name       : TowerEta
						// input_type_conversion : TowerEta[i_0]
						if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerEta_tmp_mem;
							TowerEta_tmp_mem = TowerEta[i_0];
							TowerEta_22_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerEta_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerEta_22, "%s\n", (TowerEta_22_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerEta_22, tvout_TowerEta_22);
		}

		tcl_file.set_num(1, &tcl_file.TowerEta_22_depth);
		sprintf(tvout_TowerEta_22, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_22, tvout_TowerEta_22);

		// release memory allocation
		delete [] TowerEta_22_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerEta_23, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_23, tvout_TowerEta_23);

		sc_bv<16>* TowerEta_23_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerEta_23
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerEta(15, 0)
				{
					// carray: (23) => (23) @ (2)
					for (int i_0 = 23; i_0 <= 23; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerEta[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerEta[0]
						// regulate_c_name       : TowerEta
						// input_type_conversion : TowerEta[i_0]
						if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerEta_tmp_mem;
							TowerEta_tmp_mem = TowerEta[i_0];
							TowerEta_23_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerEta_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerEta_23, "%s\n", (TowerEta_23_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerEta_23, tvout_TowerEta_23);
		}

		tcl_file.set_num(1, &tcl_file.TowerEta_23_depth);
		sprintf(tvout_TowerEta_23, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_23, tvout_TowerEta_23);

		// release memory allocation
		delete [] TowerEta_23_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerEta_24, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_24, tvout_TowerEta_24);

		sc_bv<16>* TowerEta_24_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerEta_24
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerEta(15, 0)
				{
					// carray: (24) => (24) @ (2)
					for (int i_0 = 24; i_0 <= 24; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerEta[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerEta[0]
						// regulate_c_name       : TowerEta
						// input_type_conversion : TowerEta[i_0]
						if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerEta_tmp_mem;
							TowerEta_tmp_mem = TowerEta[i_0];
							TowerEta_24_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerEta_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerEta_24, "%s\n", (TowerEta_24_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerEta_24, tvout_TowerEta_24);
		}

		tcl_file.set_num(1, &tcl_file.TowerEta_24_depth);
		sprintf(tvout_TowerEta_24, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_24, tvout_TowerEta_24);

		// release memory allocation
		delete [] TowerEta_24_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerEta_25, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_25, tvout_TowerEta_25);

		sc_bv<16>* TowerEta_25_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerEta_25
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerEta(15, 0)
				{
					// carray: (25) => (25) @ (2)
					for (int i_0 = 25; i_0 <= 25; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerEta[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerEta[0]
						// regulate_c_name       : TowerEta
						// input_type_conversion : TowerEta[i_0]
						if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerEta_tmp_mem;
							TowerEta_tmp_mem = TowerEta[i_0];
							TowerEta_25_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerEta_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerEta_25, "%s\n", (TowerEta_25_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerEta_25, tvout_TowerEta_25);
		}

		tcl_file.set_num(1, &tcl_file.TowerEta_25_depth);
		sprintf(tvout_TowerEta_25, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_25, tvout_TowerEta_25);

		// release memory allocation
		delete [] TowerEta_25_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerEta_26, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_26, tvout_TowerEta_26);

		sc_bv<16>* TowerEta_26_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerEta_26
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerEta(15, 0)
				{
					// carray: (26) => (26) @ (2)
					for (int i_0 = 26; i_0 <= 26; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerEta[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerEta[0]
						// regulate_c_name       : TowerEta
						// input_type_conversion : TowerEta[i_0]
						if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerEta_tmp_mem;
							TowerEta_tmp_mem = TowerEta[i_0];
							TowerEta_26_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerEta_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerEta_26, "%s\n", (TowerEta_26_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerEta_26, tvout_TowerEta_26);
		}

		tcl_file.set_num(1, &tcl_file.TowerEta_26_depth);
		sprintf(tvout_TowerEta_26, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_26, tvout_TowerEta_26);

		// release memory allocation
		delete [] TowerEta_26_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerEta_27, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_27, tvout_TowerEta_27);

		sc_bv<16>* TowerEta_27_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerEta_27
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerEta(15, 0)
				{
					// carray: (27) => (27) @ (2)
					for (int i_0 = 27; i_0 <= 27; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerEta[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerEta[0]
						// regulate_c_name       : TowerEta
						// input_type_conversion : TowerEta[i_0]
						if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerEta_tmp_mem;
							TowerEta_tmp_mem = TowerEta[i_0];
							TowerEta_27_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerEta_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerEta_27, "%s\n", (TowerEta_27_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerEta_27, tvout_TowerEta_27);
		}

		tcl_file.set_num(1, &tcl_file.TowerEta_27_depth);
		sprintf(tvout_TowerEta_27, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_27, tvout_TowerEta_27);

		// release memory allocation
		delete [] TowerEta_27_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerEta_28, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_28, tvout_TowerEta_28);

		sc_bv<16>* TowerEta_28_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerEta_28
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerEta(15, 0)
				{
					// carray: (28) => (28) @ (2)
					for (int i_0 = 28; i_0 <= 28; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerEta[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerEta[0]
						// regulate_c_name       : TowerEta
						// input_type_conversion : TowerEta[i_0]
						if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerEta_tmp_mem;
							TowerEta_tmp_mem = TowerEta[i_0];
							TowerEta_28_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerEta_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerEta_28, "%s\n", (TowerEta_28_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerEta_28, tvout_TowerEta_28);
		}

		tcl_file.set_num(1, &tcl_file.TowerEta_28_depth);
		sprintf(tvout_TowerEta_28, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_28, tvout_TowerEta_28);

		// release memory allocation
		delete [] TowerEta_28_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_TowerEta_29, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_29, tvout_TowerEta_29);

		sc_bv<16>* TowerEta_29_tvout_wrapc_buffer = new sc_bv<16>[1];

		// RTL Name: TowerEta_29
		{
			// bitslice(15, 0)
			{
				int hls_map_index = 0;
				// celement: TowerEta(15, 0)
				{
					// carray: (29) => (29) @ (2)
					for (int i_0 = 29; i_0 <= 29; i_0 += 2)
					{
						// sub                   : i_0
						// ori_name              : TowerEta[i_0]
						// sub_1st_elem          : 0
						// ori_name_1st_elem     : TowerEta[0]
						// regulate_c_name       : TowerEta
						// input_type_conversion : TowerEta[i_0]
						if (&(TowerEta[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<16> TowerEta_tmp_mem;
							TowerEta_tmp_mem = TowerEta[i_0];
							TowerEta_29_tvout_wrapc_buffer[hls_map_index++].range(15, 0) = TowerEta_tmp_mem.range(15, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_TowerEta_29, "%s\n", (TowerEta_29_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_TowerEta_29, tvout_TowerEta_29);
		}

		tcl_file.set_num(1, &tcl_file.TowerEta_29_depth);
		sprintf(tvout_TowerEta_29, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_TowerEta_29, tvout_TowerEta_29);

		// release memory allocation
		delete [] TowerEta_29_tvout_wrapc_buffer;

		CodeState = DELETE_CHAR_BUFFERS;
		// release memory allocation: "towerET_0_0"
		delete [] tvin_towerET_0_0;
		// release memory allocation: "towerET_0_1"
		delete [] tvin_towerET_0_1;
		// release memory allocation: "towerET_0_2"
		delete [] tvin_towerET_0_2;
		// release memory allocation: "towerET_0_3"
		delete [] tvin_towerET_0_3;
		// release memory allocation: "towerET_1_0"
		delete [] tvin_towerET_1_0;
		// release memory allocation: "towerET_1_1"
		delete [] tvin_towerET_1_1;
		// release memory allocation: "towerET_1_2"
		delete [] tvin_towerET_1_2;
		// release memory allocation: "towerET_1_3"
		delete [] tvin_towerET_1_3;
		// release memory allocation: "towerET_2_0"
		delete [] tvin_towerET_2_0;
		// release memory allocation: "towerET_2_1"
		delete [] tvin_towerET_2_1;
		// release memory allocation: "towerET_2_2"
		delete [] tvin_towerET_2_2;
		// release memory allocation: "towerET_2_3"
		delete [] tvin_towerET_2_3;
		// release memory allocation: "towerET_3_0"
		delete [] tvin_towerET_3_0;
		// release memory allocation: "towerET_3_1"
		delete [] tvin_towerET_3_1;
		// release memory allocation: "towerET_3_2"
		delete [] tvin_towerET_3_2;
		// release memory allocation: "towerET_3_3"
		delete [] tvin_towerET_3_3;
		// release memory allocation: "towerET_4_0"
		delete [] tvin_towerET_4_0;
		// release memory allocation: "towerET_4_1"
		delete [] tvin_towerET_4_1;
		// release memory allocation: "towerET_4_2"
		delete [] tvin_towerET_4_2;
		// release memory allocation: "towerET_4_3"
		delete [] tvin_towerET_4_3;
		// release memory allocation: "towerET_5_0"
		delete [] tvin_towerET_5_0;
		// release memory allocation: "towerET_5_1"
		delete [] tvin_towerET_5_1;
		// release memory allocation: "towerET_5_2"
		delete [] tvin_towerET_5_2;
		// release memory allocation: "towerET_5_3"
		delete [] tvin_towerET_5_3;
		// release memory allocation: "towerET_6_0"
		delete [] tvin_towerET_6_0;
		// release memory allocation: "towerET_6_1"
		delete [] tvin_towerET_6_1;
		// release memory allocation: "towerET_6_2"
		delete [] tvin_towerET_6_2;
		// release memory allocation: "towerET_6_3"
		delete [] tvin_towerET_6_3;
		// release memory allocation: "towerET_7_0"
		delete [] tvin_towerET_7_0;
		// release memory allocation: "towerET_7_1"
		delete [] tvin_towerET_7_1;
		// release memory allocation: "towerET_7_2"
		delete [] tvin_towerET_7_2;
		// release memory allocation: "towerET_7_3"
		delete [] tvin_towerET_7_3;
		// release memory allocation: "towerET_8_0"
		delete [] tvin_towerET_8_0;
		// release memory allocation: "towerET_8_1"
		delete [] tvin_towerET_8_1;
		// release memory allocation: "towerET_8_2"
		delete [] tvin_towerET_8_2;
		// release memory allocation: "towerET_8_3"
		delete [] tvin_towerET_8_3;
		// release memory allocation: "towerET_9_0"
		delete [] tvin_towerET_9_0;
		// release memory allocation: "towerET_9_1"
		delete [] tvin_towerET_9_1;
		// release memory allocation: "towerET_9_2"
		delete [] tvin_towerET_9_2;
		// release memory allocation: "towerET_9_3"
		delete [] tvin_towerET_9_3;
		// release memory allocation: "towerET_10_0"
		delete [] tvin_towerET_10_0;
		// release memory allocation: "towerET_10_1"
		delete [] tvin_towerET_10_1;
		// release memory allocation: "towerET_10_2"
		delete [] tvin_towerET_10_2;
		// release memory allocation: "towerET_10_3"
		delete [] tvin_towerET_10_3;
		// release memory allocation: "towerET_11_0"
		delete [] tvin_towerET_11_0;
		// release memory allocation: "towerET_11_1"
		delete [] tvin_towerET_11_1;
		// release memory allocation: "towerET_11_2"
		delete [] tvin_towerET_11_2;
		// release memory allocation: "towerET_11_3"
		delete [] tvin_towerET_11_3;
		// release memory allocation: "towerET_12_0"
		delete [] tvin_towerET_12_0;
		// release memory allocation: "towerET_12_1"
		delete [] tvin_towerET_12_1;
		// release memory allocation: "towerET_12_2"
		delete [] tvin_towerET_12_2;
		// release memory allocation: "towerET_12_3"
		delete [] tvin_towerET_12_3;
		// release memory allocation: "towerET_13_0"
		delete [] tvin_towerET_13_0;
		// release memory allocation: "towerET_13_1"
		delete [] tvin_towerET_13_1;
		// release memory allocation: "towerET_13_2"
		delete [] tvin_towerET_13_2;
		// release memory allocation: "towerET_13_3"
		delete [] tvin_towerET_13_3;
		// release memory allocation: "towerET_14_0"
		delete [] tvin_towerET_14_0;
		// release memory allocation: "towerET_14_1"
		delete [] tvin_towerET_14_1;
		// release memory allocation: "towerET_14_2"
		delete [] tvin_towerET_14_2;
		// release memory allocation: "towerET_14_3"
		delete [] tvin_towerET_14_3;
		// release memory allocation: "towerET_15_0"
		delete [] tvin_towerET_15_0;
		// release memory allocation: "towerET_15_1"
		delete [] tvin_towerET_15_1;
		// release memory allocation: "towerET_15_2"
		delete [] tvin_towerET_15_2;
		// release memory allocation: "towerET_15_3"
		delete [] tvin_towerET_15_3;
		// release memory allocation: "towerET_16_0"
		delete [] tvin_towerET_16_0;
		// release memory allocation: "towerET_16_1"
		delete [] tvin_towerET_16_1;
		// release memory allocation: "towerET_16_2"
		delete [] tvin_towerET_16_2;
		// release memory allocation: "towerET_16_3"
		delete [] tvin_towerET_16_3;
		// release memory allocation: "TowerPhi_0"
		delete [] tvout_TowerPhi_0;
		// release memory allocation: "TowerPhi_1"
		delete [] tvout_TowerPhi_1;
		// release memory allocation: "TowerPhi_2"
		delete [] tvout_TowerPhi_2;
		// release memory allocation: "TowerPhi_3"
		delete [] tvout_TowerPhi_3;
		// release memory allocation: "TowerPhi_4"
		delete [] tvout_TowerPhi_4;
		// release memory allocation: "TowerPhi_5"
		delete [] tvout_TowerPhi_5;
		// release memory allocation: "TowerPhi_6"
		delete [] tvout_TowerPhi_6;
		// release memory allocation: "TowerPhi_7"
		delete [] tvout_TowerPhi_7;
		// release memory allocation: "TowerPhi_8"
		delete [] tvout_TowerPhi_8;
		// release memory allocation: "TowerPhi_9"
		delete [] tvout_TowerPhi_9;
		// release memory allocation: "TowerPhi_10"
		delete [] tvout_TowerPhi_10;
		// release memory allocation: "TowerPhi_11"
		delete [] tvout_TowerPhi_11;
		// release memory allocation: "TowerPhi_12"
		delete [] tvout_TowerPhi_12;
		// release memory allocation: "TowerPhi_13"
		delete [] tvout_TowerPhi_13;
		// release memory allocation: "TowerPhi_14"
		delete [] tvout_TowerPhi_14;
		// release memory allocation: "TowerPhi_15"
		delete [] tvout_TowerPhi_15;
		// release memory allocation: "TowerPhi_16"
		delete [] tvout_TowerPhi_16;
		// release memory allocation: "TowerPhi_17"
		delete [] tvout_TowerPhi_17;
		// release memory allocation: "TowerPhi_18"
		delete [] tvout_TowerPhi_18;
		// release memory allocation: "TowerPhi_19"
		delete [] tvout_TowerPhi_19;
		// release memory allocation: "TowerPhi_20"
		delete [] tvout_TowerPhi_20;
		// release memory allocation: "TowerPhi_21"
		delete [] tvout_TowerPhi_21;
		// release memory allocation: "TowerPhi_22"
		delete [] tvout_TowerPhi_22;
		// release memory allocation: "TowerPhi_23"
		delete [] tvout_TowerPhi_23;
		// release memory allocation: "TowerPhi_24"
		delete [] tvout_TowerPhi_24;
		// release memory allocation: "TowerPhi_25"
		delete [] tvout_TowerPhi_25;
		// release memory allocation: "TowerPhi_26"
		delete [] tvout_TowerPhi_26;
		// release memory allocation: "TowerPhi_27"
		delete [] tvout_TowerPhi_27;
		// release memory allocation: "TowerPhi_28"
		delete [] tvout_TowerPhi_28;
		// release memory allocation: "TowerPhi_29"
		delete [] tvout_TowerPhi_29;
		// release memory allocation: "TowerEta_0"
		delete [] tvout_TowerEta_0;
		// release memory allocation: "TowerEta_1"
		delete [] tvout_TowerEta_1;
		// release memory allocation: "TowerEta_2"
		delete [] tvout_TowerEta_2;
		// release memory allocation: "TowerEta_3"
		delete [] tvout_TowerEta_3;
		// release memory allocation: "TowerEta_4"
		delete [] tvout_TowerEta_4;
		// release memory allocation: "TowerEta_5"
		delete [] tvout_TowerEta_5;
		// release memory allocation: "TowerEta_6"
		delete [] tvout_TowerEta_6;
		// release memory allocation: "TowerEta_7"
		delete [] tvout_TowerEta_7;
		// release memory allocation: "TowerEta_8"
		delete [] tvout_TowerEta_8;
		// release memory allocation: "TowerEta_9"
		delete [] tvout_TowerEta_9;
		// release memory allocation: "TowerEta_10"
		delete [] tvout_TowerEta_10;
		// release memory allocation: "TowerEta_11"
		delete [] tvout_TowerEta_11;
		// release memory allocation: "TowerEta_12"
		delete [] tvout_TowerEta_12;
		// release memory allocation: "TowerEta_13"
		delete [] tvout_TowerEta_13;
		// release memory allocation: "TowerEta_14"
		delete [] tvout_TowerEta_14;
		// release memory allocation: "TowerEta_15"
		delete [] tvout_TowerEta_15;
		// release memory allocation: "TowerEta_16"
		delete [] tvout_TowerEta_16;
		// release memory allocation: "TowerEta_17"
		delete [] tvout_TowerEta_17;
		// release memory allocation: "TowerEta_18"
		delete [] tvout_TowerEta_18;
		// release memory allocation: "TowerEta_19"
		delete [] tvout_TowerEta_19;
		// release memory allocation: "TowerEta_20"
		delete [] tvout_TowerEta_20;
		// release memory allocation: "TowerEta_21"
		delete [] tvout_TowerEta_21;
		// release memory allocation: "TowerEta_22"
		delete [] tvout_TowerEta_22;
		// release memory allocation: "TowerEta_23"
		delete [] tvout_TowerEta_23;
		// release memory allocation: "TowerEta_24"
		delete [] tvout_TowerEta_24;
		// release memory allocation: "TowerEta_25"
		delete [] tvout_TowerEta_25;
		// release memory allocation: "TowerEta_26"
		delete [] tvout_TowerEta_26;
		// release memory allocation: "TowerEta_27"
		delete [] tvout_TowerEta_27;
		// release memory allocation: "TowerEta_28"
		delete [] tvout_TowerEta_28;
		// release memory allocation: "TowerEta_29"
		delete [] tvout_TowerEta_29;

		AESL_transaction++;

		tcl_file.set_num(AESL_transaction , &tcl_file.trans_num);
	}
}

